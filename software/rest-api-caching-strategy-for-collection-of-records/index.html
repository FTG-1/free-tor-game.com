<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>REST API caching strategy for collection of records &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1076035 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1076035" class="post-1076035 software type-software status-publish hentry category-software tag-api-design tag-http tag-rest"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">REST API caching strategy for collection of records</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">api-design</span><span class="mr-2 badge badge-info">http</span><span class="mr-2 badge badge-warning">rest</span></p><div class="entry-content"><p>I am designing a REST API for my mobile clients to interact with our app server (built with Django/django-rest-framework if it makes any difference).</p><p>There are a number of different objects accessible through the API, some changing frequently (say daily), some almost never changing (on average less than once per month), and some for which only some nested records will be changing (think a blog post for which we add new comments a few times a day).</p><p>Because the clients are sensitive to data transfer volume (for cost reasons, mobile data in developing country), I want to limit this, especially when they download a list of object (eg: the list of blog posts objects mentioned earlier). Data transfer is by far my biggest concern here, long before server-side load.</p><p>I have thought of using something similar to the HTTP <code>If-Modified-Since</code> header (<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" rel="noreferrer">https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html</a> section 14.25), that could work on individual object requests, like GET <code>/api/blogposts/&lt;id&gt;/</code>. But with high network latency (ping times of over 500ms are common), running dozens or hundreds of requests seems like a bad idea.</p><p>To obtain a collection of records, I would expect the following behaviour to help more in my case (the requests I&#39;m talking about are similar to what is described in <a href="https://softwareengineering.stackexchange.com/a/293612/170488">this answer</a>: taylored collections per user)</p><p>GET <code>/api/myblogposts/</code> would initially return a JSON list of objects, not just the IDs:</p><pre><code>[
&#39;post1&#39;: {...},
&#39;post2&#39;: {...},
...
&#39;postN&#39;: {...}
]
</code></pre><p>Then a subsequent GET on the same url with appropriate header <code>If-Modified-Since: Sat, 29 Oct 2016 19:43:31 GMT</code> would filter the list to return only records modified since then. The client can then merge the changes into its local data store.</p><p>Does this strategy seem to make sense? Is there some existing standard for client and server to negotiate what subset of records to transfer?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>If you really think about it, if a record has not changed, it is in a sense &#34;cached&#34; already, because that <code>updated_at</code> timestamp has not changed; thus, your intuition about only fetching records that have been modified is the best way to go about this &#34;caching&#34;. However, I wouldn&#39;t really call it &#34;caching&#34;, but rather &#34;selective retrieval&#34;.</p><p>However, as @Joeri Sebrechts mentioned in his comment, using HTTP heads in a <em>non-standard fashion</em> is a really good way to annoy maintainers of your code as they struggle to figure out why you&#39;re using <code>If-Modified-Since</code> like a query parameter to filter records. In fact, that&#39;s exactly why he suggested using a query parameter - they&#39;re used exactly for this purpose - and I fully agree.</p><p>So the solution here is to:</p><ol><li>Initially, fetch <em>all</em> records that you need (e.g. at startup)<ul><li>store this value on the client as a timestamp - <code>changed-after</code> (or whatever you want to name it - when doing the GET</li><li>make sure that the record <code>id</code> is included so you can do some fancy merging with existing records later</li></ul></li><li>When the client needs to retrieve new records or update the list, simply send another GET to e.g. <code>/records?changed-after=THE_STORED_TIMESTAMP</code><ul><li>your API will only retrieve records with <code>updated_at &gt; changed-after</code></li><li>send those records back to the client</li></ul></li><li>On the client, do a merge operation on your existing list of records<ul><li>do not <em>delete</em> records from the list</li><li>simply take the set of <strong>new</strong> records, find them in the old list, and replace them</li><li>leave the rest of the list unmodified</li></ul></li></ol><p>Some other applications use <strong>websockets</strong> to communicate changes to clients; e.g. the server detects a change in a record and pings all clients that an update is available for retrieval. That would be, in my opinion, the more &#34;efficient&#34; way to do things in the event that you have millions upon millions of records that might take a long time to query, and you have the bandwidth available for websockets. Instead of having clients constantly querying for updates that may or may not be available (and the possibility of those queries being expensive), you simply have the server tell clients when they need to update.</p><p>However, we don&#39;t know anything about the quantity and complexity of your data, but the simple fact that you have a high-latency and low-bandwitdth situation kind of eliminates the possibility of using websockets, so the query parameter <code>update_at</code> filter seems to be the most appropriate approach.</p><p><strong>PS</strong> - If you&#39;re <em>really really really</em> tight on data, you could even implement a changelog of your records to know <em>which fields changed</em>, allowing you to selectively send only the fields that were actually updated, instead of the entire record. Some frameworks/languages have libraries that do this, e.g. Rails&#39; <a href="https://github.com/airblade/paper_trail" rel="nofollow noreferrer">Paper Trail</a>. If you think that the need for very low bandwidth usage is worth adding such a dependency, I would highly recommend it. Sometimes these libraries make it ridiculously easy, like Paper Trails&#39; <a href="https://github.com/airblade/paper_trail#3c-diffing-versions" rel="nofollow noreferrer">methods to diff versions</a> which gives you only the data that was changed. So you could send only that dat, along with the record&#39;s <code>id</code>, and selectively merge on the client on a <em>field</em> basis instead of a <em>whole record</em> basis. Neat!</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../sending-a-collection-of-data-to-an-api-multiple-small-calls-vs-one-big-call/'>Sending a collection of data to an API. Multiple small calls vs one big call</a></li><li class="list-group-item"><a href='../rest-how-to-safeguard-a-rest-api-for-only-trusted-mobile-applications/'>Rest &#8211; How to safeguard a REST API for only trusted mobile applications</a></li><li class="list-group-item"><a href='../how-should-data-transfer-between-a-client-and-a-web-api-for-normalized-data-be-designed/'>How should data transfer between a client and a web API for normalized data be designed</a></li><li class="list-group-item"><a href='../rest-api-paging-via-headers/'>REST API paging via headers</a></li><li class="list-group-item"><a href='../web-development-two-way-data-synchronization-between-web-application-and-rest-api-server/'>Web-development &#8211; Two way data synchronization between web application and REST API server</a></li><li class="list-group-item"><a href='../rest-using-304-not-modified-and-if-modified-since-on-a-rest-api-as-a-cache-strategy/'>Rest &#8211; Using `304 Not Modified` and `If-Modified-Since` on a REST API as a cache strategy</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>