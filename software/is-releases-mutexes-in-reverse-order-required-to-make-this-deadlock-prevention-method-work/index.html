<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Is &#8220;releases mutexes in reverse order&#8221; required to make this deadlock-prevention method work &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1074259 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1074259" class="post-1074259 software type-software status-publish hentry category-software tag-concurrency tag-deadlines tag-mutex tag-semaphore tag-synchronization"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Is &#8220;releases mutexes in reverse order&#8221; required to make this deadlock-prevention method work</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">concurrency</span><span class="mr-2 badge badge-info">deadlines</span><span class="mr-2 badge badge-warning">mutex</span><span class="mr-2 badge badge-primary">semaphore</span><span class="mr-2 badge badge-danger">synchronization</span></p><div class="entry-content"><p>Operating System Concepts says</p><blockquote><p>7.4.4 Circular Wait</p><p>The fourth and ﬁnal condition for deadlocks is the circular-wait condition. One<br /> way to ensure that this condition never holds is to <strong>impose a total ordering of<br /> all resource types</strong> and to require that <strong>each process requests resources in an<br /> increasing order of enumeration</strong>.</p></blockquote><p>Computers Systems: a Programmer&#39;s Perspective says</p><blockquote><p>Programs deadlock for many reasons, and preventing them is a difﬁcult problem in general. However, when binary semaphores are used for mutual exclusion,<br /> as in Figure 12.44, then you can apply the following simple and effective rule to<br /> prevent deadlocks:</p></blockquote><blockquote><p>Mutex lock ordering rule: Given a total ordering of all mutexes, a program is<br /> deadlock-free if each thread acquires its mutexes in order and <strong>releases them in<br /> reverse order</strong>.</p></blockquote><p>Is it correct that both describe the same deadlock-prevention method?</p><p>If yes, in this deadlock-prevention method:</p><ul><li><p>Is &#34;releases mutexes in reverse order&#34; required to make this deadlock-prevention method work? (It appears in the second book, but not in the first book.)</p></li><li><p>Does the order between releases of the mutexes matter to existence of deadlock? (For example, for two semaphores s and t, order P(s), P(t), V(t), V(s), and order P(s), P(t), V(s), V(t))</p></li></ul><p>Thanks.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>For a deadlock (more specifically, a <em>circular wait</em>) to occur, there needs to be a circular chain of <em>n</em> ≥ 2 mutexes (or other exclusively lockable resources) <em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>, …, <em>R</em><sub><em>n</em></sub> such that, for each <em>k</em> from 1 to <em>n</em>−1, the current owner of <em>R</em><sub><em>k</em></sub> is waiting for <em>R</em><sub><em>k</em>+1</sub>, while the current owner of <em>R</em><sub><em>n</em></sub> is waiting for <em>R</em><sub>1</sub>.</p><p>To prevent such a circular wait situation from occurring, it is sufficient to define some total order on the mutexes and require that <strong>no thread ever tries to acquire a mutex while holding another mutex further up in the order.</strong></p><p>This requirement guarantees that, while it&#39;s possible to have a chain of <em>n</em> mutexes <em>R</em><sub><em>k</em></sub>, 1 ≤ <em>k</em> ≤ <em>n</em>, with each mutex <em>R</em><sub><em>k</em></sub> other than the last being held by a thread waiting for mutex <em>R</em><sub><em>k</em>+1</sub>, any such chain of mutexes must necessarily be ascending in the total order, and thus the holder of the last mutex <em>R</em><sub><em>n</em></sub> in such an ascending chain may not attempt to acquire any earlier mutex in the chain.</p><hr/><p>This requirement is <strong>slightly weaker</strong> than the one given in the books you quote.  In particular, while it still requires threads to acquire mutexes in ascending order, it does not <em>quite</em> require them to always release them in the reverse order.</p><p>For example, let the mutexes A and B be ordered such that A &lt; B.  Now, under the requirement given above, both of the following sequences of operations are permissible.</p><blockquote><ol><li>Acquire A; acquire B; release B; release A.</li><li>Acquire A; acquire B; release A; release B.</li></ol></blockquote><p>and so are both of the following:</p><blockquote><ol start="3"><li>Acquire A; acquire B; release B; acquire B; release B; release A.</li><li>Acquire A; acquire B; release B; acquire B; release A; release B.</li></ol></blockquote><p>but the following sequence is not:</p><blockquote><ol start="5"><li>Acquire A; acquire B; release A; <strong>acquire A</strong>; …</li></ol></blockquote><p>The problematic event that can trigger a deadlock here is not the release of A before B, but rather <em>trying to acquire A while holding B.</em> This is because another thread might have grabbed the mutex A when it was released, and trying to reacquire it while still holding B could deadlock if the new owner of A was waiting for B to be released.</p><p>Of course, requiring threads to always release mutexes in reverse order of acquisition would also forbid the problematic sequence #5 above, since the thread would have to release B before releasing A, and thus couldn&#39;t hold B any more when it tried to reacquire A.  But this stronger requirement would also forbid the perfectly safe and harmless sequences #2 and #4.</p><hr/><p>Now, at this point, all of this might seem like needless pedantry: after all, if you&#39;re going to release both A and B anyway, isn&#39;t it kind of obvious that the order doesn&#39;t really matter, and <em>wouldn&#39;t it be perfectly reasonable to always release B first anyway, thus sticking to the simple &#34;release in reverse order&#34; rule?</em></p><p>Well, no, not really.</p><p>First of all, the order of consequent mutex releases can actually matter for performance, even if it doesn&#39;t matter for correctness.  For example, consider the following variant of sequence #2 above, where the thread is performing some slow processing that initially requires both A and B, but where A is only used at the start of the processing:</p><blockquote><p>Acquire A; acquire B; (<em>start processing</em>); release A; (<em>continue slow processing while holding only B</em>); release B.</p></blockquote><p>Now, any other thread that only needs mutex A can execute concurrently during most of the slow processing, which wouldn&#39;t be possible if the slow thread had to keep holding A until it can release B.</p><p>Also, with more mutexes, the weaker condition (&#34;never acquire an earlier mutex while holding a later one&#34;) can actually permit qualitatively distinct access patterns that the stronger condition (&#34;always acquire in ascending and release in descending order&#34;) would forbid.  For example, the weaker condition allows a thread to &#34;climb&#34; an ascending chain of mutexes while always holding only a subset of them, as in:</p><blockquote><p>Acquire A; acquire B; (<em>do something with A and B</em>); release A; acquire C; (<em>do something with B and C</em>); release B; acquire D; (<em>do something with C and D</em>); …</p></blockquote><p>In particular, two or more such threads can safely and efficiently run concurrently, with the second thread starting to process resources A and B as soon as the first one has released them both, while the first thread is now working on C and D.</p><p>If mutexes had to always be released in reverse order of acquisition, however, this sequence of operations would be forbidden, and would have to be replaced ether with something like this:</p><blockquote><p>Acquire A; acquire B; (<em>do something with A and B</em>); acquire C; (<em>do something with B and C</em>); acquire D; (<em>do something with C and D</em>); …; release D; release C; release B; release A.</p></blockquote><p>which prevents any concurrent execution of such threads, since the mutex A isn&#39;t released until the whole &#34;climb&#34; is finished, or possibly with something like this:</p><blockquote><p>Acquire A; acquire B; (<em>do something with A and B</em>); release B; release A; acquire B; acquire C; (<em>do something with B and C</em>); release C; release B; …</p></blockquote><p>which may not be feasible if the resource protected by mutex B cannot be safely accessed by other threads between the two processing steps.</p><hr/><p>That said, neither of your books presents the &#34;acquire in ascending and release in descending order&#34; rule as anything but a <em>sufficient</em> requirement to prevent deadlocks, which it is.  It&#39;s just not a <em>necessary</em> requirement for deadlock prevention (and, indeed, neither is the weaker requirement I gave above).</p><p>And, in something like 99% of all cases, &#34;acquire in ascending and release in descending order&#34; is perfectly practical and suitable.  Indeed, the difficult part of implementing this rule isn&#39;t usually the &#34;release in descending order&#34; part, which is easily accomplished e.g. by storing acquired locks on a stack, but ensuring that the mutexes get acquired in a consistent order in the first place.</p><p>And that part — ensuring that threads competing for mutexes attempt to acquire them in a consistent same order — <em>is</em> necessary to avoid deadlocks.  In particular, if one thread tries to first acquire A and then B, while another thread tries to first acquire B and the A, then those threads are vulnerable to deadlocks regardless of the order in which they might be planning to later release those mutexes.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   </div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>