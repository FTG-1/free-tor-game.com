<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Why does LLVM have an assembly-like IR rather than a tree-like IR? Or: why do projects target LLVM IR instead of clang&#8217;s AST &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1076780 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1076780" class="post-1076780 software type-software status-publish hentry category-software tag-clang tag-compiler tag-llvm tag-programming-languages"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Why does LLVM have an assembly-like IR rather than a tree-like IR? Or: why do projects target LLVM IR instead of clang&#8217;s AST</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">clang</span><span class="mr-2 badge badge-info">compiler</span><span class="mr-2 badge badge-warning">llvm</span><span class="mr-2 badge badge-primary">programming-languages</span></p><div class="entry-content"><p>Why is LLVM&#39;s intermediate representation (LLVM IR) assembly-like rather than tree-like?</p><p>Alternatively, why do language implementations target LLVM IR rather than clang&#39;s AST?</p><p>I&#39;m not trying to ask two different questions at once if it seems that way. To me, it simply seems like both client and library programmers have come to the consensus that LLVM&#39;s API, nothing more and nothing less, is obviously good software design and my question is &#34;why?&#34;.</p><p>The reason I ask is that it seems like LLVM could provide more functionality to frontends if it&#39;s IR was AST-like because then clang&#39;s AST-based tools could be used for any frontend. Alternatively, languages that target LLVM IR could get more functionality if they targeted clang&#39;s AST.</p><p>Clang has classes and functions for creating and working with ASTs and it&#39;s the <em>only</em> frontend project that&#39;s strongly tied to the LLVM project so why is clang&#39;s AST-functionality external to LLVM?</p><p>Off the top of my head, I know that Rust (rustc), D (ldc), and Haskell (GHC) can all use LLVM as a backend but they don&#39;t use the Clang AST (as far as I know, I could be wrong). I don&#39;t know all the internal details of these compilers but at least Rust and D certainly seem like they could be compiled to clang&#39;s AST. Maybe Haskell could too, but I&#39;m much less certain about that.</p><p>Is this because of historical reasons (LLVM originally being a &#34;low-level virtual machine&#34; and clang coming along later)? Is this because other frontends want to have as much control as possible over what they feed to LLVM? Are there fundamental reasons that clang&#39;s AST is inappropriate for &#34;non-C-like&#34; languages?</p><p>I don&#39;t intend this question to be an exercise in mindreading. I just want it to be helpful to those of us who are curious about, but not already fluent in, compiler design. Since the LLVM and clang projects are developed in public, I&#39;m hoping that someone familiar with the development of these projects can answer or that the answer is obvious enough to some compile nerds that they feel confident enough to answer.</p><hr/><p>To pre-empt some obvious but unsatisfactory answers:</p><p>Yes, having an assembly-like IR gives more control to whoever crafts the IR (perhaps X lang has a better codebase and AST format than clang) but if that&#39;s the only answer, then the question becomes &#34;why does LLVM <em>only</em> have an assembly-like IR instead of a high level tree-like IR and a low-level assembly-like IR?&#34;.</p><p>Yes, it&#39;s not that hard to parse a programming language into an AST (at least compared to the other steps of compiling). Even so, why use separate ASTs? If nothing else, using the same AST allows you to use tools that operate on ASTs (even just simple things like AST printers).</p><p>Yes, I <em>strongly</em> agree that being more modular is a good thing, but if that&#39;s the only reason, then why do other language implementations tend to target LLVM IR instead of clang&#39;s AST?</p><p>These pre-emptions might be erroneous or overlook details, so do feel free to give these answers if you have more details or my assumptions are mistaken.</p><hr/><p>For anyone wanting to answer a more definitively answerable question: what are the advantages and disadvantages of an assembly-like IR vs a tree-like IR?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>There&#39;s a number of inter-related questions here, I&#39;ll try to separate them as best I can.</p><p><strong>Why do other languages build on LLVM IR and not clang AST?</strong></p><p>This is simply because clang is a C/C++ front end and the AST it produces is tightly coupled to C/C++. Another language could use it but it would need near identical semantics to some subset of C/C++ which is very limiting. As you point out, parsing to an AST is fairly straightforward so restricting your semantic choices is unlikely to be worth the small saving.</p><p>However, if you&#39;re writing tooling for C/C++ e.g. static analysers, then re-using the AST makes a lot of sense as it&#39;s a lot easier to work with the AST than the raw text iff you&#39;re working with C/C++.</p><p><strong>Why is LLVM IR the form it is?</strong></p><p>LLVM IR was chosen as an appropriate form to write compiler optimisations. As such, it&#39;s primary feature is that it&#39;s in <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form" rel="noreferrer">SSA</a> form. It&#39;s quite a low level IR so that it is applicable to a wide range of languages e.g. it doesn&#39;t type memory as this varies a lot across languages.</p><p>Now, it happens to be the case that writing compiler optimisations is quite a specialist task and is often orthogonal to language feature design. However, having a compiled language run fast is a fairly general requirement. Also, the conversion from LLVM IR to ASM is fairly mechanical and not generally interesting to language designers either.</p><p>Therefore, lowering a language to LLVM IR gives a language designer a lot of &#34;free stuff&#34; that is very useful in practice leaving them to concentrate on the language itself.</p><p><strong>Would a different IR be useful (OK, not asked but sort of implied)?</strong></p><p>Absolutely! ASTs are quite good for certain transformations on the program structure but are very hard to use if you want to transform program flow. An SSA form is generally better. However, LLVM IR is very low level so a lot of the high level structure is lost (on purpose so it&#39;s more generally applicable). Having an IR between the AST and the low level IR can be beneficial here. Both Rust and Swift take this approach and have a high level IR between the two.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../reason-to-use-mingw-win32-headers-and-libs-with-llvm-clang/'>Reason to use mingw win32 headers and libs with LLVM/Clang</a></li><li class="list-group-item"><a href='../clang-warning-flags-for-objective-c-development/'>Clang warning flags for Objective-C development</a></li><li class="list-group-item"><a href='../how-to-add-link-time-optimization-capabilities-to-the-llvm-based-compiler/'>How to add link-time optimization capabilities to the LLVM-based compiler</a></li><li class="list-group-item"><a href='../c-metaprogramming-with-a-compiler-api-rather-than-with-c-features/'>C++: Metaprogramming with a compiler API rather than with C++ features</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>