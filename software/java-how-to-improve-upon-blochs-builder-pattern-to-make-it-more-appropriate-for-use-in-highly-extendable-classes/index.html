<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Java &#8211; How to improve upon Bloch&#8217;s Builder Pattern, to make it more appropriate for use in highly-extendable classes &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1064695 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1064695" class="post-1064695 software type-software status-publish hentry category-software tag-design tag-design-patterns tag-java tag-object-oriented"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Java &#8211; How to improve upon Bloch&#8217;s Builder Pattern, to make it more appropriate for use in highly-extendable classes</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">design</span><span class="mr-2 badge badge-info">design-patterns</span><span class="mr-2 badge badge-warning">java</span><span class="mr-2 badge badge-primary">object-oriented</span></p><div class="entry-content"><p>I have been greatly influenced by Joshua Bloch&#39;s Effective Java book (2nd edition), probably more so than with any programming book I&#39;ve read. In particular, his Builder Pattern (item 2) has had the greatest effect.</p><p>Despite Bloch&#39;s builder getting me much farther in the couple of months than in my past ten years of programming, I am still finding myself hitting the same wall: Extending classes with self-returning method-chains is at best discouraging, and at worst a nightmare&#8211;especially when generics come into play, and <em>especially</em> with <strong><em>self-referential generics</em></strong> (such as <code>Comparable&lt;T extends Comparable&lt;T&gt;&gt;</code>).</p><p>There are two primary needs that I have, only the second of which I&#39;d like to focus on in this question:</p><ol><li><p>The first problem is &#34;how to share self-returning method chains, without having to re-implement them in every&#8230;single&#8230;class?&#34; For those who may be curious, I&#39;ve addressed this part at the bottom of this answer-post, but it&#39;s not what I want to focus on here.</p></li><li><p>The second problem, which I am asking for comment on, is &#34;how can I implement a builder in classes that are themselves intended to be extended by many other classes?&#34; Extending a class with a builder is naturally more difficult than extending one without. Extending a class that has a builder <em>that also implements <code>Needable</code>, and therefore has significant generics associated to it</em>, is unwieldy.</p></li></ol><p>So that is my question: How can I improve upon (what I call) the Bloch Builder, so I can feel free to attach a builder to <em>any</em> class&#8211;even when that class is meant to be a &#34;base class&#34; that may be extended and sub-extended many times over&#8211;<em>without discouraging my future-self, or users of my library</em>, because of the extra baggage the builder (and its potential generics) impose on them?</p><hr/><p><em><strong>Addendum</strong></em><br /> My question focuses on part 2 above, but I wanted to elaborate a bit on problem one, including how I&#39;ve dealt with it:</p><p>The first problem is &#34;how to share self-returning method chains, without having to re-implement them in every&#8230;single&#8230;class?&#34; This is not to prevent <em>extending classes</em> from having to re-implement these chains, which, of course, they must&#8211;rather, how to prevent <em>non-sub-classes</em>, that want to take advantage of these method chains, from having to re-implement every self-returning function in order for <em>their</em> users to be able to take advantage of them? For this I&#39;ve come up with a needer-needable design that I&#39;ll print the interface skeletons for here, and leave it at that for now. It has worked well for me (this design was years in the making&#8230;the hardest part was avoiding circular dependencies):</p><pre><code>public interface Chainable  {  
    Chainable chainID(boolean b_setStatic, Object o_id);  
    Object getChainID();  
    Object getStaticChainID();  
}
public interface Needable&lt;O,R extends Needer&gt; extends Chainable  {
    boolean isAvailableToNeeder();
    Needable&lt;O,R&gt; startConfigReturnNeedable(R n_eeder);
    R getActiveNeeder();
    boolean isNeededUsable();
    R endCfg();
}
public interface Needer  {
    void startConfig(Class&lt;?&gt; cls_needed);
    boolean isConfigActive();
    Class getNeededType();
    void neeadableSetsNeeded(Object o_fullyConfigured);
}
</code></pre></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>I have created what, for me, is a big improvement over Josh Bloch&#39;s Builder Pattern. Not to say in any way that it is &#34;better&#34;, just that in a <em>very specific situation</em>, it does provide some advantages--the biggest being that it decouples the builder from its to-be-built class.</p><p>I have thoroughly documented this alternative below, which I call the Blind Builder Pattern.</p><hr/><p></p><h1>Design Pattern: Blind Builder</h1><p></p><p></p><p>As an alternative to Joshua Bloch&#39;s <a href="http://www.informit.com/articles/article.aspx?p=1216151&amp;seqNum=2" rel="nofollow noreferrer">Builder Pattern</a> (item 2 in Effective Java, 2nd edition), I have created what I call the &#34;Blind Builder Pattern&#34;, which shares many of the benefits of the Bloch Builder and, aside from a single character, is used in exactly the same way. Blind Builders have the advantage of</p><ul><li>decoupling the builder from its enclosing class, eliminating a circular dependency,</li><li>greatly reduces the size of the source code of (what is <i>no longer</i>) the enclosing class, and</li><li>allows the <code>ToBeBuilt</code> class to be extended <i>without having to extend its builder</i>.</li></ul><p></p><p></p><p></p><p>In this documentation, I&#39;ll refer to the class-being-built as the &#34;<code>ToBeBuilt</code>&#34; class.</p><p></p><p></p><h2>A class implemented with a Bloch Builder</h2><p>A Bloch Builder is a <code>public static class</code> contained inside the class that it builds. An example:</p><p></p><p></p><pre>public class UserConfig  {
   private final String sName    ;
   private final int    iAge     ;
   private final String sFavColor;
   public UserConfig(UserConfig.Cfg uc_c)  {      //CONSTRUCTOR
      //transfer
         try  {
            sName  = uc_c.sName;
         }  catch(NullPointerException rx)  {
            throw  new NullPointerException(&#34;uc_c&#34;);
         }
         iAge      = uc_c.iAge;
         sFavColor = uc_c.sFavColor;
      //VALIDATE ALL FIELDS HERE
   }
   public String toString()  {
      return  &#34;name=&#34; + sName + &#34;, age=&#34; + iAge + &#34;, sFavColor=&#34; + sFavColor;
   }
   //builder...START
   public static class Cfg  {
      private String sName    ;
      private int    iAge     ;
      private String sFavColor;
      public Cfg(String s_name)  {
         sName = s_name;
      }
      //self-returning setters...START
         public Cfg age(int i_age)  {
            iAge = i_age;
            return  this;
         }
         public Cfg favoriteColor(String s_color)  {
            sFavColor = s_color;
            return  this;
         }
      //self-returning setters...END
      public UserConfig build()  {
         return  (new UserConfig(this));
      }
   }
   //builder...END
}</pre><p></p><p></p><h3>Instantiating a class with a Bloch Builder</h3><p></p><p></p><pre>UserConfig uc = new UserConfig.Cfg(&#34;Kermit&#34;).age(50).favoriteColor(&#34;green&#34;).build();
</pre><p></p><p></p><h2>The same class, implemented as a Blind Builder</h2><p></p><p></p><p>There are three parts to a Blind Builder, each of which is in a separate source-code file:</p><ol><li>The <code>ToBeBuilt</code> class (in this example: <code>UserConfig</code>)</li><li>Its &#34;<code>Fieldable</code>&#34; interface</li><li>The builder</li></ol><p></p><p></p><h3>1. The to-be-built class</h3><p></p><p></p><p>The to-be-built class accepts its <code>Fieldable</code> interface as its only constructor parameter. The constructor sets all internal fields from it, <i>and validates</i> each. Most importantly, this <code>ToBeBuilt</code> class has no knowledge of its builder.</p><p></p><p></p><pre>public class UserConfig  {
   private final String sName    ;
   private final int    iAge     ;
   private final String sFavColor;
    public UserConfig(UserConfig_Fieldable uc_f)  {      //CONSTRUCTOR
      //transfer
         try  {
            sName  = uc_f.getName();
         }  catch(NullPointerException rx)  {
            throw  new NullPointerException(&#34;uc_f&#34;);
         }
         iAge      = uc_f.getAge();
         sFavColor = uc_f.getFavoriteColor();
      //VALIDATE ALL FIELDS HERE
   }
   public String toString()  {
      return  &#34;name=&#34; + sName + &#34;, age=&#34; + iAge + &#34;, sFavColor=&#34; + sFavColor;
   }
}</pre><p></p><p></p><p>As noted by one smart commenter (who inexplicably deleted their answer), if the <code>ToBeBuilt</code> class also implements its <code>Fieldable</code>, its one-and-only constructor can be used as both its primary <i>and</i> copy constructor (a disadvantage is that fields are always validated, even though it is known that the fields in the original <code>ToBeBuilt</code> are valid).</p><p></p><p></p><h3>2. The &#34;<code>Fieldable</code>&#34; interface</h3><p></p><p></p><p>The fieldable interface is the &#34;bridge&#34; between the <code>ToBeBuilt</code> class and its builder, defining all fields necessary to build the object. This interface is required by the <code>ToBeBuilt</code> classes constructor, and is implemented by the builder. Since this interface may be implemented by classes other than the builder, any class may easily instantiate the <code>ToBeBuilt</code> class, without being forced to use its builder. This also makes it easier to extend the <code>ToBeBuilt</code> class, when extending its builder is not desirable or necessary.</p><p></p><p></p><p>As described in a below section, I do not document the functions in this interface at all.</p><p></p><p></p><pre>public interface UserConfig_Fieldable  {
   String getName();
   int getAge();
   String getFavoriteColor();
}</pre><p></p><p></p><h3>3. The builder</h3><p></p><p></p><p>The builder implements the <code>Fieldable</code> class. It does no validation at all, and to emphasize this fact, all of its fields are public and mutable. While this public accessibility is not a requirement, I prefer and recommend it, because it re-enforces the fact that validation does not occur until the <code>ToBeBuilt</code>&#39;s constructor is called. This is important, because it is <i>possible</i> for another thread to manipulate the builder further, before it is passed to the <code>ToBeBuilt</code>&#39;s constructor. The only way to guarantee the fields are valid--assuming the builder cannot somehow &#34;lock&#34; its state--is for the <code>ToBeBuilt</code> class to do the final check.</p><p></p><p></p><p>Finally, as with the <code>Fieldable</code> interface, I do not document any of its getters.</p><p></p><p></p><pre>public class UserConfig_Cfg implements UserConfig_Fieldable  {
   public String sName    ;
   public int    iAge     ;
    public String sFavColor;
    public UserConfig_Cfg(String s_name)  {
       sName = s_name;
    }
    //self-returning setters...START
       public UserConfig_Cfg age(int i_age)  {
          iAge = i_age;
          return  this;
       }
       public UserConfig_Cfg favoriteColor(String s_color)  {
          sFavColor = s_color;
          return  this;
       }
    //self-returning setters...END
    //getters...START
       public String getName()  {
          return  sName;
       }
       public int getAge()  {
          return  iAge;
       }
       public String getFavoriteColor()  {
          return  sFavColor;
       }
    //getters...END
    public UserConfig build()  {
       return  (new UserConfig(this));
    }
}</pre><p></p><p></p><h3>Instantiating a class with a Blind Builder</h3><p></p><p></p><pre>UserConfig uc = new UserConfig_Cfg(&#34;Kermit&#34;).age(50).favoriteColor(&#34;green&#34;).build();
</pre><p></p><p></p><p>The only difference is &#34;<code>UserConfig_Cfg</code>&#34; instead of &#34;<code>UserConfig.Cfg</code>&#34;</p><p></p><p></p><h2>Notes</h2><p></p><p></p><p>Disadvantages:</p><ul><li>Blind Builders cannot access private members of its <code>ToBeBuilt</code> class,</li><li>They are more verbose, as getters are now required in both the builder and in the interface.</li><li>Everything for a single class is no longer in <i>just one place</i>.</li></ul><p></p><p></p><p></p><p>Compiling a Blind Builder is straight-forward:</p><ol><li><code>ToBeBuilt_Fieldable</code></li><li><code>ToBeBuilt</code></li><li><code>ToBeBuilt_Cfg</code></li></ol><p></p><p></p><p></p><h3>The <code>Fieldable</code> interface is entirely optional</h3><p></p><p></p><p>For a <code>ToBeBuilt</code> class with few required fields--such as this <code>UserConfig</code> example class, the constructor could simply be</p><p></p><p></p><pre>public UserConfig(String s_name, int i_age, String s_favColor)  {</pre><p></p><p></p><p>And called in the builder with</p><p></p><p></p><pre>public UserConfig build()  {
   return  (new UserConfig(getName(), getAge(), getFavoriteColor()));
}</pre><p></p><p>Or even by eliminating the getters (in the builder) altogether:</p><p></p><pre>   return  (new UserConfig(sName, iAge, sFavoriteColor));</pre><p></p><p></p><p>By passing fields directly, the <code>ToBeBuilt</code> class is just as &#34;blind&#34; (unaware of its builder) as it is with the <code>Fieldable</code> interface. However, for <code>ToBeBuilt</code> classes which and are intended to be &#34;extended and sub-extended many times&#34; (which is in the title of this post), any changes to <i>any</i> field necessitates changes in <i>every</i> sub-class, in <i>every</i> builder and <code>ToBeBuilt</code> constructor. As the number of fields and sub-classes increases, this becomes impractical to maintain.</p><p></p><p></p><p>(Indeed, with few necessary fields, using a builder at all may be overkill. For those interested, <em><a href="http://pastebin.com/embed_js.php?i=cXRuHw3m" rel="nofollow noreferrer">here is a sampling</a></em> of some of the larger Fieldable interfaces in my personal library.)</p><p></p><p></p><h3>Secondary classes in sub-package</h3><p></p><p></p><p>I choose to have all builder and the <code>Fieldable</code> classes, for all Blind Builders, in a sub-package of their <code>ToBeBuilt</code> class. The sub-package is always named &#34;<code>z</code>&#34;. This prevents these secondary classes from cluttering up the JavaDoc package list. For example</p><ul><li><code>library.class.my.UserConfig</code></li><li><code>library.class.my.z.UserConfig_Fieldable</code></li><li><code>library.class.my.z.UserConfig_Cfg</code></li></ul><p></p><p></p><p></p><h3>Validation example</h3><p></p><p></p><p>As mentioned above, all validation occurs in the <code>ToBeBuilt</code>&#39;s constructor. Here is the constructor again with example validation code:</p><p></p><p></p><pre>public UserConfig(UserConfig_Fieldable uc_f)  {
   //transfer
      try  {
         sName  = uc_f.getName();
      }  catch(NullPointerException rx)  {
         throw  new NullPointerException(&#34;uc_f&#34;);
      }
      iAge      = uc_f.getAge();
      sFavColor = uc_f.getFavoriteColor();
   //validate          (should really pre-compile the patterns...)
      try  {
         if(!Pattern.compile(&#34;\\w+&#34;).matcher(sName).matches())  {
            throw  new IllegalArgumentException(&#34;uc_f.getName() (\&#34;&#34; + sName + &#34;\&#34;) may not be empty, and must contain only letters digits and underscores.&#34;);
         }
      }  catch(NullPointerException rx)  {
         throw  new NullPointerException(&#34;uc_f.getName()&#34;);
      }
      if(iAge &lt; 0)  {
         throw  new IllegalArgumentException(&#34;uc_f.getAge() (&#34; + iAge + &#34;) is less than zero.&#34;);
      }
      try  {
         if(!Pattern.compile(&#34;(?:red|blue|green|hot pink)&#34;).matcher(sFavColor).matches())  {
            throw  new IllegalArgumentException(&#34;uc_f.getFavoriteColor() (\&#34;&#34; + uc_f.getFavoriteColor() + &#34;\&#34;) is not red, blue, green, or hot pink.&#34;);
         }
      }  catch(NullPointerException rx)  {
         throw  new NullPointerException(&#34;uc_f.getFavoriteColor()&#34;);
      }
}</pre><p></p><p></p><h2>Documenting Builders</h2><p></p><p></p><p>This section is applicable to both Bloch Builders and Blind Builders. It demonstrates how I document the classes in this design, making setters (in the builder) and their getters (in the <code>ToBeBuilt</code> class) directly cross-referenced to each other--with a single mouse-click, and without the user needing to know where those functions actually reside--and without the developer having to document anything redundantly.</p><p></p><p></p><h3>Getters: In the <code>ToBeBuilt</code> classes only</h3><p></p><p></p><p>Getters are documented only in the <code>ToBeBuilt</code> class. The equivalent getters both in the <code><em>_Fieldable</em></code><em> and <code></code></em><code>_Cfg</code> classes are ignored. I don&#39;t document them at all.</p><p></p><p></p><pre>/**
   &lt;P&gt;The user&#39;s age.&lt;/P&gt;
   @return  An int representing the user&#39;s age.
   @see  UserConfig_Cfg#age(int)
   @see  getName()
 **/
public int getAge()  {
   return  iAge;
}</pre><p></p><p></p><p>The first <code>@see</code> is a link to its setter, which is in the builder class.</p><p></p><p></p><h3>Setters: In the builder-class</h3><p></p><p></p><p>The setter is documented <i>as if it is in the <code>ToBeBuilt</code> class</i>, and also as if <i>it</i> does the validation (which really is done by the <code>ToBeBuilt</code>&#39;s constructor). The asterisk (&#34;<code>*</code>&#34;) is a visual clue indicating that the link&#39;s target is in another class.</p><p></p><p></p><pre>/**
   &lt;P&gt;Set the user&#39;s age.&lt;/P&gt;
   @param  i_age  May not be less than zero. Get with {@code UserConfig#getName() getName()}*.
   @see  #favoriteColor(String)
 **/
public UserConfig_Cfg age(int i_age)  {
   iAge = i_age;
   return  this;
}</pre><p></p><p></p><h3>Further information</h3><p></p><p></p><p></p><ul><li><code><a href="https://softwareengineering.stackexchange.com/questions/225207/why-should-a-builder-be-an-inner-class-instead-in-its-own-class-file"></a><a href="https://softwareengineering.stackexchange.com/questions/225207/why-should-a-builder-be-an-inner-class-instead-in-its-own-class-file">Why should a builder be an inner class instead of in its own class file?</a></code></li><li><code><a href="https://softwareengineering.stackexchange.com/questions/118039/benefit-of-using-static-inner-builder-class"></a><a href="https://softwareengineering.stackexchange.com/questions/118039/benefit-of-using-static-inner-builder-class">Benefit of using static inner builder class</a></code></li></ul><p></p><p></p><p></p><h2>Putting it all together: The full source of the Blind Builder example, with complete documentation</h2><p></p><p></p><h2><code>UserConfig.java</code></h2><p></p><p></p><pre>import  java.util.regex.Pattern;
/**
   &lt;P&gt;Information about a user -- &lt;I&gt;[builder: UserConfig_Cfg]&lt;/I&gt;&lt;/P&gt;
   &lt;P&gt;Validation of all fields occurs in this classes constructor. However, each validation requirement is document only in the builder&#39;s setter functions.&lt;/P&gt;
   &lt;P&gt;{@code java xbn.z.xmpl.lang.builder.finalv.UserConfig}&lt;/P&gt;
 **/
public class UserConfig  {
   public static final void main(String[] igno_red)  {
      UserConfig uc = new UserConfig_Cfg(&#34;Kermit&#34;).age(50).favoriteColor(&#34;green&#34;).build();
      System.out.println(uc);
   }
   private final String sName    ;
   private final int    iAge     ;
   private final String sFavColor;
   /**
      &lt;P&gt;Create a new instance. This sets and validates all fields.&lt;/P&gt;
      @param  uc_f  May not be {@code null}.
    **/
   public UserConfig(UserConfig_Fieldable uc_f)  {
      //transfer
         try  {
            sName  = uc_f.getName();
         }  catch(NullPointerException rx)  {
            throw  new NullPointerException(&#34;uc_f&#34;);
         }
         iAge      = uc_f.getAge();
         sFavColor = uc_f.getFavoriteColor();
      //validate
         try  {
            if(!Pattern.compile(&#34;\\w+&#34;).matcher(sName).matches())  {
               throw  new IllegalArgumentException(&#34;uc_f.getName() (\&#34;&#34; + sName + &#34;\&#34;) may not be empty, and must contain only letters digits and underscores.&#34;);
            }
         }  catch(NullPointerException rx)  {
            throw  new NullPointerException(&#34;uc_f.getName()&#34;);
         }
         if(iAge &lt; 0)  {
            throw  new IllegalArgumentException(&#34;uc_f.getAge() (&#34; + iAge + &#34;) is less than zero.&#34;);
         }
         try  {
            if(!Pattern.compile(&#34;(?:red|blue|green|hot pink)&#34;).matcher(sFavColor).matches())  {
               throw  new IllegalArgumentException(&#34;uc_f.getFavoriteColor() (\&#34;&#34; + uc_f.getFavoriteColor() + &#34;\&#34;) is not red, blue, green, or hot pink.&#34;);
            }
         }  catch(NullPointerException rx)  {
            throw  new NullPointerException(&#34;uc_f.getFavoriteColor()&#34;);
         }
   }
   //getters...START
      /**
         &lt;P&gt;The user&#39;s name.&lt;/P&gt;
         @return  A non-{@code null}, non-empty string.
         @see  UserConfig_Cfg#UserConfig_Cfg(String)
         @see  #getAge()
         @see  #getFavoriteColor()
       **/
      public String getName()  {
         return  sName;
      }
      /**
         &lt;P&gt;The user&#39;s age.&lt;/P&gt;
         @return  A number greater-than-or-equal-to zero.
         @see  UserConfig_Cfg#age(int)
         @see  #getName()
       **/
      public int getAge()  {
         return  iAge;
      }
      /**
         &lt;P&gt;The user&#39;s favorite color.&lt;/P&gt;
         @return  A non-{@code null}, non-empty string.
         @see  UserConfig_Cfg#age(int)
         @see  #getName()
       **/
      public String getFavoriteColor()  {
         return  sFavColor;
      }
   //getters...END
   public String toString()  {
      return  &#34;getName()=&#34; + getName() + &#34;, getAge()=&#34; + getAge() + &#34;, getFavoriteColor()=&#34; + getFavoriteColor();
   }
}</pre><p></p><p></p><h2><code>UserConfig_Fieldable.java</code></h2><p></p><p></p><pre>/**
   &lt;P&gt;Required by the {@link UserConfig} {@code UserConfig#UserConfig(UserConfig_Fieldable) constructor}.&lt;/P&gt;
 **/
public interface UserConfig_Fieldable  {
   String getName();
   int getAge();
   String getFavoriteColor();
}</pre><p></p><p></p><h2><code>UserConfig_Cfg.java</code></h2><p></p><p></p><pre>import  java.util.regex.Pattern;
/**
   &lt;P&gt;Builder for {@link UserConfig}.&lt;/P&gt;
   &lt;P&gt;Validation of all fields occurs in the &lt;CODE&gt;UserConfig&lt;/CODE&gt; constructor. However, each validation requirement is document only in this classes setter functions.&lt;/P&gt;
 **/
public class UserConfig_Cfg implements UserConfig_Fieldable  {
   public String sName    ;
   public int    iAge     ;
   public String sFavColor;
   /**
      &lt;P&gt;Create a new instance with the user&#39;s name.&lt;/P&gt;
      @param  s_name  May not be {@code null} or empty, and must contain only letters, digits, and underscores. Get with {@code UserConfig#getName() getName()}{@code ()}<em>.
    **/
   public UserConfig_Cfg(String s_name)  {
      sName = s_name;
   }
   //self-returning setters...START
      /**
         &lt;P&gt;Set the user&#39;s age.&lt;/P&gt;
         @param  i_age  May not be less than zero. Get with {@code UserConfig#getName() getName()}{@code ()}</em>.
         @see  #favoriteColor(String)
       **/
      public UserConfig_Cfg age(int i_age)  {
         iAge = i_age;
         return  this;
      }
      /**
         &lt;P&gt;Set the user&#39;s favorite color.&lt;/P&gt;
         @param  s_color  Must be {@code &#34;red&#34;}, {@code &#34;blue&#34;}, {@code green}, or {@code &#34;hot pink&#34;}. Get with {@code UserConfig#getName() getName()}{@code ()}*.
         @see  #age(int)
       **/
      public UserConfig_Cfg favoriteColor(String s_color)  {
         sFavColor = s_color;
         return  this;
      }
   //self-returning setters...END
   //getters...START
      public String getName()  {
         return  sName;
      }
      public int getAge()  {
         return  iAge;
      }
      public String getFavoriteColor()  {
         return  sFavColor;
      }
   //getters...END
   /**
      &lt;P&gt;Build the UserConfig, as configured.&lt;/P&gt;
      @return  &lt;CODE&gt;(new {@link UserConfig#UserConfig(UserConfig_Fieldable) UserConfig}(this))&lt;/CODE&gt;
    **/
   public UserConfig build()  {
      return  (new UserConfig(this));
   }
}</pre><p></p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-manager-container-class-vs-static-class-methods/'>C# &#8211; Manager/Container class vs static class methods</a></li><li class="list-group-item"><a href='../object-oriented-using-the-decorator-pattern-to-add-public-methods-to-an-object/'>Object-oriented &#8211; Using the Decorator pattern to add public methods to an object</a></li><li class="list-group-item"><a href='../java-want-this-class-to-extend-an-interface-and-what-is-the-right-design-pattern-for-this/'>Java &#8211;  want this class to extend an interface, and what is the right design pattern for this</a></li><li class="list-group-item"><a href='../java-why-does-java-have-void-methods/'>Java &#8211; Why does Java have `void` methods</a></li><li class="list-group-item"><a href='../java-using-generics-on-interfaces-when-implementation-is-not-generic/'>Java &#8211; Using generics on interfaces when implementation is not generic</a></li><li class="list-group-item"><a href='../java-oop-design-considering-no-modifications-to-existing-design/'>Java &#8211; OOP Design considering no modifications to existing design</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>