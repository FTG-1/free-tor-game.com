<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++ &#8211; Implementation of Matrix: std::vector vs std::unique_ptr &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1083274 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1083274" class="post-1083274 software type-software status-publish hentry category-software tag-c tag-matrix"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++ &#8211; Implementation of Matrix<T>: std::vector<T> vs std::unique_ptr<T[]></h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">matrix</span></p><div class="entry-content"><p>As part of a hobby project, I needed a rectangular Matrix object to maintain state of a grid. At first, the implementation seemed trivial and unworthy of further discussion: (I haven&#39;t included all the code, only the relevant code)</p><pre><code>template&lt;typename T&gt;
class Matrix {
    uint64_t rows, columns;
    std::vector&lt;T&gt; _data;

    uint64_t get_flat_index(uint64_t row, uint64_t column) const {
        return row * columns + column;
    }

public:
    Matrix(uint64_t rows, uint64_t columns) :
    rows(rows), columns(columns), _data(rows * columns, {}) {}

    //Auto-generated by compiler
    //Matrix(Matrix const&amp;) = default;
    //Matrix(Matrix &amp;&amp;) = default;
    //Matrix &amp; operator=(Matrix const&amp;) = default;
    //Matrix &amp; operator=(Matrix &amp;&amp;) = default;
    //~Matrix() = default;

    T &amp; operator()(uint64_t row, uint64_t column) {
        return _data[get_flat_index(row, column)];
    }

    T const&amp; operator()(uint64_t row, uint64_t column) const {
        return _data[get_flat_index(row, column)];
    }

    bool is_valid(uint64_t row, uint64_t column) const {
        return row &lt; rows &amp;&amp; column &lt; columns;
    }

    T &amp; at(uint64_t row, uint64_t column) {
        if(!is_valid(row, column)) throw std::runtime_error(&#34;row/column out of bounds!&#34;);
        return operator()(row, column);
    }

    T const&amp; at(uint64_t row, uint64_t column) const {
        if(!is_valid(row, column)) throw std::runtime_error(&#34;row/column out of bounds!&#34;);
        return operator()(row, column);
    }

    uint64_t get_rows() const {return rows;}
    uint64_t get_columns() const {return columns;}

    void resize(uint64_t new_rows, uint64_t new_columns) {
        if (new_rows == rows &amp;&amp; new_columns == columns) return;

        if (new_columns == columns) {
            _data.resize(new_rows * new_columns, {});
        }
        else {
            std::vector&lt;T&gt; new_data(new_rows * new_columns, {});
            for (uint64_t row = 0; row &lt; std::min(rows, new_rows); row++) {
                auto beginning_of_row = _data.begin() + (row * columns);
                auto ending_of_row = beginning_of_row + std::min(columns, new_columns);
                auto beginning_of_new_row = new_data.begin() + (row * new_columns);
                std::copy(beginning_of_row, ending_of_row, beginning_of_new_row);
            }
            _data = std::move(new_data);
        }

        columns = new_columns;
        rows = new_rows;
    }

    //Other code, not related to this post
};
</code></pre><p>So it all seems pretty great right? I can write stuff like <code>Matrix&lt;int&gt; m(50,50);</code>, <code>m(5, 10) = 17;</code>, <code>try {m.at(52, 47) = 99;} catch (std::runtime_error const&amp; e) {std::cerr &lt;&lt; &#34;Whoops!&#34; &lt;&lt; std::endl;}</code>, and it all just works, right?</p><p>Well, it turns out there&#39;s at least one situation where the code misbehaves in a major way:</p><pre><code>Matrix&lt;bool&gt; is_tested(60, 60); 
is_tested(30, 40) = true; //Does not compile! Whoops.
</code></pre><p>Yeah. Turns out that because <a href="http://en.cppreference.com/w/cpp/container/vector_bool" rel="nofollow noreferrer"><code>std::vector&lt;bool&gt;</code> has been specialized</a>, it messes with the integrity of my code.</p><p>My initial solution was to write a specialization for <code>Matrix&lt;bool&gt;</code>.</p><pre><code>template&lt;&gt;
class Matrix&lt;bool&gt; {
    uint64_t rows, columns;
    std::unique_ptr&lt;bool[]&gt; _data;

    //Duplicated: 
    uint64_t get_flat_index(uint64_t rows, uint64_t columns) {/*...*/}
public:
    Matrix(uint64_t rows, uint64_t columns) :
    rows(rows), columns(columns), _data(std::make_unique&lt;bool[]&gt;(rows * columns)) {}

    //I don&#39;t get this for free anymore!
    Matrix(Matrix const&amp; m) : Matrix(m.rows, m.columns) {
        std::copy(m._data.get(), m._data.get() + rows * columns, _data.get());
    }

    //I have to include this manually now.
    Matrix(Matrix &amp;&amp;) = default;

    //More duplicated code...
    bool &amp; operator()(uint64_t row, uint64_t column) {/*...*/}
    bool const&amp; operator()(uint64_t row, uint64_t column) const {/*...*/}
    bool is_valid(uint64_t row, uint64_t column) const {/*...*/}
    bool &amp; at(uint64_t row, uint64_t column) {/*...*/}
    bool const&amp; at(uint64_t row, uint64_t column) const {/*...*/}
    uint64_t get_rows() const {/*...*/}
    uint64_t get_columns() const {/*...*/}

    void resize(uint64_t new_rows, uint64_t new_columns) {
        if (new_rows == rows &amp;&amp; new_columns == columns) return;

        std::unique_ptr&lt;bool[]&gt; new_data{ std::make_unique&lt;bool[]&gt;(new_rows * new_columns) };

        if (new_columns == columns) {
            std::copy(
                begin(),
                begin() + ((new_rows &lt; rows) ? new_rows * new_columns : rows * new_columns),
                new_data.get()
            );
        }
        else {
            for (uint64_t row = 0; row &lt; std::min(rows, new_rows); row++) {
                auto beginning_of_row = _data.get() + (row * columns);
                auto ending_of_row = beginning_of_row + std::min(columns, new_columns);
                auto beginning_of_new_row = new_data.get() + (row * new_columns);
                std::copy(beginning_of_row, ending_of_row, beginning_of_new_row);
            }
        }

        _data = std::move(new_data);
        columns = new_columns;
        rows = new_rows;
    }

    //All the other code needs to be duplicated as well!
};
</code></pre><p>This is, of course, frustrating, not least of which since every time I spot a mistake in one version of the code, I have to fix it in the other, and same goes if I redesign something.</p><p>So my next thought was to ditch <code>std::vector&lt;T&gt;</code> entirely, and just specialize around <code>std::unique_ptr&lt;T[]&gt;</code>. This solves the code duplication problem, but it means I can&#39;t take advantage of any optimization potential that <code>std::vector&lt;T&gt;</code> offers over <code>std::unique_ptr&lt;T[]&gt;</code>, like smart use of allocators and other benefits, all to ensure that <code>Matrix&lt;bool&gt;</code> works correctly. I tried a version that partitions out the divergent code into a superclass called <code>_matrix_impl&lt;T&gt;</code> that specializes around <code>bool</code> itself, leaving <code>Matrix&lt;T&gt;</code> to not have to specialize anything itself, but there was still a significant amount of code duplication on things like the variable declarations and the <code>get_flat_index</code> code (not to mention a lot of the code not listed here being duplicated) and it created its own nightmare for code maintainability, vis-a-vis inheritance of template superclasses.</p><p>So ultimately, my question is: what is the best solution for this situation? Since my code doesn&#39;t have things like <code>insert</code>, <code>emplace</code>, or other similar constructs, does it make sense to just use <code>std::unique_ptr&lt;T[]&gt;</code> for everything, since many of the benefits I&#39;d otherwise have access to are moot anyways? If I use <code>std::vector&lt;T&gt;</code>instead, is there a way to gracefully handle <code>Matrix&lt;bool&gt;</code> without dealing with the headache that is <code>std::vector&lt;bool&gt;</code>? Is there a superior third/fourth option I haven&#39;t even considered?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>Since my code doesn&#39;t have things like <code>insert</code>, <code>emplace</code>, or other similar constructs, does it make sense to just use <code>std::unique_ptr&lt;T[]&gt;</code> for everything, since many of the benefits I&#39;d otherwise have access to are moot anyways?</p></blockquote><p>It&#39;s not a bad idea from a performance standpoint; given that you matrix is fixed-size, you can get away with just one pointer instead of three, so your matrix objects are going to be slightly lighter weight than when using <code>std::vector</code> as a data backend; also, given that that pointer has now way to be modified outside the constructor, the compiler may be able to be extra smart and avoid re-reading it from your object when performing manipulations intermixed with extern function calls (it&#39;s a common cause of slight slowdown with <code>std::vector</code>).</p><p>OTOH, you are not getting the copy/assignment stuff for free, if this is important it&#39;s for you to judge.</p><blockquote><p>If I use <code>std::vector&lt;T&gt;</code> instead, is there a way to gracefully handle <code>Matrix&lt;bool&gt;</code> without dealing with the headache that is <code>std::vector&lt;bool&gt;</code>?</p></blockquote><p>A possibility that I actually used is to use the <code>std::vector&lt;T&gt;::reference</code> <code>typedef</code>s for your accessors, thus forwarding whatever proxy object <code>std::vector&lt;bool&gt;</code> likes to use straight to your user. So, something like:</p><pre><code>typedef std::vector&lt;T&gt;::reference reference;
typedef std::vector&lt;T&gt;::const_reference const_reference;

reference operator()(uint64_t row, uint64_t column) {
    return _data[get_flat_index(row, column)];
}

const_reference operator()(uint64_t row, uint64_t column) const {
    return _data[get_flat_index(row, column)];
}

// ... same with at &amp; co. ...
</code></pre><p>Incidentally, if you are to implement your <code>Matrix</code> class using <code>std::vector</code> as a backend, you can avoid storing the number of rows - the <code>std::vector</code> already stores the full size, so the height is just one division away (but as usual, check if the size reduction of the <code>Matrix</code> object is worth the extra cost of the division by profiling the code against common scenarios).</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../how-did-strassen-come-up-with-his-matrix-multiplication-method/'>How did Strassen come up with his matrix multiplication method</a></li><li class="list-group-item"><a href='../c-allow-iteration-of-an-internal-vector-without-leaking-the-implementation/'>C++ &#8211; Allow iteration of an internal vector without leaking the implementation</a></li><li class="list-group-item"><a href='../c-use-of-raw-pointer-of-stdvector/'>C++ &#8211; Use of raw pointer of std::vector</a></li><li class="list-group-item"><a href='../c-stdvector-non-array-implementation/'>C++ &#8211; std::vector Non-Array Implementation</a></li><li class="list-group-item"><a href='../c-ny-merit-for-using-beginning-iterator-instead-of-reference-to-a-stdvector/'>C++ &#8211; ny merit for using beginning iterator instead of reference to a std::vector</a></li><li class="list-group-item"><a href='../which-algorithm-is-performant-for-matrix-multiplication-of-4x4-matrices-of-affine-transformations/'>Which algorithm is performant for matrix multiplication of 4&#215;4 matrices of affine transformations</a></li><li class="list-group-item"><a href='../c-how-did-stdvector-come-about/'>C++ &#8211; How did std::vector<bool> come about</a></li><li class="list-group-item"><a href='../c-how-to-pass-a-mock-as-stdunique_ptr-to-class-under-test/'>C++ &#8211; How to pass a mock as std::unique_ptr to Class under test</a></li><li class="list-group-item"><a href='../c-should-i-use-a-unique_ptr-with-an-array-type-or-a-vector/'>C++ &#8211; Should I use a unique_ptr with an array type, or a vector</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>