<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="https://free-tor-game.com/wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Non-OOP languages advantages and good uses &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js?ver=11.2.0' id='highlight-js'></script>     <script>( function( w, d, s, l, i ) {
				w[l] = w[l] || [];
				w[l].push( {'gtm.start': new Date().getTime(), event: 'gtm.js'} );
				var f = d.getElementsByTagName( s )[0],
					j = d.createElement( s ), dl = l != 'dataLayer' ? '&l=' + l : '';
				j.async = true;
				j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
				f.parentNode.insertBefore( j, f );
			} )( window, document, 'script', 'dataLayer', ' ' );</script>      <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1070134 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="https://free-tor-game.com/3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="https://free-tor-game.com/contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1070134" class="post-1070134 software type-software status-publish hentry category-software tag-functional-programming tag-object-oriented tag-paradigms tag-procedural"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Non-OOP languages advantages and good uses</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">functional programming</span><span class="mr-2 badge badge-info">object-oriented</span><span class="mr-2 badge badge-warning">paradigms</span><span class="mr-2 badge badge-primary">procedural</span></p><div class="entry-content"><p>I&#39;m a C# developer, but I also know Java, JavaScript, XSLT, a little of C and Perl, and some other that I may have forgotten. Still, the paradigm I&#39;m most familiar with is OOP.</p><p>I have always thought that OOP was the natural evolution of procedural programming, but I wonder if OOP is that perfect. After reading some articles on the web and some questions here, I found that many people don&#39;t agree with this and some say that OOP is a bad option.</p><p>While developing, I really appreciate using lambdas, LINQ, anonymous types, and really enjoy JavaScript with its prototyping and dynamic nature.</p><p>But still, I can&#39;t think of any scenario where OOP is not an option, or where other paradigms fit better. The only thing I can think of is that sometimes programming with OOP is really boring and slow, like having to declare a class, import some other classes, declaring a method, specifying its parameters, return type and name just to show &#34;Hello, World!&#34; on the console screen. But still, for real-life programs, it seems like something that compensates its cost.</p><p>In what scenarios do other paradigms fit better than OOP? What are their advantages over OOP and where does OOP make things worse instead of helping? Especially, what are the advantages and in what scenarios do procedural and functional programming excel?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>[...] were does OOP makes things worse instead of helping? [...] And what about procedural programming? What are its advantages over other paradigms?</p></blockquote><p>I&#39;ve come to favor writing more and more procedural or featherweight object-oriented code in C over the years, kind of making a full circle back to where I started (working backwards in the eyes of many of my peers, and maybe I&#39;m becoming a dinosaur). I&#39;ll try to cover why and the benefits I see to doing that. And the benefits aren&#39;t set in stone. They&#39;re related to human tendencies I just observed in the past.</p><p>Again these are just tendencies I personally observed and there&#39;s no rule that says that OOP has to be this way, but my acquired distaste for OOP in certain areas (even though I still use it a lot for higher-level code) came from the tendency of OOP enthusiasts to increase the amount of coupling and to redirect dependencies from simpler data types (possibly primitive types like <code>int</code>) to more and more complex user-defined types.</p><p>Now as an aside, to help understand my subjectivity, it&#39;s worth noting that my specialty in the past related to image and mesh processing. I wrote a lot of code related to looping over pixels, vertices, edges, triangles, and polygons along with data structures to process and represent them (with the mesh-related data structures and algorithms typically being the most complex). These are also performance-critical areas as well where my input sizes often spanned in the millions of pixels, millions of vertices, millions of polygons. The users do notice performance differences here very easily with their production models and images/textures being so high resolution, though performance had nothing to do with my full circle back towards C (I only mention it to help understand the lower-level domain of the code I typically wrote, often divorced from high-level user-end concepts and user interfaces and so forth).</p><p><strong>My Lovely Procedural Image Library</strong></p><p>So I&#39;ll go over an incident that happened to me in the past that might help to appreciate my viewpoint, though keep in mind it&#39;s not an isolated one. It&#39;s not like this one incident made me decide to write more procedural code in C again. But I was working with a team of object-oriented enthusiasts long ago (I also counted myself among them, at least &#34;sorta&#34;) and I had a procedural image library I wrote in C which was completely decoupled from the outside world. Most of its functions resembled this form processing 32-bit images in RGBA pixel formats:</p><pre class="lang-c prettyprint-override"><code>void image_filter(unsigned char pixels[], int w, int h, int stride);
</code></pre><p>And of course I have my author&#39;s bias, but if you ask me that&#39;s perfectly fine and lovely C code: one of the better and longer-lasting things I wrote, well-tested, and something I had been using for years. There&#39;s no reason for it to ever be changed except to perhaps provide support for a wider range of pixel formats or improve its performance against newer hardware (using parallel loops and SIMD, which I would have welcomed if anyone wanted to apply such optimizations and test them thoroughly).</p><p>It was also <em>completely</em> decoupled from the outside world (unless you count the C standard library which was uber stable and something we would never personally have to maintain). The dependencies looked like this:</p><p><a href="https://i.stack.imgur.com/TmGZd.png" rel="noreferrer"><img src="https://i.stack.imgur.com/TmGZd.png" alt="enter image description here"/></a></p><p>With incoming (afferent) dependencies but no outgoing (efferent) ones, and that made it build in a blink of an eye, made it very easy to deploy in any needed project (and I had been using it in many personal ones), and made it very stable. It had no reason to change as a result of something else changing, since it depended on nothing else.</p><p>But working with this team of OOP enthusiasts, and this was in the context of trying to move away from a legacy C codebase, we had the peer code reviews and they didn&#39;t like it. They thought it was too primitive and C-like. Someone also pointed out that it was duplicating some math functions in our math repository, like lerps and clamps and min/max functions operating on bytes. So one of the things they got me to do was to change the code to use our central math functions, and that wasn&#39;t related to OOP so much as DRY, but I hated it. So now I had to do this:</p><p><a href="https://i.stack.imgur.com/HIOKT.png" rel="noreferrer"><img src="https://i.stack.imgur.com/HIOKT.png" alt="enter image description here"/></a></p><p>And in my opinion that made my image library so much uglier because our math &#34;repository&#34; (I refuse to call it &#34;library&#34;) was not designed by people dedicating their time trying to figure out how to create a nice, minimalist math library with most of its responsibilities anticipated upfront. It was an eclectic mess of functions and classes programmers just added to whenever they needed something with no rhyme and reason to it and it was constantly changing so now my image library takes longer to build and has to be rebuilt all the time now depending on this unstable math repository.</p><p>But it didn&#39;t stop there. We ended up introducing an abstract <code>Image</code> interface, so the next iteration was to make the functions operate on these image interfaces instead of raw pixels:</p><pre><code>void image_filter(Image&amp; image);
</code></pre><p>At which point the dependencies were like this:</p><p><a href="https://i.stack.imgur.com/xmt1Q.png" rel="noreferrer"><img src="https://i.stack.imgur.com/xmt1Q.png" alt="enter image description here"/></a></p><p>And that image interface was also unstable and prone to change in ways I thought were really dumb, like people adding virtual methods to gaussian blur an image. Such methods need not belong in the interface when we could be defining and implementing them outside the class without making everything we could ever want to do with images a member function of an image interface*.</p><blockquote><ul><li>This leads to another point. I don&#39;t believe that an object should try to provide every function you need as a direct method of that class if such functions could be implemented <em>outside</em> the class to improve its encapsulation, loosen up the coupling, and keep its interface design more stable. But I tended to be in the minority here, and most people I&#39;ve worked with believe it is far more desirable to add everything you need as a method to the class so that you can get auto-completion/intellisense and have everything you would ever want right there inside the class.</li></ul></blockquote><p>Later on it got to the point where my library was &#34;refactored&#34; (more like &#34;demolished&#34; in my view) in its procedural form while the functions it provided became members of a concrete class implementing the abstract image interface above.</p><p>And what did that gain us? Maybe some syntactical sugar, but in exchange what started out as my original code went from being dependent on nothing to being dependent on multiple, and in my eyes, poorly-designed interfaces and &#34;repositories&#34; of functions which never achieved a point of stability, always receiving changes and updates and additions while the same code had to be rebuilt over and over. And with all the moving parts and ugly interfaces, I missed the way the code originally was in its simple C form, like so:</p><pre><code>void image_filter(unsigned char pixels[], int w, int h, int stride);
</code></pre><p>... with no dependencies to the outside world. And it was upon realizing this more and more that I started working my way back towards C, valuing its tendency to produce code that is decoupled and isolated from the outside world, invulnerable to its changes, and generally quite stable as long as there aren&#39;t a team of OO enthusiasts trying to OOP-ify it.</p><p>So that&#39;s why I like plain old procedural programming in C when appropriate. I tend to use it with a &#34;library-building&#34; mindset, and I like the fast build times, the decoupled nature of the code, the dependencies on simpler and more stable data types instead of complex and unstable user-defined types, and maybe even just the aesthetics of it all. I like code that stays stable and doesn&#39;t have to change in a technological world of moving parts, even if it&#39;s code as low-level and simple as an image library. I like having that little slice of stability against an unstable world, and I tend to find heavily object-oriented architectures and frameworks to often be a lot more unstable due to the increased amount of coupling against delicate design ideas prone to change over the course of time.</p><p>So it&#39;s admittedly a totally subjective answer, and one filled with a lot of bias and shaped by personal experiences, but I find procedural programming appealing in this way.</p><p><strong>Questions</strong></p><blockquote><p>In what scenarios does other paradigms fits better than OOP? What are its advantages over OOP and were does OOP makes things worse instead of helping?</p></blockquote><p>It&#39;s hard to put my finger on it but typically I find procedural programming well-suited when the focus is more on just &#34;transforming data&#34;. The above image library example as it originally started just operated on the idea of an array of pixels as &#34;data&#34; to transform. And I don&#39;t think there&#39;s so much benefit to a pixel or a collection of them to be modeled as anything more complex than &#34;data&#34;, especially in the context of a function which only needs to loop through pixels and transform them.</p><p>And if people attempted to abstract the notion of a pixel or a collection of pixels as anything more than data, then the abstraction risks being awkward, unstable, and being rendered obsolete over time even though the underlying data was the same all along and never faced the tendency towards obsolescence. Besides that, in this case if we tried to model an <code>Image</code> interface to abstract the idea of a collection of pixels, the objects implementing that interface don&#39;t necessarily benefit from encapsulation and information hiding of their pixels that much, because their ability to interop and work with other image processing code requires them to expose their raw pixel data. Such objects cannot effectively hide that data and maintain invariants over it in light of functionality that seeks to transform pixels unless it wants to try to provide for every single image-related operation known to mankind or require a dynamic dispatch just to <code>get_pixel</code> here and <code>set_pixel</code> there while sacrificing their ability to work directly against existing image processing code.</p><p>So in this case the scenario is just operate straight on the pixel &#34;data&#34; with procedural code or operate on pixel/image &#34;objects&#34; with functionality but still ending up being objects that practically have to leak their data to the outside world, with the objects more likely being unstable (prone to require changes), bulky, and harder to design properly. Sometimes the most effective and stable model for a concept is to leave it as just &#34;raw data&#34; instead of user-defined objects and interfaces to interact with in far more complex ways.</p><p>Dependencies should flow towards stability (as in, things that are unlikely to need future changes -- not the same definition that Martin uses but just code that has the lowest probability of requiring changes), and sometimes raw data is more stable and no more problematic than abstract interfaces of functionality. In such cases, I find procedural programming focused on transforming data to often yield code that is easier to maintain and generally requires much less maintenance in the first place.</p><p><strong>Entity-Component Systems</strong></p><p>It is perhaps for a similar reason that I&#39;ve come to like C so much again that I&#39;ve also come to love entity-component systems. Their dependencies flow uniformly towards &#34;raw data&#34; rather than abstractions, and in my cases I&#39;ve often found data to be easier to stabilize than abstractions on top of requiring fewer dependencies, less object-&gt;object interactions, etc.</p><p>It also suits my brain better? I mean, when I look at a large-scale codebase, it&#39;s not the complexity of any individual function that overwhelms me. It&#39;s the control flow and the number of interactions from one function to the next, abstract or not. You could show me a codebase with a thousand very simple objects and straightforward abstractions, all individually easy to understand, and I&#39;d still be overwhelmed by what&#39;s going on <em>between</em> the objects and functions. The sheer number of interactions between everything and the complex graph of dependencies that results would overwhelm the mind.</p><p>And procedural code of the sort I&#39;m describing that depends more on just &#34;raw data&#34; minimizes those interactions, keeps the call stack shallower, makes it so you can graph your codebase dependencies and not be overwhelmed by the result. It seems a lot of people focus on clean code at the intra-function or intra-object level, but the ultimate factor that leads to my ability to maintain and comprehend a system is generally more about the inter-function and inter-object level. I find it far more beneficial to minimize the interactions and complex control flows between code than to make any given function or object easier to comprehend, and favoring a more procedural mindset revolving around just loops that transform raw data tends to have that effect.</p><p><a href="https://i.stack.imgur.com/YVY3r.png" rel="noreferrer"><img src="https://i.stack.imgur.com/YVY3r.png" alt="enter image description here"/></a></p><p>I also don&#39;t believe ECS to be object-oriented at all but far more procedural, since what in an ECS benefits conceptually from being an object? Systems don&#39;t benefit since they&#39;re generally decoupled and don&#39;t talk to each other. Components don&#39;t benefit since they model raw data. Entities don&#39;t since they just contain components. Even if we use OOP languages and model, say, systems as objects just for some minor conveniences, the entity-component systems as used in a lot of game engines ultimately model a very procedural mindset, so I would use such game engines that benefit from entity-component systems as an example of where procedural programming is more suitable and flexible than OOP.</p><p><strong>Functional Programming</strong></p><blockquote><p>[...] and functional programming?</p></blockquote><p>This I&#39;m ill-suited to answer since I had my little love affair with LISP long ago in the past but never wrote anything of scale in it. However, the way it encourages immutability and discourages side effects is just something that seems so wonderful, so beautiful, so much easier to maintain if I can just get my head around such heavy recursive logic.</p><p>My previous adventures with LISP were always one where I had to take maybe 10 times longer to write the same thing because of how much thought I had to put into expressing it recursively and without any side effects (note that I was far from good or practiced at this) along with functions that input functions that return functions, but then came up with something that didn&#39;t flake out where it was easy to reason about the correctness of the code. It&#39;s been ages but I remember even trying to make it fall apart exploring possible edge cases and couldn&#39;t, and it was also easy to change it without worrying about cascading code breakages.</p><p>I&#39;ve still found that lesson valuable even when writing C code where I now try to write as many functions as I can to avoid side effects. I even have my own little library of immutable C data structures that I use here and there to help cheapen the costs of writing functions to be free of side effects. I do still mutate data inside such functions and my immutable structures revolve around mutable &#34;builders&#34; or &#34;transients&#34; which makes it easier for my brain, but the data is local to the function.</p><p>So I actually think functional programming is theoretically ideal in many cases. So many more functions tend to cause side effects in production than required and there are a lot more algorithms we might be able to apply in more situations if we had expressive languages built around lambdas and closures and predicates and things of that sort. The only problem is that my brain has a hard time just writing functional code in the first place even if the result is much easier to maintain, so I take many lessons from functional languages and pragmatically try to apply them in C, C++, and Lua (the three languages I use most nowadays), with the biggest one being to favor writing as many functions as possible to be free of side effects (we don&#39;t necessarily need to make every data type immutable to achieve that, however, since we can just copy them by value into a function and return a new result).</p><p><strong>Summary</strong></p><p>So anyway, among my mess of thoughts I got requested to do a summary. I&#39;ll try to come up with one.</p><p>I find procedural programming useful because:</p><ol><li>It tends to arguably be the most straightforward among the three.</li><li>It discourages complex user-defined types, which I consider both a good and bad thing (good when appropriate, bad when not). That tends to encourage minimal coupling and code that operates on the lowest common denominator of data.</li><li>It makes it easier to come up with code that doesn&#39;t feel outdated and awkward 2 years later when it is used in areas where it tends to excel, like just transforming raw data in a function, perhaps if only because it&#39;s simpler and more limited in nature. You can&#39;t go wrong with things you can&#39;t do.</li><li>Sometimes the most stable way to design something is to just leave it as data. Among the countless image libraries ever built by mankind so far, there have only been a handful of pixel formats. If more code was written procedurally against raw pixel data rather than abstract pixel or image interfaces, we would probably end up with a world with much less code that needs to be written, and much less code than needs to be maintained and rewritten.</li></ol><p>Functional programming I find useful, although I have the most limited experience here, because:</p><ol><li>I find the most difficult things to reason about in a complex codebase are the side effects that go on between code interactions and complex, graph-like control flows. Complex side effects make it so you can no longer reason about code correctness just in terms of &#34;what&#34; it does. It also makes you have to worry about &#34;when&#34; and &#34;where&#34; everything happens which raises the difficulty to reason about correctness exponentially. Functional programming, at least one that encourages pure functions, minimizes those side effects. When you bring the places causing side effects to an absolute minimum, then even the most complex recursive control flows become much easier to reason about in terms of correctness. A series of functions that cause no side effects can potentially be called in any order at any given time by any given thread.</li><li>There&#39;s a lot of rich expressiveness to algorithms we can apply in a functional way, like using a less than comparator to sort a range of elements while the comparator itself might be a function calling a lambda function. Functional programming allows you to get very fancy and recursive and extremely flexible with your control flows which could normally be a nightmare to debug if there were all kinds of side effects along the way, but it avoids that problem by avoiding those side effects in the first place.</li></ol><p>I find OOP useful because:</p><ol><li>It <em>does</em> allow creating complex and rich user-defined types. Sometimes raw data is too raw, too primitive, too exposed, to effectively express what we want to do and effectively maintain invariants.</li><li>Some things do map beautifully to the concept of an object and/or an abstract interface.</li><li>Sometimes an abstract interface is more stable than a data representation. An example is that of a forward iterator or enumerable. Countless data structures have been made representing data in a different way, and many of them are worthwhile and excel in their different areas. However, the concept of a forward iterator to iterate through whatever elements they contain, however they represent them, is a far more stable concept. Code written against a forward iterator can iterate through any data structure that provides one. While such concepts could potentially be expressed in a functional way or through coroutines or other means, iterator objects might be the most straightforward way to design it. In such a case, a counting function written against an abstract forward iterator interface implemented by forward iterator objects need not be rewritten for every single data structure ever made, provided they all provide conforming iterator objects.</li></ol><p>Continuing from #3, however, it is actually difficult to think of many abstract interfaces, widely-applicable, that have lasted the test of time beyond the standard libraries (they also tend to use other concepts like generics and procedural functions and some lightweight functional programming), and that lack of stability and wide applicability is one of the most difficult things I find about OOP.</p><p>I can more easily come up with many more cases where data representations are more stable than the abstractions meant to hide them away. Consider the data representing a rectangle in raw form versus a concrete rectangle object implementing, say, an abstract shape interface. The former comes in very few varieties, with the only noteworthy differences being perhaps whether they use integers or floating-point. The latter comes in endless, all coming and going each year and changing like a fashion trend. Standardizing functionality is often much more difficult than standardizing data representations, and for a lot of object-oriented code to be stable and require the minimum maintenance efforts, it needs to standardize functionality (interface designs) at least within a given team. And especially in loosely-coordinated teams of people with a mixture of skillsets and design sensibilities, this can be damned near impossible to do for all but a handful of things.</p><p>For OO enthusiasts that seek to maximize code reuse, a question worth thinking about is whether code becomes more reusable and widely applicable over the long term using, say, an abstract <code>Image</code> interface your team came up with or from a third party library or the above procedural form I originally had which just operates directly on pixel data. Sometimes the most reusable solutions that will last you for years will just operate straight on data if the data representation is more stable than the abstractions meant to hide them away. In such cases, you may find much more widely-applicable, reusable, stable code by leaving it operating directly on data rather than interacting with such data indirectly through an abstract interface. In some cases the abstract interface may actually be more stable, but it&#39;s also worth considering the alternative approach of just straightforward procedural functions operating directly over data, in choosing how you go about designing code.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='https://free-tor-game.com/software/object-oriented-paradigms-fit-for-ui-programming/'>Object-oriented &#8211; Paradigms fit for UI programming</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/object-oriented-what-are-the-advantages-of-prototype-based-oop-over-class-based-oop/'>Object-oriented &#8211; What are the advantages of prototype-based OOP over class-based OOP</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/whats-the-difference-between-imperative-procedural-and-structured-programming/'>What&#8217;s The Difference Between Imperative, Procedural and Structured Programming</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/javascript-is-javascript-a-functional-programming-language/'>Javascript &#8211; Is Javascript a Functional Programming Language</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/introducing-functional-programming-constructs-in-non-functional-programming-languages/'>Introducing functional programming constructs in non-functional programming languages</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/uses-of-persistent-data-structures-in-non-functional-languages/'>Uses of persistent data structures in non-functional languages</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/object-oriented-do-non-oop-paradigms-support-concepts-such-as-encapsulation/'>Object-oriented &#8211; Do non-OOP paradigms support concepts such as encapsulation</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='http://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="https://free-tor-game.com/wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>