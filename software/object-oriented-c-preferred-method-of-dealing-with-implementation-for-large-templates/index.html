<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; C++ Preferred method of dealing with implementation for large templates &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1072921 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1072921" class="post-1072921 software type-software status-publish hentry category-software tag-c tag-coding-style tag-object-oriented tag-templates"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; C++ Preferred method of dealing with implementation for large templates</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">coding-style</span><span class="mr-2 badge badge-warning">object-oriented</span><span class="mr-2 badge badge-primary">templates</span></p><div class="entry-content"><p>Typically when declaring a C++ class, it is best practice to put only the declaration in the header file and put the implementation in a source file. However, it seems that this design model does not work for template classes.</p><p>When looking online there seems to be 2 opinions on the best way to manage template classes:</p><h3>1. Entire declaration and implementation in header.</h3><p>This is fairly straightforward but leads to what are, in my opinion, difficult to maintain and edit code files when the template becomes large.</p><h3>2. Write the implementation in a template include file (.tpp) included at end.</h3><p>This seems like a better solution to me but doesn&#39;t seem to be widely applied. Is there a reason that this approach is inferior?</p><p>I know that many times the style of code is dictated by personal preference or legacy style. I am starting a new project (porting an old C project to C++) and I am relatively new to OO design and would like to follow best practices from the start.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>When writing a templated C++ class, you usually have three options:</p><p><strong>(1) Put declaration and definition in the header.</strong></p><pre><code>// foo.h
#pragma once

template &lt;typename T&gt;
struct Foo
{
    void f()
    {
        ...
    }
};
</code></pre><p>or</p><pre><code>// foo.h
#pragma once

template &lt;typename T&gt;
struct Foo
{
    void f();
};

template &lt;typename T&gt;
inline void Foo::f()
{
    ...
}
</code></pre><p><strong>Pro:</strong></p><ul><li>Very convenient usage (just include the header).</li></ul><p><strong>Con:</strong></p><ul><li>Interface and method implementation are mixed. This is &#34;just&#34; a readability problem. Some find this unmaintainable, because it is different from the usual .h/.cpp approach. However, be aware that this is no problem in other languages, for example, C# and Java.</li><li>High rebuild impact: If you declare a new class with <code>Foo</code> as member, you need to include <code>foo.h</code>. This means that changing the implementation of <code>Foo::f</code> propagates through both header and source files.</li></ul><p>Lets take a closer look at the rebuild impact:
For non-templated C++ classes, you put declarations in .h and method definitions in .cpp. This way, when the implementation of a method is changed, only one .cpp needs to be recompiled. This is different for template  classes if the .h contains all you code. Take a look at the following example:</p><pre><code>// bar.h
#pragma once
#include &#34;foo.h&#34;
struct Bar
{
    void b();
    Foo&lt;int&gt; foo;
};

// bar.cpp
#include &#34;bar.h&#34;
void Bar::b()
{
    foo.f();
}

// qux.h
#pragma once
#include &#34;bar.h&#34;
struct Qux
{
    void q();
    Bar bar;
}

// qux.cpp
#include &#34;qux.h&#34;
void Qux::q()
{
    bar.b();
}
</code></pre><p>Here, the only usage of <code>Foo::f</code> is inside <code>bar.cpp</code>. However, if you change the implementation of <code>Foo::f</code>, both <code>bar.cpp</code> and <code>qux.cpp</code> need to be recompiled. The implementation of <code>Foo::f</code> lives in both files, even though no part of <code>Qux</code> directly uses anything of <code>Foo::f</code>. For large projects, this can soon become a problem.</p><p><strong>(2) Put declaration in .h and definition in .tpp and include it in .h.</strong></p><pre><code>// foo.h
#pragma once
template &lt;typename T&gt;
struct Foo
{
    void f();
};
#include &#34;foo.tpp&#34;    

// foo.tpp
#pragma once // not necessary if foo.h is the only one that includes this file
template &lt;typename T&gt;
inline void Foo::f()
{
    ...
}
</code></pre><p><strong>Pro:</strong></p><ul><li>Very convenient usage (just include the header).</li><li>Interface and method definitions are separated.</li></ul><p><strong>Con:</strong></p><ul><li>High rebuild impact (same as <strong>(1)</strong>).</li></ul><p>This solution separates declaration and method definition in two separate files, just like .h/.cpp. However, this approach has the same rebuild problem as <strong>(1)</strong>, because the header directly includes the method definitions.</p><p><strong>(3) Put declaration in .h and definition in .tpp, but dont include .tpp in .h.</strong></p><pre><code>// foo.h
#pragma once
template &lt;typename T&gt;
struct Foo
{
    void f();
};

// foo.tpp
#pragma once
template &lt;typename T&gt;
void Foo::f()
{
    ...
}
</code></pre><p><strong>Pro:</strong></p><ul><li>Reduces rebuild impact just as the .h/.cpp separation.</li><li>Interface and method definitions are separated.</li></ul><p><strong>Con:</strong></p><ul><li>Inconvenient usage: When adding a <code>Foo</code> member to a class <code>Bar</code>, you need to include <code>foo.h</code> in the header. If you call <code>Foo::f</code> in a .cpp, you <strong>also</strong> have to include <code>foo.tpp</code> there.</li></ul><p>This approach reduces the rebuild impact, since only .cpp files that really use <code>Foo::f</code> need to be recompiled. However, this comes at a price: All those files need to include <code>foo.tpp</code>. Take the example from above and use the new approach:</p><pre><code>// bar.h
#pragma once
#include &#34;foo.h&#34;
struct Bar
{
    void b();
    Foo&lt;int&gt; foo;
};

// bar.cpp
#include &#34;bar.h&#34;
#include &#34;foo.tpp&#34;
void Bar::b()
{
    foo.f();
}

// qux.h
#pragma once
#include &#34;bar.h&#34;
struct Qux
{
    void q();
    Bar bar;
}

// qux.cpp
#include &#34;qux.h&#34;
void Qux::q()
{
    bar.b();
}
</code></pre><p>As you can see, the only difference is the additional include of <code>foo.tpp</code> in <code>bar.cpp</code>. This is inconvenient and adding a second include for a class depending on whether you call methods on it seems very ugly. However, you reduce the rebuild impact: Only <code>bar.cpp</code> needs to be recompiled if you change the implementation of <code>Foo::f</code>. The file <code>qux.cpp</code> needs no recompilation.</p><p><strong>Summary:</strong></p><p>If you implement a library, you usually do not need to care about rebuild impact. Users of your library grab a release and use it and the library implementation does not change in the user&#39;s day to day work. In such cases, the library can use approach <strong>(1)</strong> or <strong>(2)</strong> and it is just a matter of taste which one you choose.</p><p>However, if you are working on an application, or if you are working on an internal library of your company, the code changes frequently. So you have to care about rebuild impact. Choosing approach <strong>(3)</strong> can be a good option if you get your developers to accept the additional include.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-splitting-and-hiding-headers-in-a-static-library/'>C++ &#8211; Splitting and hiding headers in a static library</a></li><li class="list-group-item"><a href='../c-where-should-i-place-a-typedef-when-used-in-method-signatures-in-c/'>C++ &#8211; Where should I place a typedef when used in method signatures in C++</a></li><li class="list-group-item"><a href='../c-include-own-header-file-first-or-last-any-technical-reasons/'>C++ &#8211; Include own header file first or last? Any technical reasons</a></li><li class="list-group-item"><a href='../object-oriented-using-friend-classes-to-encapsulate-private-member-functions-in-c-good-practice-or-abuse/'>Object-oriented &#8211; Using friend classes to encapsulate private member functions in C++ &#8211; good practice or abuse</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>