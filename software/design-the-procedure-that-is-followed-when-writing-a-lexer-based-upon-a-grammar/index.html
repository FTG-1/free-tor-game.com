<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Design &#8211;  the procedure that is followed when writing a lexer based upon a grammar &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1078321 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1078321" class="post-1078321 software type-software status-publish hentry category-software tag-design tag-design-patterns tag-development-process tag-grammar tag-lexer"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Design &#8211;  the procedure that is followed when writing a lexer based upon a grammar</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">design</span><span class="mr-2 badge badge-info">design-patterns</span><span class="mr-2 badge badge-warning">development-process</span><span class="mr-2 badge badge-primary">grammar</span><span class="mr-2 badge badge-danger">lexer</span></p><div class="entry-content"><p>While reading through an answer to the question <a href="https://softwareengineering.stackexchange.com/questions/223394/clarification-about-grammars-lexers-and-parsers"><em>Clarification about Grammars , Lexers and Parsers</em></a>, the answer stated that:</p><blockquote><p>[&#8230;] a BNF grammar contains all the rules you need for lexical analysis and parsing.</p></blockquote><p>This came across as somewhat odd to me because up until now, I&#39;d always thought that a lexer was <em>not</em> based upon a grammar at all, while a parser was heavily based upon one. I had come to this conclusion after reading numerous blog post about writing lexers, and not one ever using <sup>1</sup>EBNF/BNF as a basis for design.</p><p>If lexers, as well as parsers, are based upon an EBNF/BNF grammar, then how would one go about creating a lexer using that method? That is, how would I construct a lexer using a given EBNF/BNF grammar?</p><p>I&#39;ve seen many, <em>many</em> post that deal with writing a parser using EBNF/BNF as a guide or a blueprint, but I&#39;ve come across none so far that show the equivalent with lexer design.</p><p>For example, take the following grammar:</p><pre><code>input = digit| string ;
digit = &#34;0&#34; | &#34;1&#34; | &#34;2&#34; | &#34;3&#34; | &#34;4&#34; | &#34;5&#34; | &#34;6&#34; | &#34;7&#34; | &#34;8&#34; | &#34;9&#34; ;
string = &#39;&#34;&#39;, { all characters - &#39;&#34;&#39; }, &#39;&#34;&#39; ;
all characters = ? all visible characters ? ;
</code></pre><p>How would one create a lexer that is based on the grammar? I could imagine how a parser could be written from such a grammar, but I fail to grasp the concept of doing the same with a lexer.</p><p>Are there certain rules or logic used to accomplish a task such as this, as with writing a parser? Frankly, I&#39;m beginning to wonder whether lexer designs use an EBNF/BNF grammar at all, let alone are based upon one.</p><hr/><p><sup>1</sup><sub><a href="https://en.wikipedia.org/wiki/Extended_Backus–Naur_form" rel="noreferrer">Extended Backus–Naur form</a> and <a href="https://en.wikipedia.org/wiki/Backus–Naur_form" rel="noreferrer">Backus–Naur form</a></sub></p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Lexers are just simple parsers that are used as a performance optimisation for the main parser. If we have a lexer, the lexer and the parser work together to describe the complete language. Parsers that don&#39;t have a separate lexing stage are sometimes called “scannerless”.</p><p>Without lexers, the parser would have to operate on a character-by-character basis. Since the parser has to store metadata about every input item, and may have to pre-calculate tables for every input item state, this would result in unacceptable memory consumption for large input sizes. In particular, we don&#39;t need a separate node per character in the abstract syntax tree.</p><p>Since text on a character-by-character basis is fairly ambiguous, this would also result in much more ambiguity that is annoying to handle. Imagine a rule <code>R → identifier | &#34;for &#34; identifier</code>. where <em>identifier</em> is made up from ASCII letters. If I want to avoid ambiguity, I now need a 4-character lookahead to determine which alternative should be chosen. With a lexer, the parser just has to check whether it has an IDENTIFIER or FOR token – a 1-token lookahead.</p><h3>Two-level grammars.</h3><p>Lexers work by translating the input alphabet to a more convenient alphabet.</p><p>A scannerless parser describes a grammar (N, Σ, P, S) where the non-terminals N are the left hand sides of the rules in the grammar, the alphabet Σ is e.g. ASCII characters, the productions P are the rules in the grammar, and the start symbol S is the parser&#39;s top level rule.</p><p>The lexer now defines an alphabet of tokens a, b, c, …. This allows the main parser to use these tokens as alphabet: Σ = {a, b, c, …}. For the lexer, these tokens are non-terminals, and the start rule S<sub>L</sub> is S<sub>L</sub> → ε | a S | b S | c S | …, that is: any sequence of tokens. The rules in the lexer grammar are all rules necessary to produce these tokens.</p><p>The performance advantage comes from expressing the lexer&#39;s rules as a <em>regular language</em>. These can be parsed much more efficiently than context-free languages. In particular, regular languages can be recognized in O(n) space and O(n) time. In practice, a code generator can turn such a lexer into highly efficient jump tables.</p><h3>Extracting tokens from your grammar.</h3><p>To touch on your example: the <code>digit</code> and <code>string</code> rules are expressed on a character-by-character level. We could use those as tokens. The rest of the grammar stays intact. Here&#39;s the lexer grammar, written as a right-linear grammar to make it clear that it&#39;s regular:</p><pre><code>digit = &#34;0&#34; | &#34;1&#34; | &#34;2&#34; | &#34;3&#34; | &#34;4&#34; | &#34;5&#34; | &#34;6&#34; | &#34;7&#34; | &#34;8&#34; | &#34;9&#34; ;
string = &#39;&#34;&#39; , string-rest ;
string-rest = &#39;&#34;&#39; | STRING-CHAR, string-rest ;
STRING-CHAR = ? all visible characters ? - &#39;&#34;&#39; ;
</code></pre><p>But since it&#39;s regular, we would usually use regular expressions to express the token syntax. Here are the above token definitions as regexes, written using .NET character class exclusion syntax and POSIX charclasses:</p><pre><code>digit ~ [0-9]
string ~ &#34;[[:print:]-[&#34;]]*&#34;
</code></pre><p>The grammar for the main parser then contains the remaining rules not handled by the lexer. In your case, that&#39;s just:</p><pre><code>input = digit | string ;
</code></pre><h3>When lexers can&#39;t be used easily.</h3><p>When designing a language, we would usually take care that the grammar can be separated cleanly into a lexer level and a parser level, and that the lexer level describes a regular language. This is not always possible.</p><ul><li><p>When embedding languages. Some languages allow you to interpolate code into strings: <code>&#34;name={expression}&#34;</code>. The expression syntax is part of the context-free grammar and therefore can&#39;t be tokenized by a regular expression. To solve this, we either recombine the parser with the lexer, or we introduce additional tokens like <code>STRING-CONTENT, INTERPOLATE-START, INTERPOLATE-END</code>. The grammar rule for a string might then look like: <code>String → STRING-START STRING-CONTENTS { INTERPOLATE-START Expression INTERPOLATE-END STRING-CONTENTS } STRING-END</code>. Of course the Expression may contain other strings, which leads us to the next problem.</p></li><li><p>When tokens could contain each other. In C-like languages, keywords are indistinguishable from identifiers. This is solved in the lexer by prioritizing keywords over identifiers. Such a strategy isn&#39;t always possible. Imagine a config file where <code>Line → IDENTIFIER &#34; = &#34; REST</code>, where the rest is any character until the end of the line, even if the rest looks like an identifier. An example line would be <code>a = b c</code>. The lexer is really dumb and does not know in which order the tokens may occur. So if we prioritize IDENTIFIER over REST, the lexer would give us <code>IDENT(a), &#34; = &#34;, IDENT(b), REST( c)</code>. If we prioritize REST over IDENTIFIER, the lexer would just give us <code>REST(a = b c)</code>.</p><p>To solve this, we have to recombine the lexer with the parser. The separation can be maintained somewhat by making the lexer lazy: each time the parser needs the next token, it requests it from the lexer and tells the lexer the set of acceptable tokens. Effectively, we are creating a new top-level rule for the lexer grammar for each position. Here, this would result in the calls <code>nextToken(IDENT), nextToken(&#34; = &#34;), nextToken(REST)</code>, and everything works fine. This requires a parser that knows the complete set of acceptable tokens at each location, which implies a bottom-up parser like LR.</p></li><li><p>When the lexer has to maintain state. E.g. the Python language delimits code blocks not by curly braces, but by indentation. There are ways to handle layout-sensitive syntax within a grammar, but those techniques are overkill for Python. Instead, the lexer checks the indentation of each line, and emits INDENT tokens if a new indented block is found, and DEDENT tokens if the block has ended. This simplifies the main grammar because it can now pretend those tokens are like curly braces. The lexer however now needs to maintain state: the current indentation. This means the lexer technically no longer describes a regular language, but actually a context-sensitive language. Luckily this difference is not relevant in practice, and Python&#39;s lexer can still work in O(n) time.</p></li></ul></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../python-coming-up-with-tokens-for-a-lexer/'>Python &#8211; Coming up with tokens for a lexer</a></li><li class="list-group-item"><a href='../chosing-a-parser-for-a-code-beautifier/'>Chosing a parser for a code beautifier</a></li><li class="list-group-item"><a href='../what-should-be-the-datatype-of-the-tokens-a-lexer-returns-to-its-parser/'>What should be the datatype of the tokens a lexer returns to its parser</a></li><li class="list-group-item"><a href='../when-to-use-a-parser-combinator-when-to-use-a-parser-generator/'>When to use a Parser Combinator? When to use a Parser Generator</a></li><li class="list-group-item"><a href='../design-is-repetition-expressed-in-backus-naur-form-by-recursive-production-definitions/'>Design &#8211; Is repetition expressed in Backus–Naur form by recursive production definitions</a></li><li class="list-group-item"><a href='../should-the-lexer-allow-what-is-obviously-a-syntax-error/'>Should the lexer allow what is obviously a syntax error</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>