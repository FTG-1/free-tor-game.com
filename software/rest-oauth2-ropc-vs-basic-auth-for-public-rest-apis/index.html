<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Rest &#8211; OAuth2 ROPC vs Basic Auth for public REST APIs &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1064160 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1064160" class="post-1064160 software type-software status-publish hentry category-software tag-https tag-oauth tag-rest"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Rest &#8211; OAuth2 ROPC vs Basic Auth for public REST APIs</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">https</span><span class="mr-2 badge badge-info">oauth</span><span class="mr-2 badge badge-warning">rest</span></p><div class="entry-content"><p>The specific use case I&#39;m interested in here is authenticating REST clients against publicly-available server endpoints (such as a public REST API).</p><p>The simplest solution here is <strong>Basic Auth</strong>. But I often hear OAuth2 touted as a superior auth solution in almost all circumstances.</p><p>The thing is, the <em>only</em> OAuth2 grant type that is feasible for a REST client authenticating against a REST server is <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2"><strong>Resource Owner Password Credentials (ROPC)</strong></a>, because Code Grants and Implicit Grants require a UI/webpage (hosted by the Auth Server) for the user to login to and manually authorize the client app.</p><p>The way ROPC works is, by sending the resource owner&#39;s username/password, and the client ID as <em>query string params</em>?!? This is even less secure (IMHO) then Basic Auth, which at least base-64 encodes the credentials and sends them inside a header which can be encrypted by TLS!</p><p>So I ask: in the context of public REST APIs, is OAuth2 ROPC <em>really</em> any better than Basic Auth? What is more secure than OAuth2 ROPC?</p><hr/><h3>Update</h3><p>I just read <a href="http://www.thebuzzmedia.com/designing-a-secure-rest-api-without-oauth-authentication/">this excellent article</a> which explains Amazon&#39;s non-OAuth2 based REST security for AWS. It is essentially a private key-based solution where hashes of each REST request are generated and sent as sidecars along-side the normal (un-encrypted) request. Only the client and the server know the private key, so when the server receives the request (again, containing the normal request + the hashed request), the server looks up the client&#39;s private key, applies the same hash to the normal request, and then compares the two hashes.</p><p><strong>This sounds way more complicated, complex and secure than OAuth2&#39;s ROPC!</strong> Unless I&#39;m missing something <em>major</em> here, OAuth2 ROPC is just sending <code>client_id</code>, <code>username</code> and <code>password</code> as query string params&#8230;totally and utterly unsecure! This HMAC/hashed-based solution seems to be much more impressive and secure.</p><p>The thing is, even the author of that article goes on to say:</p><blockquote><p>You [will] also slowly realize and accept that at some point you will have to implement OAuth&#8230;</p></blockquote><p><strong>Ba-ba-bwhat?!?!</strong> If OAuth2 is <em>less secure</em> than this clever HMAC/hash-based solution, why does the author of this article feel OAuth needs to be embraced at some point. I&#39;m so confused.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>The answer to your question can be at the code level, protocol level or architecture level. I will attempt to summarize here most of the protocol level issues since that is usually critical in pros and cons analysis. Keep in mind that <a href="https://www.rfc-editor.org/rfc/rfc6749" rel="nofollow noreferrer">OAuth2</a> is much more than <a href="https://www.rfc-editor.org/rfc/rfc6749#section-10.4" rel="nofollow noreferrer">Resource Owner Password Credentials</a> which, according to the specification, exists for &#34;legacy or migration reasons&#34;, is considered &#34;higher risk than other grant types&#34; and the specification explicitly states that the clients and authorization servers &#34;SHOULD minimize use of this grant type and utilize other grant types whenever possible&#34;.</p><p>There are still many advantages of using ROPC over basic authentication but before we get into that, let&#39;s understand the basic protocol difference between OAuth2 and basic authentication. Please bear with me as I explain these and will come to ROPC later.</p><p><strong>User authentication flows</strong></p><p>There are four roles defined in OAuth2 specification. With examples, they are:</p><ol><li>Resource owner: The user who has access to some resource, e.g. in your case, different users may have different access level to the REST API;</li><li>The client: usually the application the user is using, and needs access to the resource to provide services to the user;</li><li>Resource server: the REST API in your case; and</li><li>Authorization server: the server to which user&#39;s credentials are presented and which will authenticate the user.</li></ol><p>When a client application runs, it is granted access to the resources based on the user. If a user has administrator privileges, the resources and operations available to the user in REST API may be far more than a user without administrator privileges.</p><p>OAuth2 also allows the possibility of using a single authorization server with multiple clients and for multiple resources. As an example, a resource server can accept user&#39;s authentication with Facebook (which can act as authorization server in such a case). So when the user runs an application (i.e. the client), it sends the user to Facebook. User types their credentials in Facebook, and the client gets back a &#34;token&#34; which it can present to the resource server. Resource server looks at the token and accepts it after verifying that Facebook in fact issued it and allow the user access to the resource. In this case, the client never sees user&#39;s credentials (i.e. their Facebook credentials).</p><p>But let&#39;s say you are managing your user&#39;s identities (and have an authorization server) instead of Facebook, which grants tokens to your client already. Now, let&#39;s say you also have a partner and you want to allow their application (i.e. client) to access your REST API. With basic authentication (or even ROPC), the user will provide credentials to that client which will send it to the authorization server. Authorization server will then provide a token that can be used by the client to access the resources. Unfortunately, this means that user&#39;s credentials are now visible to that client too. However, you would not want a partner&#39;s application (who could be external to your organization) to even know a user&#39;s password. That&#39;s a security issue now. In order to achieve that goal, you would want to use another flow (such as the authorization code grant) in which the user directly provides credentials to the authorization server.</p><p>Thus, with OAuth2, one would ideally not use ROPC in such cases rather use a different one, such as authorization code flow. This protects any application from knowing the user&#39;s credentials which are presented only to the authorization server. Thus, a user&#39;s credentials are not leaked. The same issues apply with basic authentication, but in the next section, I will explain how ROPC is still better because the user&#39;s credentials still do not need to be stored by the client in ROPC for persistent access by the clients.</p><p>Note that when the user goes to the authorization server, the authorization server can also ask user to confirm that they want to allow the client to access the resources on their behalf or not. That is why it is called the <em>authorization server</em> because the process of authorizing a client to access resources is entailed in the process. If the user does not authorize the client, it will not get access to the resources. Likewise, if the user themselves do not have access to the resources, the authorization server can still deny access and not issue a token.</p><p>In basic authentication, even the authorization server and resource server are combined into a single entity. Thus, the resource server wants to authorize the user, so asks the credentials from client. The client furnishes those credentials which are used by the resource server to authenticate the user. This means that multiple resource servers will essentially be requiring credentials from the user.</p><p><strong>Token issuance</strong></p><p>The clients get tokens from authorization server, keep them around and use those to access the resources (more details on tokens themselves below). The clients never know the user&#39;s password (in flows other than ROPC) and do not need to store it. In ROPC, even though the clients do know the user&#39;s password, they still do not need to store it because they use these tokens to access resources. By contrast, in basic authentication, if a client does not want to have user to provide credentials in every session, then the client has to store the user&#39;s password so they can furnish it the next time around. This is a major drawback to using basic authentication unless the client is only a web application in which case, cookies can address some of these concerns. With native applications, that&#39;s usually not an option.</p><p>There is another aspect of OAuth2 which is entailed in how tokens are issued and they work. When a user furnishes credentials to the authorization server (even in ROPC), the authorization server can give one or more of the two types of tokens: 1) access token, and 2) refresh token.</p><p>Access tokens are sent to the resource server which will grant access to the resources after validating it, and usually they have a short lifetime, e.g. 1hr. Refresh tokens are sent to the authorization server by the client to get another access token when it expires, and usually have a large lifetime (e.g. a few days to months or even years).</p><p>When the client provides the access token to the resource server, it looks at the token and after validating, looks inside the token to determine whether to allow access or not. As long as access token is valid, the client can keep using it. Let&#39;s say the user closes the application and starts it the next day, and the access token is expired. Now the client will make a call to the authorization server and present the refresh token assuming it&#39;s not expired. Authorization server, since it already issued the token, verifies it and can determine that the user does not need to provide the credentials again and thus gives another access token to the client. The client now has access to the resource server again. This is how typically the client applications for Facebook and Twitter ask for credentials one time and then do not require the user to provide credentials again. These applications never need to know the users credentials and yet can access resources every time user starts the application.</p><p>Now the user can go into the authorization server (e.g. in their Facebook user profile), change password without impacting any client applications. They will all continue to function properly. If the user loses a device on which they already had an application with refresh tokens, they can tell authorization server (e.g. Facebook) to &#34;log them out&#34; of those applications which the authorization server (i.e. Facebook) will accomplish by not honoring any existing refresh tokens and forcing the user to provide credentials again when they try to access resources through those applications.</p><p><a href="https://www.rfc-editor.org/rfc/rfc7519" rel="nofollow noreferrer">JWT</a> is simply the token format that is usually used with OAuth2 and OpenID Connect. The methods of signing the token and validating it is also standardized with libraries available for those instead of every resource server implementing yet another solution. Thus, the advantage lies in reusability of code that has been vetted and continues to be supported.</p><p><strong>Security implications</strong></p><p>Basic authentication will be weaker when any of the above scenarios are in the picture. There is also an extensive <a href="https://www.rfc-editor.org/rfc/rfc6819" rel="nofollow noreferrer">threat model for OAuth2</a> available for developers who can use the suggestions in it to avoid common vulnerabilities in their implementations. If you go through the threat model, you will see that many implementation related vulnerabilities (such as open redirector and CSRF) are also covered in it. I did not go through comparison of those against basic authentication in this response.</p><p>The last major advantage of OAuth2 is that the protocol is standardized and multiple authorization servers, clients and resource servers honor it. Numerous libraries are available to developers, which are maintained so as security issues are found in implementations, the libraries are updated while allowing interoperability.</p><p><strong>Conclusion</strong></p><p>If you are writing a new application, IMO, the ideal case would be to avoid both the basic authentication and ROPC because of the issues inherent in them. However, each application has different needs, timelines, developer proficiency etc. so the decision is case-by-case. But even if you did not have any more need than basic authentication, by choosing it, you could lock yourself into an architecture that may not be easy to extend (e.g. if you have multiple servers in the future, you would not necessarily want to have the user provide credentials to each one of them rather just provide to authorization server once, which can hand out tokens, etc.)</p><p>Note that I did not address your comment about how the credentials are sent over the wire because those can be secured using TLS or a similar protocol, or proof of possession etc. As someone already suggested, base 64 encoding is 0 security, please do not be deluded by that. The differences mentioned above are usually at the architectural level and thus that is where I focused because architecture is the hardest to change once implemented.</p><p><a href="http://blogs.technet.com/b/ad/archive/2015/09/16/azure-ad-b2c-and-b2b-are-now-in-public-preview.aspx" rel="nofollow noreferrer">Azure Active Directory B2C Basic</a>, a service which I work on and was recently released for public preview, allows third party application to use AAD as the authorization server with interoperability with social IDPs (such as Facebook, Google, etc.). It also allows users to create their own accounts instead of using social IDPs and those can later be used for authentication purposes. There are a few other services also like that (e.g. another one I know of is <a href="https://auth0.com/" rel="nofollow noreferrer">auth0</a>) which can be used by developers to completely outsource authentication and user management for their applications and resources. The same protocols characteristics that I mentioned above is used by developers to decouple authorization server (AAD), a resource (e.g. their REST APIs), the client (e.g. their mobile applications), and users. I hope this explanation helps somewhat.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../rest-designing-authentication-for-rest-api/'>Rest &#8211; Designing authentication for REST API</a></li><li class="list-group-item"><a href='../rest-oauth-alternative-for-a-2-party-system/'>Rest &#8211; OAuth alternative for a 2 party system</a></li><li class="list-group-item"><a href='../rest-is-this-a-secure-solution-for-restful-authentication/'>Rest &#8211; Is this a secure solution for RESTful authentication</a></li><li class="list-group-item"><a href='../rest-api-security-hmac-key-hashing-vs-jwt/'>REST API security: HMAC/key hashing vs JWT</a></li><li class="list-group-item"><a href='../rest-api-security-stored-token-vs-jwt-vs-oauth/'>REST API security Stored token vs JWT vs OAuth</a></li><li class="list-group-item"><a href='../rest-token-based-authentication-using-access-and-refresh-tokens/'>Rest &#8211; Token-based authentication using access and refresh tokens</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>