<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="https://free-tor-game.com/wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Caching authenticated requests for all users &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js?ver=11.2.0' id='highlight-js'></script>     <script>( function( w, d, s, l, i ) {
				w[l] = w[l] || [];
				w[l].push( {'gtm.start': new Date().getTime(), event: 'gtm.js'} );
				var f = d.getElementsByTagName( s )[0],
					j = d.createElement( s ), dl = l != 'dataLayer' ? '&l=' + l : '';
				j.async = true;
				j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
				f.parentNode.insertBefore( j, f );
			} )( window, document, 'script', 'dataLayer', ' ' );</script>      <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1070529 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="https://free-tor-game.com/3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="https://free-tor-game.com/contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1070529" class="post-1070529 software type-software status-publish hentry category-software tag-authentication tag-caching tag-nginx"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Caching authenticated requests for all users</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">authentication</span><span class="mr-2 badge badge-info">caching</span><span class="mr-2 badge badge-warning">nginx</span></p><div class="entry-content"><p>I am working on a web app that must deal with very large impulses of simultaneous users, who need to be authorized, to request identical content. In its current state, it&#39;s totally crippling to even a 32-core AWS instance.</p><p><em>(Note that we&#39;re using Nginx as a reverse proxy)</em></p><p>The response cannot be simply cached since, in the worst case, we must check if the user is authenticated by decoding their JWT. This requires us firing up Laravel 4, which most would agree, is <strong>slow</strong>, even with PHP-FPM and OpCache enabled. This is mostly due to the hefty bootstrapping phase.</p><p>One might ask the question &#34;Why did you use PHP and Laravel in the first place if you knew this was going to be an issue?&#34; &#8211; but it&#39;s too late now to go back on that decision!</p><h1>Possible Solution</h1><p>One solution that has been put forward is to extract the Auth module from Laravel to a lightweight external module (written in something fast like C) whose responsibility it is to decode the JWT and decide if the user is authenticated.</p><p>The flow of a request would be:</p><ol><li>Check if cache hit (if not pass to PHP as normal)</li><li>Decode the token</li><li>Check if it&#39;s valid</li><li>If <strong>valid</strong>, serve from cache</li><li>If <strong>invalid</strong>, tell Nginx, and then Nginx will then pass the request to PHP to deal with as normal.</li></ol><p>This will allow us to not hit PHP once we have served this request to a single user and instead reach out to a lightweight module to mess around with decoding JWTs and any other caveats that come with this type of auth.</p><p>I was even thinking of writing this code directly as an Nginx HTTP extension module.</p><h1>Concerns</h1><p>My concern is that I&#39;ve never seen this done before and wondered if there&#39;s a better way.</p><p>Also, the second you add any user specific content to the page, it totally kills this method.</p><p>Is there another simpler solution available directly in Nginx? Or would we have to use something more specialized like Varnish?</p><h1>My Questions:</h1><p>Does the above solution make sense?</p><p>How is this normally approached?</p><p>Is there a better way to achieve a similar or better performance gain?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>I&#39;ve been trying to address a similar issue. 
My users need to be authenticated for every request they make.
I&#39;ve been focusing on getting the users authenticated at least once by the backend app (validation of the JWT token), but after that, I decided I shouldn&#39;t need the backend anymore.</p><p>I chose to avoid requiring any Nginx plugin that is not included by default. Otherwise you can check nginx-jwt or Lua scripting and these would probably be great solutions.</p><h1>Addressing authentication</h1><p>So far I&#39;ve done the following:</p><ul><li><p>Delegated the authentication to Nginx using <code>auth_request</code>. This calls an <code>internal</code> location that passes the request to my backend token validation endpoint. This alone doesn&#39;t address the issue of handling a high number of validations at all.</p></li><li><p>The result of the token validation is cached using a <code>proxy_cache_key &#34;$cookie_token&#34;;</code> directive. Upon successful token validation, the backend adds a <code>Cache-Control</code> directive that tells Nginx to only cache the token for up to 5 minutes. <strong>At this point, any auth token validated once is in the cache, subsequent requests from the same user/token don&#39;t touch the auth backend anymore!</strong></p></li><li><p>To protect my backend app against potential flooding by invalid tokens, I also cache refused validations, when my backend endpoint returns 401. These ones are only cached for a short duration to avoid potentially filling the Nginx cache with such requests.</p></li></ul><p>I&#39;ve added a couple of additional improvements such as a logout endpoint that invalidates a token by returning 401 (which is also cached by Nginx) so that if the user clicks logout, the token cannot be used anymore even if it&#39;s not expired.</p><p>Also, my Nginx cache contains for every token, the associated user as a JSON object, which saves me from fetching it from the DB if I need this information ; and also saves me from decrypting the token.</p><h1>About token lifetime and refresh tokens</h1><p>After 5 minutes, the token will have expired in the cache, so the backend will be queried again. This is to ensure that you&#39;re able to invalidate a token, because the user logs out, because it has been compromised, and so on. Such periodic revalidation, with proper implementation in the backend, avoids me to have to use refresh tokens.</p><p>Traditionally refresh tokens would be used to request a new access token; they would be stored in your backend and you would verify that a request for an access token is made with a refresh token that matches the one you have in the database for this specific user. If the user logs out, or tokens are compromised you would delete/invalidate the refresh token in your DB so that the next request for a new token using the invalidated refresh token would fail.</p><p>In short, refresh tokens usually have a long validity and are always checked against the backend. 
They are used to generate access tokens that have a very short validity (a few minutes). These access tokens normally do reach your backend but you only check their signature and expiration date.</p><p>Here in my setup, we are using tokens with a longer validity (can be hours or a day), that have the same role and features as both an access token and a refresh token. Because we have their validation and invalidation cached by Nginx, they are only fully verified by the backend once every 5 minutes. So we keep the benefit of using refresh tokens (be able to quickly invalidate a token) without the added complexity. And simple validation never ever reaches your backend that is at least 1 order of magnitude slower than the Nginx cache, even if used only for signature and expiry date checking.</p><p>With this setup, I could disable authentication in my backend, since all  incoming requests reach the <code>auth_request</code> Nginx directive before touching it.</p><p>That doesn&#39;t fully solve the problem if you need to perform any kind per-resource authorization, but at least you&#39;ve saved the basic authorization part. And you can even avoid decrypting the token or do a DB lookup to access token data since Nginx cached auth response can contain data and pass it back to the backend.</p><p>Now, my biggest concern is that I may be breaking something obvious related to security without realizing it.
That being said, any received token is still validated at least once before being cached by Nginx. Any tempered token would be different so wouldn&#39;t hit the cache since the cache key would also be different.</p><p>Also, maybe it&#39;s worth mentioning that a real world authentication would fight against token stealing by generating (and verifying) an additional Nonce or something.</p><p>Here is a simplified extract of my Nginx config for my app:</p><pre><code># Cache for internal auth checks
proxy_cache_path /usr/local/var/nginx/cache/auth levels=1:2 keys_zone=auth_cache:10m max_size=128m inactive=10m use_temp_path=off;
# Cache for content
proxy_cache_path /usr/local/var/nginx/cache/resx levels=1:2 keys_zone=content_cache:16m max_size=128m inactive=5m use_temp_path=off;
server {
    listen 443 ssl http2;
    server_name ........;

    include /usr/local/etc/nginx/include-auth-internal.conf;

    location /api/v1 {
        # Auth magic happens here
        auth_request         /auth;
        auth_request_set     $user $upstream_http_X_User_Id;
        auth_request_set     $customer $upstream_http_X_Customer_Id;
        auth_request_set     $permissions $upstream_http_X_Permissions;

        # The backend app, once Nginx has performed internal auth.
        proxy_pass           http://127.0.0.1:5000;
        proxy_set_header     X-User-Id $user;
        proxy_set_header     X-Customer-Id $customer;
        proxy_set_header     X-Permissions $permissions;

        # Cache content
        proxy_cache          content_cache;
        proxy_cache_key      &#34;$request_method-$request_uri&#34;;
    }
    location /api/v1/Logout {
        auth_request         /auth/logout;
    }

}
</code></pre><p>Now, here&#39;s the configuration extract for the internal <code>/auth</code> endpoint, included above as <code>/usr/local/etc/nginx/include-auth-internal.conf</code>:</p><pre><code># Called before every request to backend
location = /auth {
    internal;
    proxy_cache             auth_cache;
    proxy_cache_methods     GET HEAD POST;
    proxy_cache_key         &#34;$cookie_token&#34;;
    # Valid tokens cache duration is set by backend returning a properly set Cache-Control header
    # Invalid tokens are shortly cached to protect backend but not flood Nginx cache
    proxy_cache_valid       401 30s;
    # Valid tokens are cached for 5 minutes so we can get the backend to re-validate them from time to time
    proxy_cache_valid       200 5m;
    proxy_pass              http://127.0.0.1:1234/auth/_Internal;
    proxy_set_header        Host ........;
    proxy_pass_request_body off;
    proxy_set_header        Content-Length &#34;&#34;;
    proxy_set_header        Accept application/json;
}

# To invalidate a not expired token, use a specific backend endpoint.
# Then we cache the token invalid/401 response itself.
location = /auth/logout {
    internal;
    proxy_cache             auth_cache;
    proxy_cache_key         &#34;$cookie_token&#34;;
    # Proper caching duration (&gt; token expire date) set by backend, which will override below default duration
    proxy_cache_valid       401 30m;
    # A Logout requests forces a cache refresh in order to store a 401 where there was previously a valid authorization
    proxy_cache_bypass      1;

    # This backend endpoint always returns 401, with a cache header set to the expire date of the token
    proxy_pass              http://127.0.0.1:1234/auth/_Internal/Logout;
    proxy_set_header        Host ........;
    proxy_pass_request_body off;
}
</code></pre><p>.</p><h2>Addressing content serving</h2><p>Now the authentication is separated from the data. Since you told it was identical for every user, the content itself can also be cached by Nginx (in my example, in the <code>content_cache</code> zone).</p><h2>Scalability</h2><p>This scenario works great out of the box assuming that you have one Nginx server. In a real world scenario you probably have high availability, meaning multiple Nginx instances, potentially also hosting your (Laravel) backend application. In that case, any request your users make could be sent to any of your Nginx servers, and until they all have locally cached the token, they will keep reaching your backend to verify it. For a small number of servers, using this solution would still bring big benefits.</p><p>However, it is important to note that with multiple Nginx servers (and thus caches) you lose the ability to log out on the server side because you&#39;re unable to purge (by forcing a refresh) the tokens cache on all of them, like <code>/auth/logout</code> does in my example. You&#39;re only left with the 5mn token cache duration that will force your backend to be queried soon, and will tell Nginx that the request is denied. A partial workaround is to delete the token header or cookie on the client when logging out.</p><p>Any comment would be very welcomed and appreciated!</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='https://free-tor-game.com/software/api-caching-layer/'>API Caching Layer</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/rest-is-it-an-implementation-of-a-stateful-mechanism-for-rest-api-authentication/'>Rest &#8211; Is it an implementation of a stateful mechanism for Rest API authentication</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/rest-api-security-hmac-key-hashing-vs-jwt/'>REST API security: HMAC/key hashing vs JWT</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/how-to-handle-user-permission-changes-in-spa/'>How to handle user permission changes in SPA</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='http://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="https://free-tor-game.com/wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>