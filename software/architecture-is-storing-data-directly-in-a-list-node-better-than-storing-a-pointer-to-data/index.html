<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Architecture &#8211; Is storing data directly in a list node better than storing a pointer to data &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1086117 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1086117" class="post-1086117 software type-software status-publish hentry category-software tag-architecture tag-data-structures tag-linked-list tag-list tag-performance"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Architecture &#8211; Is storing data directly in a list node better than storing a pointer to data</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">Architecture</span><span class="mr-2 badge badge-info">data structures</span><span class="mr-2 badge badge-warning">linked list</span><span class="mr-2 badge badge-primary">list</span><span class="mr-2 badge badge-danger">performance</span></p><div class="entry-content"><p>Suppose we have two different doubly-linked list structures:</p><ol><li><p>One has content of the node embedded directly in the node:</p><pre><code>struct Content {
    // some stuff
};
struct Node {
    struct Node *next;
    struct Node *prev;
    struct Content content;
}
</code></pre></li><li><p>The other has a pointer to content:</p><pre><code>struct Content;
struct Node {
    struct Node *next;
    struct Node *prev;
    struct Content *content;
}
</code></pre></li></ol><p>What are considerations to prefer one option to the other? The points can be about everything: performance in different conditions, architecture, ease of modification, ease of manipulating the list, etc.</p><p>I&#39;d like to gather knowledge about the trade-offs present.</p><p>Shown code is <code>C</code>, but the question also applies to <code>C++</code>, or any other language which has explicit pointers.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><h2>Critical Path: Element Traversal</h2><p>Let&#39;s say your most critical loops sequentially iterate through a list and access <code>Content</code>. In that case, typically in descending order of efficiency and ascending order of flexibility:</p><p><strong>1. Intrusive C-Style List Node</strong></p><p>The highest performance and least amount of flexibility is often going to go to the &#34;classic&#34; C-style intrusive linked list backed by a fixed allocator. The list pointers and contents are inseparably tied together, yielding a very inflexible (but often most compact) solution, like so:</p><pre><code>struct ContentNode {
    // The content data is *directly* embedded here (either below or above
    // these pointers for optimal alignment at the cost of minimal padding).
    struct ContentNode *prev;
    struct ContentNode *next;
};
</code></pre><p>This is only sometimes more efficient than <code>2</code> below while <em>always</em> being far less flexible. It only provides a benefit over the second solution if you can reduce the amount of padding by directly embedding the contents into the list node itself.</p><p>The level of flexibility lost here is enormous as the notion of element and list node fuse into one inseparable, tightly-bundled concept. And it&#39;s also quite dumb to use (in my strong opinion) unless you are first using a fixed allocator to give back a lot of the spatial locality that linked structures generally lack.</p><p>Yet the most performance-critical areas of a codebase will often be looking at elements that are aggregated into one primary data structure (possibly with auxiliary data structures pointing to them, but still one <em>main</em> data structure). In that case, your profiling/tuning sessions might have you ultimately reaching for this kind of very-inflexible solution in some very isolated, performance-critical section of your codebase.</p><p><strong>2. Non-Intrusive, Contiguous List Node</strong></p><p>This would be like your first version, and is dramatically more flexible as <code>Content</code> and <code>Node</code> do not have to be inseparable (<code>Content</code> could be stored in other data structures that own its memory, e.g.).</p><pre><code>struct Node {
    struct Node *next;
    struct Node *prev;
    struct Content content;
}
</code></pre><p>This only costs more than <code>1</code> in the rare event that it results in more padding, yet is <em>always</em> more flexible as it decouples <code>Content</code> from the linked list representation.</p><p><strong>3. Disjointed List Node</strong></p><p>This describes your second solution and tends to be the least efficient as a result of additional cache misses, page faults, and the need for an additional pointer to be stored (more memory usage overall).</p><pre><code>struct Node {
    struct Node *next;
    struct Node *prev;
    struct Content *content;
}
</code></pre><p>Yet this is the easiest way to achieve flexibility, especially in C if you turn <code>content</code> into a void pointer, as you can generalize your linked list very easily this way. Another way to generalize is to use variable-length structs.</p><p><strong>Fixed Allocator</strong></p><p>In these cases, where performance is a top priority and the critical paths of the list iterate through list elements and access them, it&#39;s insane not to use a fixed allocator.</p><p>The biggest immediate performance concern of linked lists in cases where the nodes/elements are smallish in size is the loss of contiguity (&#34;disjointed memory&#34;) which translates to at least more compulsory cache misses and page faults and possibly even more non-compulsory ones as well.</p><p>The fixed allocator is an easy &#34;reach-around&#34; solution when you are inevitably stuck with a linked structure to dramatically reduce cache misses/page faults.</p><p><strong>&#34;Efficient&#34;</strong></p><p>It&#39;s worth noting that the differences between these diminish if the size of the <code>Content</code> data fields are really large. They show up the most if <code>Content</code> is really small (ex: 16 bytes, maybe 64 bytes, not 400 bytes). If <code>Content</code> is huge (hundreds of bytes or more), then the differences start to become increasingly moot as well as the need for a fixed allocator.</p><h2>Critical Path: List Manipulation</h2><p>Let&#39;s say, instead, that your most critical paths of execution don&#39;t even inspect <code>Content</code> data fields and just manipulate list pointers.</p><p>In that case, the tables turn. Now <code>3</code> becomes the most efficient solution as a result of hot/cold field splitting (<code>Content</code> fields becomes cold data, rarely accessed, and the list pointers become hot data, frequently accessed).</p><p>In this case, you still want to use a fixed allocator pooling chunks of data from contiguous pooled memory for the <code>Node</code> (don&#39;t have to for <code>Content</code> quite as much here given that it&#39;s cold) to reduce page faults and cache misses (at least compulsory ones even if you end up totally rearranging the list).</p><p>When combined with the fixed allocator and the hot/cold field splitting, now more nodes can be allocated and accessed without triggering further page faults/cache misses as a result of the smaller size per node (with the cold <code>Content</code> data being stored elsewhere).</p><p>All the dynamics here are going to be related to memory efficiency with respect to the memory hierarchy. If you want to get the most out of your linked structures (trees and linked lists), then this is the place to study.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../does-the-headstart-pointer-of-doubly-linked-list-points-previously-to-the-taillast-node/'>Does the Head(start) pointer of Doubly Linked list points previously to the tail(last) node</a></li><li class="list-group-item"><a href='../designing-online-exam/'>Designing online exam</a></li><li class="list-group-item"><a href='../c-2d-linked-list-vs-multidimensional-array-vector/'>C++ &#8211; 2D linked list vs. multidimensional array/vector</a></li><li class="list-group-item"><a href='../c-linked-list-implementation-pointer-vs-pointer-to-pointer-consistency/'>C Linked List Implementation Pointer vs. Pointer-to-Pointer Consistency</a></li><li class="list-group-item"><a href='../data-structures-and-algorithms-for-a-directed-rooted-tree-with-inherited-properties/'>Data structures and algorithms for a directed rooted tree with inherited properties</a></li><li class="list-group-item"><a href='../how-to-write-a-doubly-linked-list-for-multi-core-use-without-global-lock/'>How to write a doubly linked list for multi-core use without global lock</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>