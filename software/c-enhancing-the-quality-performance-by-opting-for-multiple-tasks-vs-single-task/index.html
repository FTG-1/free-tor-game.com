<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="https://free-tor-game.com/wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C# &#8211; Enhancing the quality &#038; performance by opting for multiple tasks vs single task &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js?ver=11.2.0' id='highlight-js'></script>     <script>( function( w, d, s, l, i ) {
				w[l] = w[l] || [];
				w[l].push( {'gtm.start': new Date().getTime(), event: 'gtm.js'} );
				var f = d.getElementsByTagName( s )[0],
					j = d.createElement( s ), dl = l != 'dataLayer' ? '&l=' + l : '';
				j.async = true;
				j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
				f.parentNode.insertBefore( j, f );
			} )( window, document, 'script', 'dataLayer', ' ' );</script>      <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1086680 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="https://free-tor-game.com/3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="https://free-tor-game.com/contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1086680" class="post-1086680 software type-software status-publish hentry category-software tag-c tag-game-development tag-multithreading tag-net"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C# &#8211; Enhancing the quality &#038; performance by opting for multiple tasks vs single task</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">game development</span><span class="mr-2 badge badge-warning">multithreading</span><span class="mr-2 badge badge-primary">net</span></p><div class="entry-content"><p>I&#39;m trying to improve the performance, code quality and just make it better in terms of practice overall. I have a server for a game that managers all users connected as well as things like objects and rooms + a lot more. Its divided by rooms, each room will have players and objects placed. During the execution of this emulation system I have to check on things.</p><p>I have done this using a class, ran from the main class &#39;Game&#39; that initiate all the sub child classes such as RoomManager, ObjectManager, you get the idea&#8230;</p><p>My main reason for asking this is I don&#39;t know if I should move from having 1 task in &#39;Game&#39; to just giving the managers their individual classes, someone coming from an advanced background of C#, could you give me a clear response?</p><p>My second reason was to ask if there was anything that seemed to do a better job doing these sort of operatings? Maybe some sort of thread or timer, over a task.</p><p>These operations don&#39;t take long, its usually just checking for new movement requests, packet updates, and looping through dictionarys (timed out connections) at the moment, although that could change, so I&#39;ll need something that could be good for any kind of operation.</p><p>Another thing is some of these methods that the task calls have different intervals that they need to run at, if you take a look at my below code some only run every 30 seconds, some only run every 0.5 seconds, I&#39;ve added stopwatch&#39;s and if statements to block the methods if its not time for it to run, maybe this can also be avoided in changing the way it works?</p><p>I&#39;m just not sure if moving to multiple tasks is the right choice, on one hand you have the multiple intervals issue, but then the overhead of managing multiple tasks, but is that a bad thing?</p><p>Anyone who can give some insight please do, thank you.</p><pre><code>public class Game()
{
    public Game()
    {       
        _gameCycle = new Task(GameCycle);
        _gameCycle.Start();

        _cycleActive = true;
    }

    private void GameCycle()
    {
        while (_cycleActive)
        {
            _cycleEnded = false;

            ObjectManager.OnCycle();
            RoomManager.OnCycle();
            PlayerManager.OnCycle();
            TalentManager.OnCycle();

            _cycleEnded = true;
            Thread.Sleep(25);
        }
    }

    public void StopGameLoop()
    {
        _cycleActive = false;

        while (!_cycleEnded)
        {
            Thread.Sleep(25);
        }
    }
}

public class ObjectManager
{
    private Stopwatch lastOperation;

    public ObjectManager()
    {
        clientPingStopwatch = new Stopwatch();
        clientPingStopwatch.Start();
    }

    public void OnCycle()
    {
        Operation1();
        Operation2();
    }

    public void Operation1()
    {
        try 
        {
            // do some work
        }
        catch {
            // ignored
        }
    }

    public void Operation2()
    {
        // I only want to run this one every 30 seconds.

        if (lastOperation.ElapsedMilliseconds &gt;= 30000)
        {
            lastOperation.Restart();

            try 
            {
                // do some work
            }
            catch {
                // ignored
            }
        }
    }
}

public class RoomManager
{
    private Stopwatch lastOperation;

    public RoomManager()
    {
        clientPingStopwatch = new Stopwatch();
        clientPingStopwatch.Start();
    }

    public void OnCycle()
    {
        Operation();
    }

    public void Operation()
    {
        // I only want to run this one every half a second.

        if (lastOperation.ElapsedMilliseconds &gt;= 500)
        {
            lastOperation.Restart();

            try 
            {
                // do some work
            }
            catch {
                // ignored
            }
        }
    }
}

public class PlayerManager
{
    public void OnCycle()
    {
        try 
        {
            // do some work
        }
        catch {
            // ignored
        }
    }
}

public class TalentManager
{
    public void OnCycle()
    {
        try 
        {
            // do some work
        }
        catch {
            // ignored
        }
    }
}
</code></pre><p>Catch blocks are marked with &#34;// ignored&#34; because I choose to ignore them for now, I&#39;ve added the comments for debugging purposes.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>I&#39;m just not sure if moving to multiple tasks is the right choice, on
 one hand you have the multiple intervals issue, but then the overhead
 of managing multiple tasks, but is that a bad thing?</p></blockquote><p>By overhead if you mean programming/maintenance overhead, yes it could be depending on how difficult it is to make your system thread safe. Since you don&#39;t specify what each manager is doing, I can only compare it to common game engines like AAA game engines that use ECS, and many opt not to concurrently run their systems (&#34;managers&#34;) because of the difficulty of the state management and the evaluation order dependencies between their systems (&#34;managers&#34;). Instead they parallelize what the managers individually do. The few who dared to try this often came back with battle scars and stories to tell about how difficult it was to concurrently run the physics engine efficiently at the same time other systems were tampering with motion components while the system handling player interactions was simultaneously moving things around, e.g.</p><blockquote><p>My second reason was to ask if there was anything that seemed to do a better job doing these sort of operatings? Maybe some sort of thread or timer, over a task.</p></blockquote><p>A very immediate and unambiguously better version over what you are doing now by polling a stopwatch in a loop with manual thread sleeps is to use <code>System.Timers.Timer</code> and instead invoke manager cycles in the <code>Elapsed</code> event:</p><p><a href="https://msdn.microsoft.com/en-us/library/system.timers.timer(v=vs.110).aspx" rel="noreferrer">System.Timers.Timer</a></p><p>That&#39;s a much easier answer than whether or not you should design your game so that each system (&#34;manager&#34;) can be run in parallel (either through tasks or threads) which can be, depending on the scope of the game, a moderately to extremely ambitious undertaking.</p><p>It also doesn&#39;t make much sense to use tasks here, assuming your <code>Game</code> and <code>Managers</code> are persistent. They don&#39;t benefit from utilizing the thread pool as with short-lived tasks that are executed repeatedly (ex: in a parallel loop). So it&#39;s more of a question of threads vs. timers, and timers are a definite improvement over what you have now with polling... threads are &#34;conceptually optimal&#34; but may make your system so much more difficult to design safely and efficiently.</p><blockquote><p>My main reason for asking this is I don&#39;t know if I should move from having 1 task in &#39;Game&#39; to just giving the managers their individual classes, someone coming from an advanced background of C#, could you give me a clear response?</p></blockquote><p>In my opinion, what you&#39;re considering so far isn&#39;t bad assuming this is not like some ambitious AAA game engine. I tripped up over the sentence where you asked about giving managers individual classes which sounds like it relates to design and organization. The idea to have these <code>Managers</code> is not bad in my opinion and it at least adheres better to SRP than one giant Game object processing everything. That said, I wasn&#39;t clear if your question was about organization or about multithreading or both so I&#39;ll focus the answer on how to effectively <em>design</em> and <em>organize</em> the code in a way that will give you option of <em>exploring</em> the most efficient multithreading capabilities.</p><blockquote><p>[...] although that could change, so I&#39;ll need something that could be
 good for any kind of operation.</p></blockquote><p>Your design is actually somewhat starting to resemble what you find in AAA game engines using entity-component systems so I recommend studying them and how they parallelize processing for a start. One major difference in those engines is that they call these managers <code>Systems</code>, like <code>RoomSystem</code>, and the systems have sophisticated central capabilities to query components in the engine (ex: <code>RoomSystem</code> being able to fetch all the <code>Room</code> components to process at a specific time). The components managed by the systems in an ECS are also just raw data (<code>Room</code> is just data, not a complex object), and for good reason. The systems also don&#39;t store the components, they fetch them from a central place representing all the entities that have components in the game, because two or more systems might be interested in processing the same game entities.</p><p><strong>Multithreading</strong></p><p>What I&#39;d suggest as a next step in your immediate case is to formalize the idea of a <code>Manager</code> interface so that you don&#39;t have to hard-code what <code>OnCycle</code> methods to call on which managers in your <code>GameCycle</code>. The manager should be able to specify how frequently it wants to be called through the common interface that all managers share, and the game should be able to store a collection of managers and invoke these kinds on <code>OnCycle</code> methods on the managers without knowing precisely what kind of manager they are. The central <code>Game</code> object can be responsible for whether it uses a separate thread per manager, a single thread with a stopwatch, a task per manager, etc.</p><p>That will also make it easier to explore things besides a crude thread that just sleeps and periodically calls <code>OnCycle</code> if you ever need, and will prevent you from having to hardcode things like:</p><pre><code>if (lastOperation.ElapsedMilliseconds &gt;= 500)
{
    ...
}
</code></pre><p>... into every single manager. It&#39;ll also eliminate the need to manually keep track of a stop watch in every manager. The stop watch polling approach with a single thread that sleeps a lot is probably decent enough in practice for a smaller project and shields you from thread safety challenges, but it&#39;s far from optimal in terms of efficiency, and this will at least allow you to explore alternatives much easier in the future without changing code in every single manager, only changing central code in <code>Game</code>. Timer events would be an immediately superior solution to polling this way without making you deal with thread safety since the OS generally does things a lot smarter than polling a stop watch while sleeping the thread repeatedly for a fixed duration in a loop.</p><p><strong>Process All Entities</strong></p><p>The next thing I&#39;d explore possibly is a way to allow managers to fetch game data they&#39;re interested in efficiently and maybe even process it in parallel, like:</p><pre><code>// Inside a manager: call SomeDelegate for each `Room` in the game.
game.ProcessAll(SomeDelegate, Room);
</code></pre><p><code>game.ProcessAll</code> could be responsible for iterating all through game objects which have a specific type of component or adhere to a specific interface, like a room, and this gives you room to make <code>ProcessAll</code> multithreaded so that it&#39;s automating the process of invoking the delegate on multiple rooms concurrently without the <code>RoomManager</code> having to bother with the multithreading.</p><p>I suggest this because you&#39;re more likely to be immediately bottlenecked processing the entities in your game world instead of failing to parallelize the game systems (&#34;managers&#34;) themselves. Having a way to conveniently process entities of interest in any given manager in parallel could net you more performance gains than even running every manager in parallel because the heaviest loops in most game engines typically are the ones that have to iterate through all the entities of interest (can&#39;t skip any and this will always be linear time) and do something with them within a given system (or &#34;manager&#34;). There&#39;s enough work often in just one of those entity-processing loops within a system to devote the entire hardware&#39;s resources without overkill. That could especially apply for the server side if you have many, many clients connected.</p><p><strong>Timers vs. Threads. vs Tasks</strong></p><p>Again this is not a direct answer to your question of whether you use tasks or threads or timers, but it offers you the design to explore all these options in the future without changing much code. For a direct answer, the ideal theoretical solution for hardware scalability would likely be to make each manager a separate thread while likewise making all the bulky operations each manager performs parallelized, but that also comes with the most gotchas and will really require you to think carefully about how to make the game state both thread safe and thread efficient. Even a lot of commercial ECS engines don&#39;t bother to parallelize the processing that goes on in every system (&#34;manager&#34;) because even if that would theoretically yield the most optimal solution, it&#39;s too difficult to get correct to be worthwhile.</p><p>John Carmack has some good ideas on doing this with central, immutable data structures which can be partially copied (made unique) atomically as threads read and write to certain sections of a buffer with new versions of the buffer potentially being swapped with the old after every frame, but it&#39;s a very ambitious undertaking to say the least to try to make an engine that can simply run all systems concurrently (&#34;managers&#34;) without a care in the world as they seek to read and transform overlapping game data.</p><p>So IMHO, it&#39;s generally overkill to try to run all the systems concurrently with tasks or threads. It can become a lot easier to reason about the system if, at least for most systems, you can deduce an order in which they are executed which could be important if you have a system depending on the output of a previous system. Instead it&#39;s much easier to parallelize the most expensive operations performed by specific systems than to run all the systems in parallel.</p><p>That said, something that occurred to me just now is that you are running lots of your managers against a timer. That already tends to make it so they aren&#39;t executing their operations in any deterministic order. If there are no order dependencies among managers, it will at least make it a lot easier to run those managers that lack order dependencies in a separate thread (but still requiring appropriate ways to access shared resources safely and efficiently in parallel if you do this). For breathing room, you might include a way in, say, <code>IManager</code> implemented by all managers to indicate whether they should run in a separate thread or task or from within the central game logic thread. <code>Game</code> can then use that to decide whether to spawn off each manager in a separate thread or not.</p><p><strong>ObjectManager Operations</strong></p><p>Anyway, if you organize things this way, there&#39;s something going on here:</p><pre><code>// Inside ObjectManager:
public void Operation1()
{
   ...
}

public void Operation2()
{
    // I only want to run this one every 30 seconds.
    if (lastOperation.ElapsedMilliseconds &gt;= 30000)
    {
        ...
    }
}
</code></pre><p>If you use this kind of manager idea, I would suggest that <code>ObjectManager</code> should be split into two -- one that does whatever <code>Operation2</code> does every half a minute, and the other which does <code>Operation1</code> all the time. The central game state shouldn&#39;t be stored in these managers, maybe in your <code>Game</code> object which can be injected into these managers or passed by parameter. That&#39;ll give you more flexibility to design managers which process the game elements when they aren&#39;t storing the game elements themselves.</p><p>Anyway, this is just a start -- one iteration to kind of improve your design a little bit and make it easier to optimize centrally without cascading changes. It&#39;s actually working a little bit towards the entity-component system route with some of its benefits, but without going towards a full-blown ECS.</p><p><strong>ECS Example</strong></p><p>Here&#39;s a basic simplistic example of how an ECS is organized and processed to give you ideas:</p><p><a href="https://i.stack.imgur.com/KSi5V.png" rel="noreferrer"><img src="https://i.stack.imgur.com/KSi5V.png" alt="enter image description here"/></a></p><p>As you can see above, there&#39;s a processing order indicated in the diagram which indicates that the systems are invoked sequentially, not in parallel with a separate thread per system. However, some expensive operations that process all the components in the ECS might be invoked in parallel <em>within</em> a given system.</p><p>The ECS is favored a lot among game engines given that it leaves a lot of room for optimization when you have these bulky systems (&#34;managers&#34;) doing a lot of processing instead of teeny processing scattered across a boatload of tiny objects. It also tends to actually simplify the maintainability of the code and your ability to reason about how the system works when you only have the major game logic inside a handful of systems and not scattered across, say, a hundred different subtypes which have to communicate with each other and depend on each other forming a complex graph of interdependencies (however loosely coupled). In the above diagram, the <code>Car</code> entity contains no functionality, only components, and the components contain no functionality, only data. The only place that contains functionality are those 3 systems in the diagram: <code>MovementSystem</code>, <code>AudioSystem</code>, and <code>RenderingSystem</code>.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='https://free-tor-game.com/software/c-passing-data-between-concrete-states/'>C# &#8211; Passing data between concrete states</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/what-would-be-the-best-way-to-store-movements-on-a-game-to-allow-a-rollback/'>What would be the best way to store movements on a game to allow a rollback</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/c-method-to-validate-an-object-should-i-have-one-method-encapsulating-all-validation-logic/'>C# &#8211; Method to validate an object &#8211; should I have one method encapsulating all validation logic</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/c-what-construct-do-i-use-to-guarantee-100-tasks-are-running-in-parallel/'>C# &#8211; What construct do I use to guarantee 100 tasks are running in parallel</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='http://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="https://free-tor-game.com/wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>