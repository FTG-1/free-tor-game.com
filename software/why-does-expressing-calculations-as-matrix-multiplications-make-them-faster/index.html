<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Why does expressing calculations as matrix multiplications make them faster &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1069251 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1069251" class="post-1069251 software type-software status-publish hentry category-software tag-matrices tag-performance"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Why does expressing calculations as matrix multiplications make them faster</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">matrices</span><span class="mr-2 badge badge-info">performance</span></p><div class="entry-content"><p>In Google&#39;s <a href="https://www.tensorflow.org/versions/r0.7/tutorials/mnist/beginners/" rel="noreferrer">MNist tutorial using TensorFlow</a>, a calculation is exhibited in which one step is equivalent to multiplying a matrix by a vector. Google first shows a picture in which each numeric multiplication and addition that would go into performing the calculation is written out in full. Next, they show a picture in which it is instead expressed as a matrix multiplication, claiming that this version of the calculation is, or at least might be, faster:</p><blockquote><p>If we write that out as equations, we get:</p><p><a href="../../../i.stack.imgur.com/ssf7N.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/ssf7N.png" alt="scalar equation"/></a></p><p>We can &#34;vectorize&#34; this procedure, turning it into a matrix multiplication and vector addition. This is helpful for computational efficiency. (It&#39;s also a useful way to think.)</p><p><a href="../../../i.stack.imgur.com/cyFtH.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/cyFtH.png" alt="vector equation"/></a></p></blockquote><p>I know that equations like this are usually written in the matrix multiplication format by machine learning practitioners, and can of course see advantages to doing so from the standpoints of code terseness or of understanding the mathematics. What I don&#39;t understand is Google&#39;s claim that converting from the longhand form to the matrix form <em>&#34;is helpful for computational efficiency&#34;</em></p><p>When, why, and how would it be possible to gain performance improvements in software by expressing calculations as matrix multiplications? If I were to calculate the matrix multiplication in the second (matrix-based) image myself, as a human, I&#39;d do it by sequentially doing each of the distinct calculations shown in the first (scalar) image. To me, they are nothing but two notations for the same sequence of calculations. Why is it different for my computer? Why would a computer be able to perform the matrix calculation faster than the scalar one?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>This may sound obvious, but computers don&#39;t execute <strong>formulas</strong>, they execute <strong>code</strong>, and how long that execution takes depends directly on the code they execute and only indirectly on whatever concept that code implements. Two logically identical pieces of code can have very different performance characteristics. Some reasons that are likely to crop up in matrix multiplication specifically:</p><ul><li>Using multiple threads. There is almost no modern CPU that doesn&#39;t have multiple cores, many have up to 8, and specialized machines for high-performance computing can easily have 64 across several sockets. Writing code in the obvious way, in a normal programming language, uses only <em>one</em> of those. In other words, it may use <em>less than 2%</em> of the available computing resources of the machine it&#39;s running on.</li><li>Using SIMD instructions (confusingly, this is also called &#34;vectorization&#34; but in a different sense than in the text quotes in the question). In essence, instead of 4 or 8 or so scalar arithmetic instructions, give the CPU <em>one</em> instruction that performs arithmetic on 4 or 8 or so registers in parallel. This can literally make some calculations (when they&#39;re a perfectly independent and fit for the instruction set) 4 or 8 times faster.</li><li>Making smarter <a href="https://stackoverflow.com/q/16699247/395760">use of the cache</a>. Memory access are faster if they are <em>temporally and spatially coherent</em>, that is, consecutive accesses are to nearby addresses and when accessing an address twice you access it twice in quick succession rather than with a long pause.</li><li>Using accelerators such as GPUs. These devices are very different beasts from CPUs and programming them efficiently is an whole art form of its own. For example, they have hundreds of cores, which are grouped into groups of a few dozen cores, and these groups share resources â€” they share a few KiB of memory that is much faster than normal memory, and when any core of the group executes an <code>if</code> statement all the others in that group have to wait for it.</li><li><a href="https://en.wikipedia.org/wiki/Message_Passing_Interface" rel="noreferrer">Distribute the work</a> over several machines (very important in supercomputers!) which introduces a huge set of new headaches but can, of course, give access to vastly greater computing resources.</li><li>Smarter algorithms. For matrix multiplication the simple O(n^3) algorithm, properly optimized with the tricks above, are often faster than <a href="https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm#Sub-cubic_algorithms" rel="noreferrer">the sub-cubic ones</a> for reasonable matrix sizes, but sometimes they win. For special cases such as sparse matrices, you can write specialized algorithms.</li></ul><p>A lot of smart people have written very <a href="https://en.wikipedia.org/wiki/BLAS" rel="noreferrer">efficient code for common linear algebra operations</a>, using the above tricks and many more and usually even with stupid platform-specific tricks. Therefore, transforming your formula into a matrix multiplication <em>and then implementing that calculation by calling into a mature linear algebra library</em> benefits from that optimization effort. By contrast, if you simply write the formula out in the obvious way in a high-level language, the machine code that is eventually generated won&#39;t use all of those tricks and won&#39;t be as fast. This is also true if you take the matrix formulation and implement it by calling a naive matrix multiplication routine that you wrote yourself (again, in the obvious way).</p><p>Making code fast <em>takes work</em>, and often quite a lot of work if you want that last ounce of performance. Because so many important calculations can be expressed as combination of a couple of linear algebra operations, it&#39;s economical to create highly optimized code for these operations. Your one-off specialized use case, though? Nobody cares about that except you, so optimizing the heck out of it is not economical.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-why-would-it-ever-be-possible-for-java-to-be-faster-than-c/'>Java &#8211; Why would it ever be possible for Java to be faster than C++</a></li><li class="list-group-item"><a href='../why-is-nosql-faster-than-sql/'>Why is NoSQL faster than SQL</a></li><li class="list-group-item"><a href='../why-does-haskells-built-in-max-function-run-faster-than-mine/'>Why does Haskell&#8217;s built in max function run faster than mine</a></li><li class="list-group-item"><a href='../javascript-why-is-the-latter-function-10-faster-although-it-must-create-the-variables-over-and-over-again/'>Javascript &#8211; why is the latter function 10% faster although it must create the variables over and over again</a></li><li class="list-group-item"><a href='../web-development-why-is-one-way-data-flow-eg-react-vue-angular-faster-than-two-way-data-binding-with-dirty-checking/'>Web-development &#8211; Why is one way data flow (eg. React, Vue, Angular) faster than two way data binding with dirty checking</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>