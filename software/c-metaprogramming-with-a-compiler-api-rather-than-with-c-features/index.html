<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++: Metaprogramming with a compiler API rather than with C++ features &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1072871 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1072871" class="post-1072871 software type-software status-publish hentry category-software tag-c tag-c11 tag-clang tag-meta-programming"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++: Metaprogramming with a compiler API rather than with C++ features</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">c++11</span><span class="mr-2 badge badge-warning">clang</span><span class="mr-2 badge badge-primary">meta-programming</span></p><div class="entry-content"><p>This started out as a SO question but I realized that it is quite unconventional and based on the actual description on the websites, it might be better suited to programmers.se since the question has a lot of conceptual weight.</p><p>I have been learning <a href="http://clang.llvm.org/docs/Tooling.html" rel="noreferrer">clang LibTooling</a> and it is a very powerful tool capable of exposing the entire &#34;nitty gritty&#34; of the code in a friendly way, that is, in a <em>semantic</em> way, and not by guessing either. If clang can compile your code, then clang is <em>certain</em> about the semantics of every single character inside that code.</p><p>Now allow me to step back for a moment.</p><p>There are many practical problems that arise when one engages in C++ template metaprogramming (and especially when venturing beyond templates into the territory of clever albeit terrifying macros). To be honest, to many programmers, myself included, many of the ordinary uses of templates are also somewhat terrifying.</p><p>I guess a good example would be <a href="https://stackoverflow.com/questions/15858141">compile-time strings</a>. This is a question that is over a year old now, but it is clear that C++ as of right now does not make this easy for mere mortals. While looking at these options isn&#39;t quite enough to induce nausea for me, it nevertheless leaves me unconfident about being able to produce magical, maximally efficient machine code to suit whatever fancy application I have for my software.</p><p>I mean, let&#39;s face it, folks, strings are pretty simple and basic. Some of us just want a convenient way to emit machine code that has certain strings &#34;baked in&#34; significantly more than we do get when coding it the straightforward way. In our C++ code.</p><p>Enter clang and LibTooling, which exposes the abstract syntax tree (AST) of the source code and allows a simple custom C++ application to correctly and reliably manipulate raw source code (using <code>Rewriter</code>) alongside a rich semantic object-oriented model of everything in the AST. It handles a lot of things. It knows about the macro expansions, and lets you follow those chains. Yes, I am talking about source-to-source code transformation or translation.</p><p>My fundamental thesis here is that clang now enables us to create executables which themselves can function as the ideal custom preprocessor stages to our C++ software, and we can implement these metaprogramming stages with C++. We are simply constrained by the fact that this stage must take input which is valid C++ code and produce as output more valid C++ code. Plus whatever other constraints your build system applies.</p><p>The input has to be at least very close to valid C++ code because, after all, clang is the compiler front-end and we are just poking around and being creative with its API. I do not know if there is any provision for being able to define new syntax to use, but clearly we have to develop the ways to properly parse it and add it to the clang project in order to do this. To expect any more is to have something in the clang project that is out of scope.</p><p>Not a problem. I would imagine that some no-op macro functions can handle this task.</p><p>Another way to look at what I&#39;m describing is to implement metaprogramming constructs using runtime C++ by manipulating the AST of our source code (thanks to clang and its API) instead of implementing them using the more limited tools available in the language itself. This has clear compilation performance benefits as well (template-heavy headers slow compilation proportionally to how often you use them. Lots of compiled stuff then gets carefully matched up and thrown away by the linker).</p><p>This does, however, come at the cost of introducing an additional step or two in the build process and also in the requirement of writing some (admittedly) somewhat more verbose software (but at least it is straightforward runtime C++) as part of our tool.</p><p>That isn&#39;t the whole picture. I am pretty certain that there is a much larger space of functionality that can be had from generating code that is extremely difficult or impossible with core language features. In C++ you can write a template or a macro or a crazy combination of both, but in a clang tool you can modify classes and functions in ANY way that you can achieve with C++, at <em>runtime</em>, while having full access to the semantic content, <em>in addition</em> to template and macros and everything else.</p><p>So, I&#39;m wondering about why everybody isn&#39;t already doing this. Is it that this functionality from clang is so new and nobody is familiar with the huge class hierarchy of clang&#39;s AST? That can&#39;t be it.</p><p>Perhaps I am just underestimating the difficulty of this a little bit, but doing &#34;compile-time string manipulation&#34; with a clang tool is nearly criminally simple. It&#39;s verbose, but it&#39;s insanely straightforward. All that&#39;s needed are a bunch of no-op macro functions that map to actual real <code>std::string</code> operations. The clang plugin implements this by fetching all the relevant no-op macro calls, and performs the operations with strings. This tool is then inserted as a part of the build process. During build, these no-op macro function calls are automatically evaluated into their results, and then inserted back as plain old compile-time strings in the program. The program can then be compiled as usual. In fact this resulting program is also much more portable as a result, not requiring a fancy new compiler supporting C++11.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Yes, Virginia, there is a Santa Claus.</p><p>The notion of using programs to modify programs has been around a long time. The original idea came from <a href="http://en.wikipedia.org/wiki/John_von_Neumann" rel="noreferrer">John von Neumann</a> in the form of stored-program computers.  But machine code modifying machine code in arbitrary ways is pretty inconvenient.</p><p>People generally want to modify <em>source</em> code.  This is mostly realized in the form of <a href="http://en.wikipedia.org/wiki/Program_transformation" rel="noreferrer">program transformation systems (PTS)</a>.</p><p>PTS generally offer, for at least one programming language, the ability to parse to ASTs, manipulate that AST, and regenerate valid source text.  If in fact you dig around, for most mainstream languages, somebody has built such a tool (Clang is an example for C++, the Java compiler offers this capability as an API, Microsoft offers Rosyln, Eclipse&#39;s JDT, ...) with a procedural API that is actually pretty useful.  For the broader community, almost every language-specific community can point to something like this, implemented with various levels of maturity (usually modest, many &#34;just parsers producing ASTs&#34;).  Happy metaprogramming.</p><p>[There&#39;s a reflection-oriented community that tries to do metaprogramming from <em>inside</em> the programming language, but only achieve &#34;runtime&#34; behaviour modifiation, and only to the extent that the language compilers made <em>some</em> information available by reflection. With the exception of LISP, there are always details about the program that are not available by reflection (&#34;Luke, you need the source&#34;) that always limit what reflection can do.]</p><p>The more interesting PTS do this for <em>arbitrary</em> languages (you give the tool a language description as a configuration parameter, including at a minimum the BNF).  Such PTS also allow you to do &#34;source to source&#34; transformation, e.g., specify <em>patterns</em> directly using the surface syntax of the targeted language; using such patterns, you can code fragments of interest, and/or find and replace code fragments.  This is far more convenient than the programming API, because you don&#39;t have to know every microscopic details about the ASTs to do most of your work.  Think of this as meta-metaprogramming :-}</p><p>A downside: unless the PTS offers various kinds of useful static analyses (symbol tables, control and data flow analyses), it is hard to write really interesting transformations this way, because you need to check types and verify information flows for most practical tasks.  Unfortunately, this capability is in fact rare in the general PTS.  (It is always unavailable with the ever-proposed &#34;If I just had a parser... &#34;  See my bio for a longer discussion of &#34;Life After Parsing&#34;).</p><p>There&#39;s a theorem that says if you can do string rewriting [thus tree rewriting] you can do arbitrary transformation; and thus a number of PTS lean on this to claim you can metaprogram anything with just the tree rewrites they offer. While the theorem is satisfying in the sense you are now sure you can do anything, it is unsatisfying in the same way that a Turing Machine&#39;s ability to do anything doesn&#39;t make programming a Turing Machine the method of choice. (The same holds true for systems with just procedural APIs, if they will let you make arbitrary changes to the AST [and in fact I think this is not true of Clang]).</p><p>What you want is the best of both worlds, a system that offers you the generality of the language-parameterized type of PTS (even handling multiple languages), with the additional static analyses, the ability to mix source-to-source transformations with procedural APIs.  I only know of <em>two</em> that do this:</p><ul><li>Rascal (MPL) MetaProgramming Language</li><li>our DMS Software Reengineering Toolkit</li></ul><p>Unless <em>you</em> want the write the language descriptions and static analyzers yourself (for C++ this is a tremendous amount of work, which is why Clang was constructed both as a compiler and as general procedural metaprogramming foundation), you will want a PTS with mature language descriptions already available.  Otherwise you will spend all your time configuring the PTS, and none doing the work you actually wanted to do. [If you pick a random, non-mainstream language, this step is very hard to avoid].</p><p>Rascal tries to do this by co-opting &#34;OPP&#34; (Other People&#39;s Parsers) but that doesnt help with the static analysis part.  I think they have Java pretty well in hand, but I&#39;m very sure they don&#39;t do C or C++. But, its a academic research tool; hard to blame them.</p><p>I emphasize, <em>our</em> [commercial] DMS tool does have Java, C, C++ full front ends available. For C++, it covers almost everything in C++14 for GCC and even Microsoft&#39;s variations (and we are polishing now), macro expansion and conditional management, and method-level control and data flow analysis.  And yes, you <em>can</em> specify grammar changes in a practical way; we built a custom VectorC++ system for a client that radically extended C++ to use what amount to F90/APL data-parallel array operations.   DMS has been used to carry out other massive metaprogramming tasks on large C++ systems (e.g., application architectural reshaping).  (I am the architect behind DMS).</p><p>Happy meta-metaprogramming.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../clang-warning-flags-for-objective-c-development/'>Clang warning flags for Objective-C development</a></li><li class="list-group-item"><a href='../c-ast-processing-and-usefulness-of-visitor-pattern/'>C++ &#8211; AST processing and usefulness of visitor pattern</a></li><li class="list-group-item"><a href='../why-does-llvm-have-an-assembly-like-ir-rather-than-a-tree-like-ir-or-why-do-projects-target-llvm-ir-instead-of-clangs-ast/'>Why does LLVM have an assembly-like IR rather than a tree-like IR? Or: why do projects target LLVM IR instead of clang&#8217;s AST</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>