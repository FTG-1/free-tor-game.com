<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Are value converters more trouble than they&#8217;re worth &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1068559 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1068559" class="post-1068559 software type-software status-publish hentry category-software tag-mvvm tag-silverlight tag-wpf tag-xaml"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Are value converters more trouble than they&#8217;re worth</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">mvvm</span><span class="mr-2 badge badge-info">silverlight</span><span class="mr-2 badge badge-warning">wpf</span><span class="mr-2 badge badge-primary">xaml</span></p><div class="entry-content"><p>I&#39;m working on a WPF application with views that require numerous value conversions. Initially, my philosophy (inspired in part by <a href="http://groups.google.com/group/wpf-disciples/browse_thread/thread/3fe270cd107f184f">this lively debate on XAML Disciples</a>) was that I should make the view model strictly about supporting the <em>data</em> requirements of the view. This meant that any value conversions required to turn data into things like visibilities, brushes, sizes, etc. would be handled with value converters and multi-value converters. Conceptually, this seemed quite elegant. The view model and view would both have a distinct purpose and be nicely decoupled. A clear line would be drawn between &#34;data&#34; and &#34;look&#34;.</p><p>Well, after giving this strategy &#34;the old college try&#34;, I&#39;m having some doubts whether I want to continue developing this way. I&#39;m actually strongly considering dumping the value converters and placing the responsibility for (almost) all value conversion squarely in the hands of the view model.</p><p>The reality of using value converters just doesn&#39;t seem to be measuring up to the apparent value of cleanly separated concerns. My biggest issue with value converters is that they are tedious to use. You have to create a new class, implement <code>IValueConverter</code> or <code>IMultiValueConverter</code>, cast the value or values from <code>object</code> to the correct type, test for <code>DependencyProperty.Unset</code> (at least for multi-value converters), write the conversion logic, <strike>register the converter in a resource dictionary</strike> [see update below], and finally, hook up the converter using rather verbose XAML (which requires use of magic strings for both the binding(s) <strike>and the name of the converter</strike> [see update below]). The debugging process is no picnic either, as error messages are often cryptic, especially in Visual Studio&#39;s design mode/Expression Blend.</p><p>This isn&#39;t to say that the alternative&#8211;making the view model responsible for all value conversion&#8211;is an improvement. This could very well be a matter of the grass being greener on the other side. Besides losing the elegant separation of concerns, you have to write a bunch of derived properties and make sure you conscientiously call <code>RaisePropertyChanged(() =&gt; DerivedProperty)</code> when setting base properties, which could prove to be an unpleasant maintenance issue.</p><p>The following is an initial list I put together of the pros and cons of allowing view models to handle conversion logic and doing away with value converters:</p><ul><li>Pros:<ul><li>Fewer total bindings since multi-converters are eliminated</li><li>Fewer magic strings (binding paths <strike>+ converter resource names</strike><em>)</em></li><p><em><br /> </em></p><li><em><strike>No more registering each converter (plus maintaining this list)</strike></em></li><li>Less work to write each converter (no implementing interfaces or casting required)</li><li>Can easily inject dependencies to help with conversions (e.g., color tables)</li><li>XAML markup is less verbose and easier to read</li><li>Converter reuse still possible (although some planning is required)</li><li>No mysterious issues with DependencyProperty.Unset (a problem I noticed with multi-value converters)</li></ul></li></ul><p>*Strikethroughs indicate benefits that disappear if you use markup extensions (see update below)</p><ul><li>Cons:<ul><li>Stronger coupling between view model and view (e.g., properties must deal with concepts like visibility and brushes)</li><li>More total properties to allow direct mapping for every binding in view</li><li><strike><code>RaisePropertyChanged</code> must be called for each derived property</strike> (see Update 2 below)</li><li>Must still rely on converters if the conversion is based on a property of a UI element</li></ul></li></ul><p>So, as you can probably tell, I have some heartburn about this issue. I&#39;m very hesitant to go down the road of refactoring only to realize that the coding process is just as inefficient and tedious whether I use value converters or expose numerous value conversion properties in my view model.</p><p>Am I missing any pros/cons? For those who have tried both means of value conversion, which did you find worked better for you and why? Are there any other alternatives? (The disciples mentioned something about type descriptor providers, but I couldn&#39;t get a handle on what they were talking about. Any insight on this would be appreciated.)</p><hr/><p><strong>Update</strong></p><p>I found out today that it&#39;s possible to use something called a &#34;markup extension&#34; to eliminate the need to register value converters. In fact, it not only eliminates the need to register them, but it actually provides intellisense for selecting a converter when you type <code>Converter=</code>. Here is the article that got me started: <a href="http://www.wpftutorial.net/ValueConverters.html">http://www.wpftutorial.net/ValueConverters.html</a>.</p><p>The ability to use a markup extension changes the balance somewhat in my pros and cons listing and discussion above (see strikethroughs).</p><p>As a result of this revelation, I&#39;m experimenting with a hybrid system where I use converters for <code>BoolToVisibility</code> and what I call <code>MatchToVisibility</code> and the view model for all other conversions. MatchToVisibility is basically a converter that lets me check if the bound value (usually an enum) matches one or more values specified in XAML.</p><p>Example:</p><pre><code>Visibility=&#34;{Binding Status, Converter={vc:MatchToVisibility
            IfTrue=Visible, IfFalse=Hidden, Value1=Finished, Value2=Canceled}}&#34;
</code></pre><p>Basically what this does is check if the status is either Finished or Canceled. If it is, then the visibility gets sets to &#34;Visible&#34;. Otherwise, it gets sets to &#34;Hidden&#34;. This turned out to be a very common scenario, and having this converter saved me about 15 properties on my view model (plus associated RaisePropertyChanged statements). Note that when you type <code>Converter={vc:</code>, &#34;MatchToVisibility&#34; shows up in an intellisense menu. This noticeably reduces the chance of errors and makes using value converters less tedious (you don&#39;t have to remember or look up the name of the value converter you want).</p><p>In case you&#39;re curious, I&#39;ll paste the code below. One important feature of this implementation of <code>MatchToVisibility</code> is that it checks to see if the bound value is an <code>enum</code>, and if it is, it checks to make sure <code>Value1</code>, <code>Value2</code>, etc. are also enums of the same type. This provides a design-time and run-time check of whether any of the enum values are mistyped. To improve this to a compile-time check, you can use the following instead (I typed this by hand so please forgive me if I made any mistakes):</p><pre><code>Visibility=&#34;{Binding Status, Converter={vc:MatchToVisibility
            IfTrue={x:Type {win:Visibility.Visible}},
            IfFalse={x:Type {win:Visibility.Hidden}},
            Value1={x:Type {enum:Status.Finished}},
            Value2={x:Type {enum:Status.Canceled}}&#34;
</code></pre><p>While this is safer, it&#39;s just too verbose to be worth it for me. I might as well just use a property on the view model if I&#39;m going to do this. Anyway, I&#39;m finding that the design-time check is perfectly adequate for the scenarios I&#39;ve tried so far.</p><p><strong>Here&#39;s the code for <code>MatchToVisibility</code></strong></p><pre><code>[ValueConversion(typeof(object), typeof(Visibility))]
public class MatchToVisibility : BaseValueConverter
{
    [ConstructorArgument(&#34;ifTrue&#34;)]
    public object IfTrue { get; set; }

    [ConstructorArgument(&#34;ifFalse&#34;)]
    public object IfFalse { get; set; }

    [ConstructorArgument(&#34;value1&#34;)]
    public object Value1 { get; set; }

    [ConstructorArgument(&#34;value2&#34;)]
    public object Value2 { get; set; }

    [ConstructorArgument(&#34;value3&#34;)]
    public object Value3 { get; set; }

    [ConstructorArgument(&#34;value4&#34;)]
    public object Value4 { get; set; }

    [ConstructorArgument(&#34;value5&#34;)]
    public object Value5 { get; set; }

    public MatchToVisibility() { }

    public MatchToVisibility(
        object ifTrue, object ifFalse,
        object value1, object value2 = null, object value3 = null,
        object value4 = null, object value5 = null)
    {
        IfTrue = ifTrue;
        IfFalse = ifFalse;
        Value1 = value1;
        Value2 = value2;
        Value3 = value3;
        Value4 = value4;
        Value5 = value5;
    }

    public override object Convert(
        object value, Type targetType, object parameter, CultureInfo culture)
    {
        var ifTrue = IfTrue.ToString().ToEnum&lt;Visibility&gt;();
        var ifFalse = IfFalse.ToString().ToEnum&lt;Visibility&gt;();
        var values = new[] { Value1, Value2, Value3, Value4, Value5 };
        var valueStrings = values.Cast&lt;string&gt;();
        bool isMatch;
        if (Enum.IsDefined(value.GetType(), value))
        {
            var valueEnums = valueStrings.Select(vs =&gt; vs == null ? null : Enum.Parse(value.GetType(), vs));
            isMatch = valueEnums.ToList().Contains(value);
        }
        else
            isMatch = valueStrings.Contains(value.ToString());
        return isMatch ? ifTrue : ifFalse;
    }
}
</code></pre><p><strong>Here&#39;s the code for <code>BaseValueConverter</code></strong></p><pre><code>// this is how the markup extension capability gets wired up
public abstract class BaseValueConverter : MarkupExtension, IValueConverter
{
    public override object ProvideValue(IServiceProvider serviceProvider)
    {
        return this;
    }

    public abstract object Convert(
        object value, Type targetType, object parameter, CultureInfo culture);

    public virtual object ConvertBack(
        object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
</code></pre><p><strong>Here&#39;s the ToEnum extension method</strong></p><pre><code>public static TEnum ToEnum&lt;TEnum&gt;(this string text)
{
    return (TEnum)Enum.Parse(typeof(TEnum), text);
}
</code></pre><hr/><p><strong>Update 2</strong></p><p>Since I posted this question, I&#39;ve come across an open-source project that uses &#34;IL weaving&#34; to inject NotifyPropertyChanged code for properties and dependent properties. This makes implementing Josh Smith&#39;s vision of the view model as a &#34;value converter on steroids&#34; an absolute breeze. You can just use &#34;Auto-Implemented Properties&#34;, and the weaver will do the rest.</p><p><strong>Example:</strong></p><p>If I enter this code:</p><pre><code>public string GivenName { get; set; }
public string FamilyName { get; set; }

public string FullName
{
    get
    {
        return string.Format(&#34;{0} {1}&#34;, GivenName, FamilyName);
    }
}
</code></pre><p>&#8230;this is what gets compiled:</p><pre><code>string givenNames;
public string GivenNames
{
    get { return givenName; }
    set
    {
        if (value != givenName)
        {
            givenNames = value;
            OnPropertyChanged(&#34;GivenName&#34;);
            OnPropertyChanged(&#34;FullName&#34;);
        }
    }
}

string familyName;
public string FamilyName
{
    get { return familyName; }
    set 
    {
        if (value != familyName)
        {
            familyName = value;
            OnPropertyChanged(&#34;FamilyName&#34;);
            OnPropertyChanged(&#34;FullName&#34;);
        }
    }
}

public string FullName
{
    get
    {
        return string.Format(&#34;{0} {1}&#34;, GivenName, FamilyName);
    }
}
</code></pre><p>That&#39;s a huge savings in the amount of code you have to type, read, scroll past, etc. More importantly, though, it saves you from having to figure out what your dependencies are. You can add new &#34;property gets&#34; like <code>FullName</code> without having to painstakingly go up the chain of dependencies to add in <code>RaisePropertyChanged()</code> calls.</p><p>What is this open-source project called? The original version is called &#34;NotifyPropertyWeaver&#34;, but the owner (Simon Potter) has since created a platform called &#34;Fody&#34; for hosting a whole series of IL weavers. The equivalent of NotifyPropertyWeaver under this new platform is called PropertyChanged.Fody.</p><ul><li><strong>Fody setup instructions:</strong> <a href="http://code.google.com/p/fody/wiki/SampleUsage">http://code.google.com/p/fody/wiki/SampleUsage</a> (replace &#34;Virtuosity&#34; with &#34;PropertyChanged&#34;)</li><li><strong>PropertyChanged.Fody project site:</strong> <a href="http://code.google.com/p/propertychanged/">http://code.google.com/p/propertychanged/</a></li></ul><p>If you&#39;d prefer to go with NotifyPropertyWeaver (which a little simpler to install, but won&#39;t necessarily be updated in the future beyond bug fixes), here is the project site:<br /> <a href="http://code.google.com/p/notifypropertyweaver/">http://code.google.com/p/notifypropertyweaver/</a></p><p>Either way, these IL weaver solutions completely change the calculus in the debate between view model on steroids vs. value converters.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>I have used <code>ValueConverters</code> in some cases and put the logic in the <code>ViewModel</code> in others.  My feeling is that a <code>ValueConverter</code> becomes part of the <code>View</code> layer, so if the logic is really part of the <code>View</code> then put it there, otherwise put it in the <code>ViewModel</code>.</p><p>Personally I don&#39;t see a problem with a <code>ViewModel</code> dealing with <code>View</code>-specific concepts like <code>Brush</code>es because in my applications a <code>ViewModel</code> only exists as a testable and bindable surface for the <code>View</code>.  However, some people put a lot of business logic in the <code>ViewModel</code> (I do not) and in that case the <code>ViewModel</code> is more like a part of their business layer, so in that case I wouldn&#39;t want WPF-specific stuff in there.</p><p>I prefer a different separation:</p><ul><li><code>View</code> - WPF stuff, sometimes untestable (like XAML and code-behind) but also <code>ValueConverter</code>s</li><li><code>ViewModel</code> - testable and bindable class that is also WPF-specific</li><li><code>EditModel</code> - part of the business layer that represents my model during manipulation</li><li><code>EntityModel</code> - part of the business layer that represents my model as persisted</li><li><code>Repository</code> - responsible for persistence of the <code>EntityModel</code> to the database</li></ul><p>So, the way I do it, I have little use for <code>ValueConverter</code>s</p><p>The way I got away from some of your &#34;Con&#39;s&#34; is to make my <code>ViewModel</code>&#39;s very generic.  For instance, one <code>ViewModel</code> I have, called <code>ChangeValueViewModel</code> implements a Label property and a Value property.  On the <code>View</code> there&#39;s a <code>Label</code> that binds to the Label property and a <code>TextBox</code> that binds to the Value property.</p><p>I then have a <code>ChangeValueView</code> which is a <code>DataTemplate</code> keyed off of the <code>ChangeValueViewModel</code> type.  Whenever WPF sees that <code>ViewModel</code> it applies that <code>View</code>.  The constructor of my <code>ChangeValueViewModel</code> takes the interaction logic it needs to refresh its state from the <code>EditModel</code> (usually just passing in a <code>Func&lt;string&gt;</code>) and the action it needs to take when the user edits the Value (just an <code>Action</code> that executes some logic in the <code>EditModel</code>).</p><p>The parent <code>ViewModel</code> (for the screen) takes an <code>EditModel</code> in its constructor and just instantiates the appropriate elementary <code>ViewModel</code>s such as <code>ChangeValueViewModel</code>.  Since the parent <code>ViewModel</code> is injecting the action to take when the user makes any change, it can intercept all of these actions and take other actions.  Therefore, the injected edit action for a <code>ChangeValueViewModel</code> might look like:</p><pre><code>(string newValue) =&gt;
{
    editModel.SomeField = newValue;
    foreach(var childViewModel in this.childViewModels)
    {
        childViewModel.RefreshStateFromEditModel();
    }
}
</code></pre><p>Obviously the <code>foreach</code> loop can be refactored elsewhere, but what this does is take the action, apply it to the model, then (assuming the model has updated its state in some unknown way), tells all the child <code>ViewModel</code>s to go and get their state from the model again.  If the state has changed, they are responsible for executing their <code>PropertyChanged</code> events, as necessary.</p><p>That handles the interaction between, say, a list box and a details panel quite nicely.  When the user selects a new choice, it updates the <code>EditModel</code> with the choice, and the <code>EditModel</code> changes the values of the properties exposed for the detail panel.  The <code>ViewModel</code> children that are responsible for displaying the detail panel information automatically get notified that they need to check for new values, and if they&#39;ve changed, they fire their <code>PropertyChanged</code> events.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-is-using-getters-in-xaml-view-models-a-bad-thing/'>C# &#8211; Is using getters in XAML view-models a bad thing</a></li><li class="list-group-item"><a href='../c-overall-view-validation-with-a-datagrid-and-keeping-to-mvvm/'>C# &#8211; Overall view validation with a datagrid and keeping to MVVM</a></li><li class="list-group-item"><a href='../architecture-clean-architecture-what-is-the-view-model/'>Architecture &#8211; Clean Architecture: What is the View Model</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>