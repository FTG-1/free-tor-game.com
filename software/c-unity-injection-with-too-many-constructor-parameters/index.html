<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C# &#8211; Unity injection with too many constructor parameters &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1069214 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1069214" class="post-1069214 software type-software status-publish hentry category-software tag-c tag-dependency-injection tag-service-locator"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C# &#8211; Unity injection with too many constructor parameters</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">dependency-injection</span><span class="mr-2 badge badge-warning">service-locator</span></p><div class="entry-content"><p>The question is about choosing the appropriate design for the scenario described below. This is a repost from <a href="https://stackoverflow.com/questions/51940180/unity-injection-with-too-many-constructor-parameters">https://stackoverflow.com/questions/51940180/unity-injection-with-too-many-constructor-parameters</a> where it was suggested to put the question here.</p><p>The question seems to cause a severe controversy even among some of the best-known C# gurus. In fact, it is far beyond C# and it falls more into pure computer science. The question is based on the well-known &#34;battle&#34; between a service locator pattern and pure dependency injection pattern: <a href="https://martinfowler.com/articles/injection.html" rel="nofollow noreferrer">https://martinfowler.com/articles/injection.html</a> vs <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/" rel="nofollow noreferrer">http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/</a> and a subsequent update to remedy the situation when the dependency injection becomes too complicated: <a href="http://blog.ploeh.dk/2010/02/02/RefactoringtoAggregateServices/" rel="nofollow noreferrer">http://blog.ploeh.dk/2010/02/02/RefactoringtoAggregateServices/</a></p><p>I read everything that I could find on the subject and even contacted several well-known C# gurus directly, but yet it is still unclear what would be the best choice.</p><p><strong>Development setup and requirements</strong></p><ol><li>We use Unity for DI / IOC. As such we never create classes directly and inject only interfaces through constructors.</li><li>We use Moq with <code>MockBehavior.Strict</code> for all unit tests to ensure that we always get expected behavior and no hidden surprises.</li><li>We use partial mock for integration tests where all external services are mocked in some way and all (or almost all) internal services are real.</li><li>We use a single composition root where all interfaces are registered.</li><li>We want to simplify the design and decrease the maintenance time / cost.</li></ol><p><strong>Business setup</strong></p><p>We have a large (50 – 100+) collection of &#34;rules&#34;, which I call micro services, because each rule is wrapped into a single service. If you have a better name, please &#34;apply&#34; it when reading. Each of them operates on a single object, let&#39;s call it quote. However, a tuple (context + quote) seems more appropriate. Quote is a business object, which gets processed and serialized into a database and context is some supporting information, which is necessary while quote is being processed, but is not saved into the database. Some of that supporting information may actually come from database or from some third-party services. This is irrelevant. Assembly line comes to mind as a real-world example: an assembly worker (micro service) receives some input (instruction (context) + parts (quote)), processes it (does something with parts according to instruction and / or modifies instruction) and passes it further if successful OR discards it (raises exception) in case of issues. The micro services eventually get bundled up into a small number (about 5) of high-level services. This approach linearizes processing of some very complex business object and allows testing each micro service separately from all others: just give it an input state and test that it produces expected output.</p><p>Here is where it gets interesting. Because of the number of steps involved, high-level services start to depend on many micro services: 10-15+ and more. This dependency is natural, and it just reflects the complexity of the underlying business object. On top of that micro services can be added / removed nearly on a constant basis: basically, they are some business rules, which are almost as fluid as water. Somebody may state that such high-level services violate Single Responsibility Principle. Well, if I have to apply, let’s say, 15+ &#34;rules&#34; in order to create a quote, then the implementation of <code>IQuoteCreateService.CreateQuote</code> has to apply all of them, while performing only a single task, creating quote!</p><p>That severely clashes with Mark&#39;s recommendation above: if I have 15+ effectively independent rules applied to a quote in some high-level service, then, according to the third blog, I should aggregate them into some logical groups of, let&#39;s say no more than 3-4 instead of injecting all 15+ via constructor. But there are no logical groups! While some of the rules are loosely dependent, most of them are not and so artificially bundling them together will do more harm than good.</p><p>Throw in that the rules change frequently, and it becomes a maintenance nightmare: all real / mocked calls must be updated every time the rules change.</p><p>And I have not even mentioned that the rules are US state dependent and so, in theory, there are about 50 collections of rules with one collection per each state and per each workflow. And while some of the rules are shared among all states (like &#34;save quote to the database&#34;), there are a lot of state specific rules.</p><p><strong>Here is a very simplified example.</strong></p><p>Quote &#8211; business object, which gets saved into database.</p><pre><code>public class Quote
{
    public string SomeQuoteData { get; set; }
    // ...
}
</code></pre><p>Micro services. Each of them performs some small update(s) to quote. Higher level services can be also built from some lower level micro services as well.</p><pre><code>public interface IService_1
{
    Quote DoSomething_1(Quote quote);
}
// ...

public interface IService_N
{
    Quote DoSomething_N(Quote quote);
}
</code></pre><p>All high-level and micro services inherit from this interface. It is convenient because the low-level implementation: <code>QuoteProcessor</code> provides some common tasks, like call for data validation, perform finalizer tasks (if necessary), etc&#8230; This is irrelevant to the question but explains why micro services also inherit from this interface.</p><pre><code>public interface IQuoteProcessor
{
    List&lt;Func&lt;Quote, Quote&gt;&gt; QuotePipeline { get; }
    Quote ProcessQuote(Quote quote = null);
}

// Low level quote processor. It does all workflow related work.
public abstract class QuoteProcessor : IQuoteProcessor
{
    public abstract List&lt;Func&lt;Quote, Quote&gt;&gt; QuotePipeline { get; }

    public Quote ProcessQuote(Quote quote = null)
    {
        // The real code performs Aggregate over QuotePipeline.
        // That applies each step from workflow to a quote.
        return quote;
    }
}
</code></pre><p>One of high level &#34;workflow&#34; services:</p><pre><code>public interface IQuoteCreateService
{
    Quote CreateQuote(Quote quote = null);
}
</code></pre><p>and its actual implementation where we use many of low level micro services.</p><pre><code>public class QuoteCreateService : QuoteProcessor, IQuoteCreateService
{
    protected IService_1 Service_1;
    // ...
    protected IService_N Service_N;

    public override List&lt;Func&lt;Quote, Quote&gt;&gt; QuotePipeline =&gt;
        new List&lt;Func&lt;Quote, Quote&gt;&gt;
        {
            Service_1.DoSomething_1,
            // ...
            Service_N.DoSomething_N
        };

    public Quote CreateQuote(Quote quote = null) =&gt; 
        ProcessQuote(quote);
}
</code></pre><p><strong>Issues</strong></p><p>There are two main ways to achieve DI:</p><p>Standard approach is to inject all dependencies through constructor:</p><pre><code>    public QuoteCreateService(
        IService_1 service_1,
        // ...
        IService_N service_N
        )
    {
        Service_1 = service_1;
        // ...
        Service_N = service_N;
    }
</code></pre><p>And then register all types with Unity:</p><pre><code>public static class UnityHelper
{
    public static void RegisterTypes(this IUnityContainer container)
    {
        container.RegisterType&lt;IService_1, Service_1&gt;(
            new ContainerControlledLifetimeManager());
        // ...
        container.RegisterType&lt;IService_N, Service_N&gt;(
            new ContainerControlledLifetimeManager());

        container.RegisterType&lt;IQuoteCreateService, QuoteCreateService&gt;(
            new ContainerControlledLifetimeManager());
    }
}
</code></pre><p>Then Unity will do its &#34;magic&#34; and resolve all services at run time. The problem is that currently we have about 50-100 such micro services and the number is expected to increase. Subsequently some of the constructors are already getting 10-15+ services injected. This is inconvenient to maintain, mock, etc&#8230;</p><p>Sure, it is possible to use the idea from here: <a href="http://blog.ploeh.dk/2010/02/02/RefactoringtoAggregateServices/" rel="nofollow noreferrer">http://blog.ploeh.dk/2010/02/02/RefactoringtoAggregateServices/</a> However, the micro services are not really related to each other and so bundling them together is an artificial process without any justification. In addition, it will also defeat the purpose of making the whole workflow linear and independent (a micro service takes a current &#34;state&#34;, then preforms some action with quote, and then just moves on). None of them cares about any other micro services before or after them.</p><p>An alternative idea seems to create a single &#34;service repository&#34; or service locator:</p><pre><code>public interface IServiceRepository
{
    IService_1 Service_1 { get; set; }
    // ...
    IService_N Service_N { get; set; }

    IQuoteCreateService QuoteCreateService { get; set; }
}

public class ServiceRepository : IServiceRepository
{
    protected IUnityContainer Container { get; }

    public ServiceRepository(IUnityContainer container)
    {
        Container = container;
    }

    private IService_1 _service_1;

    public IService_1 Service_1
    {
        get =&gt; _service_1 ?? (_service_1 = Container.Resolve&lt;IService_1&gt;());
        set =&gt; _service_1 = value;
    }
    // ...
}
</code></pre><p>Then register it with Unity and change the constructor of all relevant services to something like this:</p><pre><code>    public QuoteCreateService(IServiceRepository repo)
    {
        Service_1 = repo.Service_1;
        // ...
        Service_N = repo.Service_N;
    }
</code></pre><p>The benefits of this approach (in comparison to the previous one) are as follows:</p><p>All micro services and higher-level services can be created in a unified form: new micro services can be easily added / removed without the need to fix constructor call for the services and all unit tests. Subsequently, maintenance and complexity decreases.</p><p>Due to interface <code>IServiceRepository</code>, it is easy to create an automated unit test, which will iterate over all properties and validate that all services can be instantiated, which means that there will be no nasty run time surprises.</p><p>The problem with this approach is that it starts looking a lot like a service locator, which some people consider as an anti-pattern: <a href="http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/" rel="nofollow noreferrer">http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/</a> and then people start to argue that that all dependencies must be made explicit and not hidden as in <code>ServiceRepository</code>.</p><p>Yet a few more ideas were provided in the answers to the original question (in the link above). They all centered around the idea of using IEnumerable to pass as parameters array or as the collection of rules to be applied. I personally feel that using parameter array to pass services into constructor will do more harm than good due to the need for maintaining each constructor call in sync and without compiler to the rescue.</p><p><strong>Question</strong></p><p>I want to decrease complexity associated with injecting too many parameters through constructor. The rules (or parameters) are fairly independent, so I don&#39;t have a logical reasoning to bundle them up to decrease the number of parameters for the top class(es). From the other side, the business setup does require that many nearly independent rules must be applied at the level of the top business object(s) (quote, for example).</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>This piece of code caught my attention:</p><pre><code>public override List&lt;Func&lt;Quote, Quote&gt;&gt; QuotePipeline =&gt;
    new List&lt;Func&lt;Quote, Quote&gt;&gt;
    {
        Service_1.DoSomething_1,
        // ...
        Service_N.DoSomething_N
    };
</code></pre><p>The fact that you&#39;re taking a list of discrete elements and immediately putting them in a list suggests that there is an implicit business concept here that isn&#39;t embodied in a class. If it were me, I&#39;d have a class to represent the pipline and inject either the pipeline itself or a factory that will allow the caller to create one.</p><p>If you&#39;re writing a factory, it is &#34;OK&#34; to pass in the Unity Container itself, since dependency and lifespan management is part of a factory&#39;s single responsibility. This way you are getting the benefits of the service locator pattern without breaking the rules too badly for IoC.</p><p>When you need to unit test, you can just substitute a different pipeline factory that returns mocks.</p><p>So, first we define the pipeline:</p><pre><code>public class QuotePipeline : List&lt;Func&lt;Quote,Quote&gt;&gt;
{
    public Quote Execute(Quote quote)
    {
        foreach (var f in this) quote = f(quote);
        return quote;
    }
}
</code></pre><p>Now write a factory. Unity will always inject itself automatically if your class has IUnityContainer as a constructor argument.</p><pre><code>class QuotePipelineFactory : IQuotePipelineFactory
{
    protected readonly IUnityContainer _container;

    public QuotePipelineFactory(IUnityContainer container)
    {
        _container = container;
    }

    public QuotePipeline GetPipeline()
    {
        var p = new QuotePipeline();

        var d1 = _container.Resolve&lt;Service_1&gt;();
        p.Add( q =&gt; d1.DoSomething_1(q) );

        var d2 = _container.Resolve&lt;Service_2&gt;();
        p.Add( q =&gt; d2.DoSomething_2(q) );

        return p;
    }
}
</code></pre><p>Then inject the factory and retrieve the pipeline itself:</p><pre><code>public class QuoteCreateService : IQuoteProcessor
{
    protected readonly IQuotePipelineFactory _quotePipelineFactory;

    public QuoteCreateService(IQuotePipelineFactory quotePipelineFactory)
    {
        _quotePipelineFactory = quotePipelineFactory;
    }

    public Quote CreateQuote(Quote quote)
    {
        var p = _quotePipelineFactory.GetPipeline();
        return p.Execute(quote);
    }
}
</code></pre><p>Notice now there is only one dependency, and it can support any number of quote processors.</p><p>If your quote pipelines are always the same, you can of course store it as a single instance within the factory, which will be appropriately lifetime-scoped by Unity.</p><p>If the pipelines differ, you can always add input arguments to <code>GetPipeline()</code> and then possibly use a <a href="https://stackoverflow.com/questions/91932/how-does-the-strategy-pattern-work">strategy pattern</a> to pick and choose which processors to include in the pipeline.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-dependency-injection-with-adapter-pattern/'>C# Dependency Injection with Adapter Pattern</a></li><li class="list-group-item"><a href='../c-only-use-a-dependency-injection-container-at-the-root-of-an-application/'>C# &#8211; Only use a dependency injection container at the root of an application</a></li><li class="list-group-item"><a href='../c-service-locator-anti-pattern-alternative/'>C# &#8211; Service-locator anti-pattern alternative</a></li><li class="list-group-item"><a href='../c-dependency-injection-for-a-library-with-internal-dependencies/'>C# &#8211; Dependency injection for a library with internal dependencies</a></li><li class="list-group-item"><a href='../c-unity-dependency-injection-and-helper-functions/'>C# &#8211; Unity Dependency Injection and Helper functions</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>