<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Data structures and algorithms for a directed rooted tree with inherited properties &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1085463 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1085463" class="post-1085463 software type-software status-publish hentry category-software tag-algorithms tag-data-structures tag-graph tag-trees"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Data structures and algorithms for a directed rooted tree with inherited properties</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">algorithms</span><span class="mr-2 badge badge-info">data structures</span><span class="mr-2 badge badge-warning">graph</span><span class="mr-2 badge badge-primary">trees</span></p><div class="entry-content"><p>I need to represent a directed rooted tree in memory. The caveat is, that nodes have properties.</p><p>And those properties are inherited (but not 100%) by the child nodes, recursively.</p><p><strong>What would be a good data structure and algorithms for storing this in memory?</strong></p><p><strong>For the purposes of notation:</strong></p><ul><li>D(V) &#8211; depth of the vertex (distance from the root).</li><li>A(V) &#8211; arity of the vertex (how many children it has).</li><li>V &#8211; Size of the tree (how many total vertices)</li><li>P &#8211; average # of properties inherited by a vertex.</li></ul><hr/><p><strong>The operations that need to be supported (efficiently) are:</strong></p><ul><li><p>Modifying the tree (add node/subtree; remove node/subtree, move node/subtree)</p><p>Tree modifications occur not too frequently, perhaps 1-3% of the tree changes throughout the day.</p></li><li><p>Change (add/delete/modify) a property on a node, and have all its descendents inherit that property according to inheritance rules:</p><ul><li><p>a property is inherited by default.</p></li><li><p>A property itself has 2 attributes: &#34;propagate&#34; and &#34;turned off&#34;.</p></li><li><p>A property is inherited from parent to child if (and only if): Parent node&#39;s property has &#34;propagate&#34; flag on AND the child node does NOT have the same property set with &#34;turned off&#34; attribute.</p></li></ul></li><li><p>Query out properties of a given node (this is a very frequent query, massively dominating other access patterns by frequency)</p></li><li><p><strong>Efficiently</strong> query out properties of a set of nodes</p><p>This means that, if we query out properties of N nodes sharing same parent, at depth D, the complexity would be O((N+D)<em>P) instead of O(D</em>N*P)</p><p>This query is frequent but significantly less so than the single-node one. BUT, the problem is that it would frequently be run on the entire tree or a very large portion of it, and the bulk speedup matters due to V being very large.</p></li><li><p><strong>Efficiently</strong> query out all nodes (in whole tree or given subtree) that have a specific property (either set directly or inherited) that is not turned off.</p><p>This means that it should be much faster than O(V*P).</p><p>Access pattern: less frequent than the other two, BUT needs to be very fast because it&#39;s called by user-facing UI and thus for user experience purposes needs to be responsive.</p></li></ul><hr/><p>I have tried implementing 3 approaches, but all of them suffer from different issues due to the seemingly irreconcilable trade-offs:</p><ol><li><p><strong>Approach 1:</strong></p><ul><li><p>Store the tree as a regular tree (possibly with enhancements to speed things up, such as doubly-linked edges to facilitate walking up the tree, and a hashtable to be able to find a given node in the tree in O(1).</p></li><li><p>Store properties with the nodes they are set on</p></li><li><p>Compute the properties inherited by nodes, by walking UP the tree from the node to find the path from root to the node, then walking back down that path and seeing which properties would propagate from root to child, then to grandchild&#8230; and so on till the node.</p></li><li><p><strong>PROBLEM:</strong> Computing properties on a set of nodes is slow. Dumb implementation results in O(P<em>D</em>N) although I have a feeling this can be improved.</p></li><li><p><strong>PROBLEM:</strong> Finding out which nodes inherit a specific property in the whole tree is VERY slow and I don&#39;t see a good way to optimize it.</p><p>This implementation results in O(V*P) complexity, which is unacceptable.</p></li></ul><hr/></li><li><p><strong>Approach 2:</strong></p><ul><li><p>Store the tree as a regular tree (possibly with enhancements to speed things up, such as doubly-linked edges to facilitate walking up the tree, and a hashtable to be able to find a given node in the tree in O(1).</p></li><li><p>Store properties with the nodes they are set on, AND separately store (cache) the inherited properties of each node.</p></li><li><p>This solution makes finding properties inherited by a node O(P) and a set of nodes O(P*N) very efficient.</p></li><li><p><strong>PROBLEM:</strong> Tree manipulation is slow. Basically, you need to re-compute O(P<em>D + P</em>N) (where D is a depth of a node where change occurred and N is amount of nodes being added/moved)</p></li><li><p><strong>PROBLEM:</strong> Finding out which nodes inherit a specific property in the whole tree is VERY slow and I don&#39;t see a good way to optimize it.</p><p>This implementation results in O(V*P) complexity, where P is average # of properties <strong>inherited</strong> on a node and V is # of vertices on the whole tree.</p></li></ul><hr/></li><li><p><strong>Approach 3:</strong></p><ul><li><p>Store the tree as a regular tree (possibly with enhancements to speed things up, such as doubly-linked edges to facilitate walking up the tree, and a hashtable to be able to find a given node in the tree in O(1).</p></li><li><p>Store properties with the nodes they are set on, AND separately store (cache) the inherited properties of each node.</p></li><li><p>Also, have a separate cache linking properties to a list of nodes they are inherited in (call it &#34;property cache&#34;).</p></li><li><p>This solution makes finding properties inherited by a node O(P) and a set of nodes O(P*N) very efficient.</p></li><li><p><strong>PROBLEM:</strong> Tree manipulation is <strong>extremely</strong> slow. Basically, you need to re-compute O(P<em>D + P</em>N) (where D is a depth of a node where change occurred and N is amount of nodes being added/moved) AND then also spend time refreshing properties cache that can also be O(P*N) since you have to rebuild entire cache.</p></li><li><p><strong>PROBLEM:</strong> Changing properties is also very slow because you also need to rebuild the entire properties cache for a changed property.</p></li></ul></li></ol></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>A regular tree would suit just fine and <strong>Approach 1</strong> would work here. I think you should also read up a bit about the search algorithms used for a B-tree and then see how you could modify it here.</p><p>To me, this question is basically about how to modify a generalized B-Tree to handle properties with a propagation element.</p><p>Like you say:</p><ul><li><em>Store the tree as a regular tree.</em></li><li><em>Store properties with the nodes they are set on.</em></li></ul><p>But:</p><ul><li><p><strong>Don&#39;t double link them</strong> - You can walk down the tree during the search (and also unfold if necessary revisiting the parent node when using typical recursive methods).</p></li><li><p><strong>Don&#39;t create a hash-table</strong> - a hash-table is just another look-up data-structure, why use it when you can modify the tree!</p></li><li><p><strong>DON&#39;T DO THIS:</strong> <em>Compute the properties inherited by nodes, by walking UP the tree</em> ...</p></li><li><p><strong>INSTEAD DO THIS:</strong> Store the properties as you walk through the tree locating the target node. You have to visit them anyway. During the node traversal search just pass through the property if &#39;propagate&#39; is on. When at the child node; don&#39;t save it if the property also exists there and is set to &#39;turned off&#39;. Keep traversing until you reach your target node, storing the properties as you go (perhaps in some simple little list).</p></li><li><p>Note that the property attributes requirements for &#39;propagate&#39; and &#39;turned off&#39; only impact the search algorithm by requiring logic to be placed in the traversal method.</p></li></ul><p><strong>PROBLEM 1:</strong> <em>Computing properties on a set of nodes is slow. Dumb implementation results in O(PDN) although I have a feeling this can be improved.</em></p><ul><li><p><strong>SOLUTION:</strong> This is full of assumptions. What is a set? I only can assume a simple case like; set of nodes are all of the direct children of their parent node &amp; depth of 1. Given this; Locate the parent node first with all the properties saved up until that parent node (as we just discussed in the previous point). Then for each child of that node you calculate out the properties - so for each child you have all the saved properties up to that parent node + the child&#39;s properties.</p></li><li><p><strong>EXAMPLE:</strong> Traverse from the root node to a target node. For each node get the properties where they are &#39;propagated&#39; and then traverse the next node passing through those properties. For the next node; for each property passed through check they are in the current node, if they are present and are &#39;turned on&#39; then overwrite the property with the current nodes value. Then do the &#39;propagation&#39; check and redo going through the nodes until the target node. Then you are left with the children - apply the same attribute logic and record the properties for each node.</p></li></ul><p><strong>PROBLEM 2:</strong> <em>Finding out which nodes inherit a specific property in the whole tree is VERY slow and I don&#39;t see a good way to optimize it.</em></p><ul><li><p><strong>SOLUTION:</strong> Here, you want to search for this efficiently but the creation of your tree solution doesn&#39;t have to be so efficient. And it&#39;s not too complex because you just need to find if it is &#39;turned off&#39; or not - and not involve the &#39;propagate&#39; property. What you need to do here is use the tree as it is supposed to be used. If a property is not &#39;turned off&#39; you want to say to the parent node that a child of theirs has a specific property and then update all the way back up to the root node. This way if a property doesn&#39;t exist at all you&#39;ll know straight away when visiting the root node that it doesn&#39;t exist.</p></li><li><p><strong>EXAMPLE:</strong> Given a child node is set with a new property and &#39;turned on&#39;; update the parent node with the same property and set to &#39;turned off&#39; and use this to say the property exists in one of the nodes children. Then for each parent above that parent, set the same property and attribute. Now start to traverse from the root node the property will be set on the root node indicating that a descendant has that property. Do a traversal search and go through each child where the property is set - store each node where the property is &#39;turned on&#39;.</p></li></ul><p>Hopefully I can improve on this answer. Help me by indicating hard to understand parts of my answer.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-what-data-structure-could-i-use-for-modeling-a-network-of-nodes-and-edges/'>C++ &#8211; What data structure could I use for modeling a network of nodes and edges</a></li><li class="list-group-item"><a href='../difference-between-sibling-lists-left-child-right-sibling-binary-tree-and-doubly-chained-tree/'>Difference between sibling lists, left-child right-sibling binary tree and doubly-chained tree</a></li><li class="list-group-item"><a href='../does-a-tree-node-have-an-ancestor/'>Does a tree node have an ancestor</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>