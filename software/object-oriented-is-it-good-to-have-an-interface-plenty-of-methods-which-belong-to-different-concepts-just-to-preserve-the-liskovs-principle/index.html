<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Is it good to have an interface plenty of methods which belong to different concepts, just to preserve the Liskov&#8217;s Principle &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1086772 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1086772" class="post-1086772 software type-software status-publish hentry category-software tag-liskov-substitution tag-object-oriented tag-object-oriented-design tag-single-responsibility tag-solid"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Is it good to have an interface plenty of methods which belong to different concepts, just to preserve the Liskov&#8217;s Principle</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">liskov-substitution</span><span class="mr-2 badge badge-info">object-oriented</span><span class="mr-2 badge badge-warning">object-oriented-design</span><span class="mr-2 badge badge-primary">single-responsibility</span><span class="mr-2 badge badge-danger">solid</span></p><div class="entry-content"><p>I&#39;m currently studying a course based on Software Design and I had a discussion in class with my professor and some classmates about a problem represented by the next scenario:</p><p><strong>Scenario</strong></p><blockquote><p><em>Imagine we have a graphic application which lets us plan the interior design of our future house using a perspective from top. We are able<br /> to add or remove some elements like furniture and change their<br /> position, but obviously, we can&#39;t move the walls of the house because<br /> it was already built.</em></p></blockquote><p><strong>Solution 1</strong></p><p>To solve this problem, some of my classmates proposed a solution that could be expressed using the following UML diagram:</p><p><img src="../../../i.stack.imgur.com/nV7Ne.jpg" alt="UML diagram for Solution 1"/></p><p>As you can see, they agreed on the use of a common interface called &#34;Drawable&#34; which represents the graphical objects displayed on the UI. The general class &#34;App&#34; manages a list of Drawables, and each of them has a set of methods. This interface is implemented by different classes such as Furniture, Wall or Window. The thing is that a Furniture object could be moved, but not the Walls nor the Windows. So, a Furniture would implement the &#39;move&#39; method defined in Drawable. In contrast, Wall and Window simply will write it empty.</p><p>At this point, other classmates and I complained about this decission because the design does not require to fulfill with the constraints (like moving or not Drawable objects, depending on their nature). This way, the design will allow some new objects could be moved, although they probably shouldn&#39;t be. However, the professor said this design is good because it&#39;s flexible and transparent for the App class, because this class doesn&#39;t know what kind of instance is managing.</p><p><em>Extended case</em></p><p>In addition, we could think on an extreme case where we add several methods to the Drawable interface, such as &#39;sell&#39;, &#39;open&#39; and &#39;lend&#39;. Using the same approach described above, we will have an interface which could be able to do anything, like Superman. Therefore, I believe this is a bad design solution due to we are mixing behaviors which belong to different concepts (Movable, Sellable, Openable, and so on). Also, we are allowing a Wall object could implement the &#39;sell&#39; method, which completely does not make sense&#8230; but my professor still insisted on his point of view and he didn&#39;t see the problem.</p><p><strong>Solution 2 (based on the extended case)</strong></p><p>Other people suggested we could add those interfaces (Movable, Sellable, Openable) and each of them would inherit from the Drawable interface. That way:</p><ul><li>A Wall would implement Drawable directly</li><li>A Furniture would implement Movable and Sellable</li><li>A Window would implement just Openable</li></ul><p>The next diagram summarizes this approach:</p><p><img src="../../../i.stack.imgur.com/xvqVi.jpg" alt="UML Diagram for Solution 2"/></p><p>[Edit: The Drawable&#39;s move method should be removed, this is a mistake because it is now placed into the Movable interface]</p><p><strong>Questions and Doubts</strong></p><p>Finally, once you can figure out the problem, could you help me and answer these questions, please?</p><ol><li><p>Aren&#39;t we breaking the <em>Single Responsibility Principle</em> with this super-mega-god-interface?</p></li><li><p>Are both approaches valid against the <em>Liskov&#39;s Substitution Principle</em>? I think it&#39;s broken in the first case because the post-conditions are broken due to some methods don&#39;t do anything. Anyway, in the second approach I&#39;m not sure as well because of the interfaces inheritance tree</p></li><li><p>Maybe, another alternative could be the definition of basic Drawable objects (with &#39;click&#39; and &#39;draw&#39; methods). Thus, we may take advantage of some kind of mechanism like the Decorator pattern in order to add behaviors dynamically. But how?</p></li><li><p>If we use a language without interfaces such as JavaScript or Python, how can we deal with this problem?</p></li></ol></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>Aren&#39;t we breaking the Single Responsibility Principle with this super-mega-god-interface?</p></blockquote><p>Not exactly, because the interface isn&#39;t doing anything. It has no responsibilities.</p><p>You are breaking <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a> and <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle">Interface Segregation Principle</a> though.</p><p>LSP because you&#39;re writing methods that do nothing, just to make it fit the interface (ie. What is true of IDrawable -- that you can move it -- is not true of Wall).</p><p>ISP because you&#39;ll have situations like a trade method, which should have access to Buy and Sell methods, but will also have access to Draw.</p><blockquote><p>Are both approaches valid against the Liskov&#39;s Substitution Principle? I think it&#39;s broken in the first case because the post-conditions are broken due to some methods don&#39;t do anything. Anyway, in the second approach I&#39;m not sure as well because of the interfaces inheritance tree</p></blockquote><p>It&#39;s just as broken in the second case as the first.</p><p>Edit: On second thoughts, it isn&#39;t. But it is still broken. It doesn&#39;t seem automatically true that everything that could have a Move method will also have a Draw method. It might be true in your case but, if you later find yourself wanting to pass an object with a Move method into a method that receives an IMovable, you&#39;re going to have to implement Draw on that object, even if you don&#39;t need it.</p><p>And it gains you nothing over a third solution ...</p><blockquote><p>Maybe, another alternative could be the definition of basic Drawable objects (with &#39;click&#39; and &#39;draw&#39; methods). Thus, we may take advantage of some kind of mechanism like the Decorator pattern in order to add behaviors dynamically. But how?</p></blockquote><p>The best alternative is to segregate your interfaces fully. You can still have objects with lots of methods (but <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency-Inversion Principle</a> and <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a> dictate you must push the logic down into services), but they only have to implement the interfaces they need. Wall shouldn&#39;t implement IMovable, if it can&#39;t be moved.</p><pre><code>public class Wall : IDrawable
public class Furniture : IDrawable, IMovable, ISellable
public class Window : IDrawable, IOpenable
</code></pre><p>Nothing here dictates that any of those interfaces must derive from another.</p><pre><code>public interface IDrawable
{
    void Draw(Canvas canvas);
}

public interface IMovable
{
    void MoveTo(int x, int y);
}

etc
</code></pre><p>You should then manage your list of IDrawables, which you can only be sure implement Draw(), and cast to see if other methods are available.</p><p>For example,</p><pre><code>ITradable tradable = drawable as ITradable;
if (tradable != null)
{
    tradable.Trade(buyer, seller);
}
</code></pre><p>You&#39;re going to have to do the above in your option 2 anyway, so why tie everything to IDrawable?</p><blockquote><p>If we use a language without interfaces such as JavaScript or Python, how can we deal with this problem?</p></blockquote><p>OO languages tend to support at least one of three things:</p><ul><li>Interfaces (use ... interfaces)</li><li><a href="https://en.wikipedia.org/wiki/Multiple_inheritance">Multiple inheritance</a> (use abstract classes)</li><li><a href="https://en.wikipedia.org/wiki/Dynamic_programming_language">Dynamic types</a> (use duck-typing; this is where Python comes in)</li></ul><p><a href="https://en.wikipedia.org/wiki/Prototype-based_programming">Prototypical languages</a>, such as Javascript, support ... well, prototypes, which allow for a slightly modified version of <a href="https://en.wikipedia.org/wiki/Duck_typing">duck-typing</a> (in prototypes, you generally ask if a method exists before calling it).</p><p>Other paradigms generally handle these issues in their own way.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../object-oriented-xerox-solid-example-in-php/'>Object-oriented &#8211; Xerox SOLID example in PHP</a></li><li class="list-group-item"><a href='../two-contradicting-definitions-of-interface-segregation-principle-which-one-is-correct/'>Two contradicting definitions of Interface Segregation Principle – which one is correct</a></li><li class="list-group-item"><a href='../c-clean-oop-design-how-to-implement-single-responsibility-and-no-procedural-programming/'>C# &#8211; Clean OOP-Design: How to implement single responsibility and no procedural programming</a></li><li class="list-group-item"><a href='../object-oriented-stack-extending-linkedlist-a-violation-of-liskov-substitution-principle/'>Object-oriented &#8211; Stack extending LinkedList. A violation of Liskov Substitution Principle</a></li><li class="list-group-item"><a href='../object-oriented-solid-does-liskov-substitution-principle-lsp-conflict-with-the-interface-segregation-principle-isp/'>Object-oriented &#8211; SOLID, Does Liskov Substitution Principle (LSP) conflict with the Interface Segregation Principle (ISP)</a></li><li class="list-group-item"><a href='../object-oriented-which-object-should-have-the-method/'>Object-oriented &#8211; Which object should have the method</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>