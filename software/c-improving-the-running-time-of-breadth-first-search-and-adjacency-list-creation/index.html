<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++ &#8211; Improving the running time of Breadth First Search and Adjacency List creation &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1087132 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1087132" class="post-1087132 software type-software status-publish hentry category-software tag-array tag-c tag-graph tag-graph-traversal"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++ &#8211; Improving the running time of Breadth First Search and Adjacency List creation</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">array</span><span class="mr-2 badge badge-info">c</span><span class="mr-2 badge badge-warning">graph</span><span class="mr-2 badge badge-primary">graph-traversal</span></p><div class="entry-content"><p>We are given an array of integers where all elements are between 0-9. have to start from the 1st position and reach end in minimum no of moves such that we can from an index i move 1 position back and forward i.e i-1 and i+1 and jump to any index having the same value as index i.<br /> <br /> Time Limit : 1 second<br /> <br /> Max input size : 100000</p><p>I have tried to solve this problem use a single source shortest path approach using Breadth First Search and though BFS itself is O(V+E) and runs in time the adjacency list creation takes O(n2) time and therefore overall complexity becomes O(n2). is there any way i can decrease the time complexity of adjacency list creation? or is there a better and more efficient way of solving the problem?</p><pre><code>int main(){

    vector&lt;int&gt; v;
    string str;
    vector&lt;int&gt; sets[10];

    cin&gt;&gt;str;
    int in;
    for(int i=0;i&lt;str.length();i++){
        in=str[i]-&#39;0&#39;;
        v.push_back(in);
        sets[in].push_back(i);
    }

    int n=v.size();
    if(n==1){
        cout&lt;&lt;&#34;0\n&#34;;
        return 0;
    }
    if(v[0]==v[n-1]){
        cout&lt;&lt;&#34;1\n&#34;;
        return 0;
    }


    vector&lt;int&gt; adj[100001];
    for(int i=0;i&lt;10;i++){
        for(int j=0;j&lt;sets[i].size();j++){
            if(sets[i][j]&gt;0)
                adj[sets[i][j]].push_back(sets[i][j]-1);
            if(sets[i][j]&lt;n-1)  
                adj[sets[i][j]].push_back(sets[i][j]+1);
            for(int k=j+1;k&lt;sets[i].size();k++){
                if(abs(sets[i][j]-sets[i][k])!=1){
                    adj[sets[i][j]].push_back(sets[i][k]);
                    adj[sets[i][k]].push_back(sets[i][j]);
                }
            }
        }
    }

    queue&lt;int&gt; q;
    q.push(0);

    int dist[100001];
    bool visited[100001]={false};
    dist[0]=0;
    visited[0]=true;

    int c=0;
    while(!q.empty()){
        int dq=q.front();
        q.pop();
        c++;

        for(int i=0;i&lt;adj[dq].size();i++){
            if(visited[adj[dq][i]]==false){
                dist[adj[dq][i]]=dist[dq]+1;
                visited[adj[dq][i]]=true;
                q.push(adj[dq][i]);
            }
        }

    }

    cout&lt;&lt;dist[n-1]&lt;&lt;&#34;\n&#34;;

    return 0;
}
</code></pre></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Key insight: there&#39;s no need to eagerly construct the adjacency list.  In fact, there&#39;s no need to ever construct the adjacency list; you just need a way to find the next nodes.  With this insight, we can construct an efficient version of the search.</p><h2>Lazy edges</h2><p>For any given node, finding indices i+1 and i-1 is trivial.  Finding nodes that have the same value merely requires a lookup in the <code>sets</code> datastructure you&#39;ve already created.</p><p>The rest of your breadth first search still applies equally; you mark off nodes you&#39;ve already seen to make sure you don&#39;t revisit them.</p><h2>Grouped values</h2><p>Note that there&#39;s really no reason to return to a value once you&#39;ve left it.  Any path that reaches an X-valued index can reach any other X-valued index on the next step.  That means your maximum path is 19 (each value can occur at most twice for a 20 nodes i.e. 19 edges along the path).</p><p>However, it it also means you don&#39;t want the following to occur:</p><ul><li>you&#39;re at index K with value X, and iterate over all other indices with value X, marking them as visited, and <em>adding them to the queue</em></li><li>you eventually reach each one of those X-valued indices in the queue, and iterate over everything it can reach, i.e. all those other X&#39;s - even though they&#39;ve all been visited, and you already know you&#39;re not going to add them to the queue.</li></ul><p>So you&#39;re doing quadratic work (each instance of a value iterates over each instance of the same value) and it&#39;s obviously pointless to boot.  Once you process an X-valued index and thus visit all other X&#39;s, you <em>know</em> you&#39;ll never need to follow an X-&gt;X edge again.  Easy fix? Just empty the list of indices by that value once you&#39;ve processed one.</p><p>This new algorithm is linear time:</p><ul><li>reading the input is linear</li><li>building <code>sets</code> is linear (each index is inserted once)</li><li>each index can be &#34;processed&#34; (added to the queue) at most once, so that&#39;s linear.</li><li>each index can be &#34;visited&#34; (checking the visited array) at most three times: once by i-1, once by 1+1, and once by some other identically valued index.</li></ul><p>If you really want, you can possibly shave off a bit of the constant factor here.  After all, the final path will pass through each value once (and when it does, touching one or two indexes for that value).  You can therefore construct a much, much smaller graph of how <em>values</em> can reach each other; solving that for the shortest paths is essentially free (at most 10 nodes, after all), and a shortest path through the indexes must be the shortest path through the values (proof left to reader, but note that any shortcut via i+1/i-1 costs at least a step, but can never win more than a step).  Then, when you solve the bigger graph of indices, you don&#39;t need to bother taking any steps that conflict with what you already know of the solution; i.e. don&#39;t enqueue any indices that have a value other than your own or the &#34;next&#34; value along any shortest path in the value graph. (In essence, this optimization is A*).</p><p>Similarly, you could segment your queue by value and distance, and skip processing the rest of the current value with greater distance once you&#39;ve found a way to the next.</p><p>Such trickery is almost certainly not worth it, but hey, it&#39;s possible :-).</p><hr/><p><strong>Coding Style:</strong> I&#39;d suggest naming your variables after what they represent.  Your code is a little hard to follow because it contains things like <code>sets</code> (of what? why? - oh it&#39;s a way to lookup indices having a value), and a queue <code>q</code> (again, what&#39;s this mean? oh it&#39;s the reachable set in order of distance).  Give meaningful concepts (that you repeat in the code) like <code>adj[dq][i]</code> a name.  It&#39;s the neighbor you&#39;re going to visit.  This algorithm is so simple, it&#39;s eventually clear, but there&#39;s no reason it shouldn&#39;t be clear right away.</p><hr/><p><strong>TL;DR</strong></p><ul><li>Don&#39;t precompute edges, instead compute reachability when needed.</li><li>Empty the set of indices you use to compute value-to-value reachability after using it once to avoid quadratic behavior.</li><li>The result is O(N).</li></ul></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-teaching-c-to-first-time-high-school-students-where-to-draw-the-line/'>C++ &#8211; Teaching C++ to first time high school students: Where to draw the line</a></li><li class="list-group-item"><a href='../c-how-to-effectively-manage-long-term-feature-development-and-short-term-bug-fixing-at-the-same-time/'>C++ &#8211; How to effectively manage long-term feature development and short-term bug fixing at the same time</a></li><li class="list-group-item"><a href='../breadth-first-graph-search-problem/'>Breadth-first graph search problem</a></li><li class="list-group-item"><a href='../c-running-a-process-multiple-times-at-the-same-time/'>C++ &#8211; Running a process multiple times at the same time</a></li><li class="list-group-item"><a href='../how-an-add-vertex-operation-could-be-performed-in-constant-time-for-a-graph-represented-using-adjacency-list/'>How an add vertex operation could be performed in constant time for a graph represented using adjacency list</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>