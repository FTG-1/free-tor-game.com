<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Should I use a parser generator or should I roll the own custom lexer and parser code &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1064162 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1064162" class="post-1064162 software type-software status-publish hentry category-software tag-compiler tag-language-design tag-parsing"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Should I use a parser generator or should I roll the own custom lexer and parser code</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">compiler</span><span class="mr-2 badge badge-info">language-design</span><span class="mr-2 badge badge-warning">parsing</span></p><div class="entry-content"><p>What <strong>specific</strong> advantages and disadvantages of each way to working on a programming language grammar?</p><p>Why/When should I roll my own? Why/When should I use a generator?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>There are three options really, all three of them preferable in different situations.</p><h3>Option 1: parser generators, or &#39;you need to parse some language and you just want to get it working, dammit&#39;</h3><p>Say, you&#39;re asked to build a parser for some ancient data format NOW. Or you need your parser to be fast. Or you need your parser to be easily maintainable.</p><p>In these cases, you&#39;re probably best off using a parser generator. You don&#39;t have to fiddle around with the details, you don&#39;t have to get lots of complicated code to work properly, you just write out the grammar the input will adhere to, write some handling code and presto: instant parser.</p><p>The advantages are clear:</p><ul><li>It&#39;s (usually) quite easy to write a specification, in particular if the input format isn&#39;t too weird (option 2 would be better if it is).</li><li>You end up with a very easily maintainable piece of work that is easily understood: a grammar definition usually flows a lot more natural than code.</li><li>The parsers generated by good parser generators are usually a lot faster than hand-written code. Hand-written code <em>can</em> be faster, but only if you know your stuff - this is why most widely used compilers use a hand-written recursive-descent parser.</li></ul><p>There&#39;s one thing you have to be careful of with parser-generators: the can sometimes reject your grammars. For an overview of the different types of parsers and how they can bite you, you may want to start <a href="https://cstheory.stackexchange.com/questions/2399/what-is-the-most-powerful-kind-of-parser/2401#2401">here</a>. <a href="http://en.wikipedia.org/wiki/Comparison_of_parser_generators" rel="noreferrer">Here</a> you can find an overview of a lot of implementations and the types of grammars they accept.</p><h3>Option 2: hand-written parsers, or &#39;you want to build your own parser, and you care about being user-friendly&#39;</h3><p>Parser generators are nice, but they aren&#39;t very user (the end-user, not you) friendly. You typically can&#39;t give good error messages, nor can you provide error recovery. Perhaps your language is very weird and parsers reject your grammar or you need more control than the generator gives you.</p><p>In these cases, using a hand-written recursive-descent parser is probably the best. While getting it right may be complicated, you have complete control over your parser so you can do all kinds of nice stuff you can&#39;t do with parser generators, like error messages and even error recovery (try removing all the semicolons from a C# file: the C# compiler will complain, but will detect most other errors anyway regardless of the presence of semicolons).</p><p>Hand-written parsers also usually perform better than generated ones, assuming the quality of the parser is high enough. On the other hand, if you don&#39;t manage to write a good parser - usually due to (a combination of) lack of experience, knowledge or design - then performance is usually slower. For lexers the opposite is true though: generally generated lexers use table lookups, making them faster than (most) hand-written ones.</p><p>Education-wise, writing your own parser will teach you more than using a generator. You have to write more and more complicated code after all, plus you have to understand exactly how you parse a language. On the other hand, if you want to learn how to create your own language (so, get experience at language design), either option 1 or option 3 is preferable: if you&#39;re developing a language, it will probably change a lot, and option 1 and 3 give you an easier time with that.</p><h3>Option 3: hand written parser generators, or &#39;you&#39;re trying to learn a lot from this project and you wouldn&#39;t mind ending up with a nifty piece of code you can re-use a lot&#39;</h3><p>This is the path I&#39;m currently walking down: you write <em>your own</em> parser generator. While highly nontrivial, doing this will probably teach you the most.</p><p>To give you an idea what doing a project like this involves I&#39;ll tell you about my own progress.</p><p><strong>The lexer generator</strong></p><p>I created my own lexer generator first. I usually design software starting with how the code will be used, so I thought about how I wanted to be able to use my code and wrote this piece of code (it&#39;s in C#):</p><pre><code>Lexer&lt;CalculatorToken&gt; calculatorLexer = new Lexer&lt;CalculatorToken&gt;(
    new List&lt;StringTokenPair&gt;()
    { // This is just like a lex specification:
      //                    regex   token
        new StringTokenPair(&#34;\\+&#34;,  CalculatorToken.Plus),
        new StringTokenPair(&#34;\\*&#34;,  CalculatorToken.Times),
        new StringTokenPair(&#34;(&#34;,    CalculatorToken.LeftParenthesis),
        new StringTokenPair(&#34;)&#34;,    CalculatorToken.RightParenthesis),
        new StringTokenPair(&#34;\\d+&#34;, CalculatorToken.Number),
    });

foreach (CalculatorToken token in
             calculatorLexer.GetLexer(new StringReader(&#34;15+4*10&#34;)))
{ // This will iterate over all tokens in the string.
    Console.WriteLine(token.Value);
}

// Prints:
// 15
// +
// 4
// *
// 10
</code></pre><p>The input string-token pairs are converted into a corresponding recursive structure describing the regular expressions they represent using the ideas of an arithmetic stack. This is then converted into a NFA (nondeterministic finite automaton), which is in turn converted into a DFA (deterministic finite automaton). You can then match strings against the DFA.</p><p>This way, you get a good idea how exactly lexers work. In addition, if you do it the right way the results from your lexer generator can be roughly as fast as professional implementations. You also don&#39;t lose any expressiveness compared to option 2, and not much expressiveness compared to option 1.</p><p>I implemented my lexer generator in just over 1600 lines of code. This code makes the above work, but it still generates the lexer on the fly every time you start the program: I&#39;m going to add code to write it to disk at some point.</p><p>If you want to know how to write your own lexer, <a href="https://stackoverflow.com/questions/1084069/building-a-regex-engine-online-resources">this</a> is a good place to start.</p><p><strong>The parser generator</strong></p><p>You then write your parser generator. I refer to <a href="https://cstheory.stackexchange.com/questions/2399/what-is-the-most-powerful-kind-of-parser/2401#2401">here</a> again for an overview on the different kinds of parsers - as a rule of thumb, the more they can parse, the slower they are.</p><p>Speed not being an issue for me, I chose to implement an Earley parser. Advanced implementations of an Earley parser <a href="http://webhome.cs.uvic.ca/~nigelh/Publications/PracticalEarleyParsing.pdf" rel="noreferrer">have been shown</a> to be about twice as slow as other parser types.</p><p>In return for that speed hit, you get the ability to parse <em><strong>any</strong></em> kind of grammar, even ambiguous ones. This means you never need to worry about whether your parser has any left-recursion in it, or what a shift-reduce conflict is. You can also define grammars more easily using ambiguous grammars if it doesn&#39;t matter which parse tree is the result, such as that it doesn&#39;t matter whether you parse 1+2+3 as (1+2)+3 or as 1+(2+3).</p><p>This is what a piece of code using my parser generator can look like:</p><pre><code>Lexer&lt;CalculatorToken&gt; calculatorLexer = new Lexer&lt;CalculatorToken&gt;(
    new List&lt;StringTokenPair&gt;()
    {
        new StringTokenPair(&#34;\\+&#34;,  CalculatorToken.Plus),
        new StringTokenPair(&#34;\\*&#34;,  CalculatorToken.Times),
        new StringTokenPair(&#34;(&#34;,    CalculatorToken.LeftParenthesis),
        new StringTokenPair(&#34;)&#34;,    CalculatorToken.RightParenthesis),
        new StringTokenPair(&#34;\\d+&#34;, CalculatorToken.Number),
    });

Grammar&lt;IntWrapper, CalculatorToken&gt; calculator
    = new Grammar&lt;IntWrapper, CalculatorToken&gt;(calculatorLexer);

// Declaring the nonterminals.
INonTerminal&lt;IntWrapper&gt; expr = calculator.AddNonTerminal&lt;IntWrapper&gt;();
INonTerminal&lt;IntWrapper&gt; term = calculator.AddNonTerminal&lt;IntWrapper&gt;();
INonTerminal&lt;IntWrapper&gt; factor = calculator.AddNonTerminal&lt;IntWrapper&gt;();

// expr will be our head nonterminal.
calculator.SetAsMainNonTerminal(expr);

// expr: term | expr Plus term;
calculator.AddProduction(expr, term.GetDefault());
calculator.AddProduction(expr,
                         expr.GetDefault(),
                         CalculatorToken.Plus.GetDefault(),
                         term.AddCode(
                         (x, r) =&gt; { x.Result.Value += r.Value; return x; }
                         ));

// term: factor | term Times factor;
calculator.AddProduction(term, factor.GetDefault());
calculator.AddProduction(term,
                         term.GetDefault(),
                         CalculatorToken.Times.GetDefault(),
                         factor.AddCode
                         (
                         (x, r) =&gt; { x.Result.Value *= r.Value; return x; }
                         ));

// factor: LeftParenthesis expr RightParenthesis
//         | Number;
calculator.AddProduction(factor,
                         CalculatorToken.LeftParenthesis.GetDefault(),
                         expr.GetDefault(),
                         CalculatorToken.RightParenthesis.GetDefault());
calculator.AddProduction(factor,
                         CalculatorToken.Number.AddCode
                         (
                         (x, s) =&gt; { x.Result = new IntWrapper(int.Parse(s));
                                     return x; }
                         ));

IntWrapper result = calculator.Parse(&#34;15+4*10&#34;);
// result == 55
</code></pre><p>(Note that IntWrapper is simply an Int32, except that C# requires it to be a class, hence I had to introduce a wrapper class)</p><p>I hope you see that the code above is very powerful: any grammar you can come up with can be parsed. You can add arbitrary bits of code in the grammar capable of performing lots of tasks. If you manage to get this all working, you can re-use the resulting code to do a lot of tasks very easily: just imagine building a command-line interpreter using this piece of code.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-programming-language-parser-in-java-what-would-be-a-better-design-alternative-for-a-special-case/'>Java &#8211; Programming Language Parser (in Java) &#8211; What would be a better design alternative for a special case</a></li><li class="list-group-item"><a href='../xml-based-programming-languages/'>Xml based programming languages</a></li><li class="list-group-item"><a href='../should-i-use-a-source-to-source-or-a-traditional-compiler-in-order-to-develop-the-own-programming-language/'>Should I use a source-to-source or a traditional compiler in order to develop the own Programming Language</a></li><li class="list-group-item"><a href='../when-to-use-a-parser-combinator-when-to-use-a-parser-generator/'>When to use a Parser Combinator? When to use a Parser Generator</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>