<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Understanding how variable assignment works &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1078998 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1078998" class="post-1078998 software type-software status-publish hentry category-software tag-c tag-memory-usage"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Understanding how variable assignment works</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">memory usage</span></p><div class="entry-content"><p>When I started learning C programming a few years ago, my tutor taught me similar to most of the tutors around the world. She said me the very basic things like any int datatype is of 2 bytes memory. If the following is my code,</p><pre><code>#include&#34;stdio.h&#34;
#include&#34;conio.h&#34;
void main()
{
    clrscr();
    int i,n;
    n = 0;
    for(i=0;i&lt;3;i++)
        n = n + i;
    printf(&#34;%d&#34;,n); //obviously it prints 3
    getch();
}
</code></pre><p>she will explain like what I have written below. Here my teacher starts off her class yet again. . .</p><blockquote><p>Listen students. Here we have two integer values. So let us draw two boxes each of 2 bytes memory.The first box be the memory space of <strong>i</strong> and the second box be that of <strong>n</strong>. At <code>n = 0;</code> 0 gets stored into the box n. As the control gets into the loop, 0 gets stored into the box i intially.</p><p><kbd>0</kbd> <kbd>0</kbd></p><p>Now the condition is checked. i &lt; 3. Condition gets true. So now the value of n changes from 0 to n+i i.e., 0+0=0. The first iteration then ends after the increment statement. Now i gets incremented to 1. So our picture becomes like this.</p><p><kbd>1</kbd> <kbd>0</kbd></p><p>And now i &lt; 3 again. Condtion gets true. n changes from 0 to n + i i.e., 0+1=1. Don&#39;t forget the increment my dears. Only then our iteration gets completed. i++ makes our i to 2 now. And the picture will now look like</p><p><kbd>2</kbd> <kbd>1</kbd></p></blockquote><p>She will go on similarly step by step and will complete when both the boxes get 3, 3 values.</p><blockquote><p>So thats it kids. After we get our boxes like this</p><p><kbd>3</kbd> <kbd>3</kbd></p><p>the value of n gets printed on the screen.</p><p><strong>3</strong></p></blockquote><p>By that time, I was merely like a kid nodding its head when a teacher claims earth as a  circular mass. I never asked her any questions. I felt logically she was perfect. But now I am plentiful of queries. If there is a statement like <code>n = n + i;</code>, won&#39;t there be a conflict as both the destination space and the operation space is the same n box? Will the operations be done with the help of any default temporary space for calculations? What will happen if I use a recursive code like the following snippet.</p><pre><code>int factorial(int n)
{
    if(n &lt; 2)
    {
        return n;
    }
    else
    {
        n = n * factorial(n - 1);
        return n;
    }
}
</code></pre><p>How could it be possible to use a single n box as my tutor taught? Won&#39;t a new n box be created whenever <code>factorial(n - 1)</code> is called? If I am right, how could the computer know which n box value to be returned? Somebody help me please. I am pulling of hairs from ma head!</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>How could it be possible to use a single n box as my tutor taught? Won&#39;t a new n box be created whenever factorial(n - 1) is called?</p></blockquote><p>Yes, exactly.  Each time you call a function, additional memory is set aside for the function arguments and local variables.</p><p>Let&#39;s drop a couple of levels below C and talk about how a compiled program is laid out in memory<sup>1</sup>.  We&#39;re going to assume a 32-bit, x86-like system for this discussion.</p><p>While the details vary from platform to platform, the general concepts are the same for most systems you&#39;re likely to work on.  When a compiled program is loaded into memory, it&#39;s usually divided up into several logical <em>segments</em>; one segment contains the machine code, another contains constant (read-only) data items, another contains space for non-constant, global data items, another contains space for the stack, another contains the space for the heap, etc.  The general layout looks something like the following (taken from <a href="http://cs-fundamentals.com/c-programming/memory-layout-of-c-program-code-data-segments.php" rel="nofollow">this page</a>):</p><pre><code>              +------------------------+ 
high address  | Command line arguments |   
              | and environment vars   |  
              +------------------------+
              |         stack          |
              | - - - - - - - - - - -  |
              |           |            |
              |           V            |
              |                        |
              |           ^            |
              |           |            |
              | - - - - - - - - - - -  |
              |          heap          |
              +------------------------+
              |    global and read-    |
              |       only data        |
              +------------------------+
 low address  |     program text       |
              |    (machine code)      |
              +------------------------+      
</code></pre><p>As your program runs, it uses the stack to store function arguments and local variables, along with some program state (previous frame pointer, address to the next instruction).  On x86-like systems, the stack grows &#34;downwards&#34;, towards decreasing addresses.  Among the registers<sup>2</sup> provided, there are usually two to keep track of what&#39;s on the stack.  There&#39;s the <em>stack pointer</em>, which points to the most recent item on the stack, and the <em>frame pointer</em><sup>3</sup>, which points to the current <em>stack frame</em>.  A stack frame is a region of the stack that contains the arguments and local variables for the current function, along with any saved program state:</p><pre><code>             + - - - - - - - - -  +
high address |  previous stack    |
             |       frame        |
             + - - - - - - - - -  +
             |  previous stack    |
             |       frame        |
             +--------------------+  ----------------------+
             | function arguments |                        |
             |        ...         |                        |
             +--------------------+                        |
             |   return address   |                        |
             +--------------------+                        +-- current stack frame
             | old frame pointer  | &lt;-- frame pointer      |
             +--------------------+                        |
             |  local variables   |                        |
             |        ...         | &lt;-- stack pointer      |
             +--------------------+ -----------------------+  
 low address |  available memory  |       
             + - - - - - - - - -  +  
</code></pre><p>On the systems I&#39;m familiar with, the function arguments and program state are stored &#34;above&#34; the location stored in the frame pointer, and local variables are stored &#34;below&#34; it.  Within the generated assembly code, arguments and variables are referred to by their offset from the address stored in the frame pointer.  On x86. it would look something like</p><pre><code>cmpl  $1, 8(%ebp)   ;; compare the literal value 1 to the first function argument
movl  $1, -4(%ebp)  ;; write the literal value 1 to the first local variable
</code></pre><p>The first function argument is stored 8 bytes &#34;above&#34; the address value stored in the frame pointer <code>%ebp</code>, while the first local variable would be 4 bytes &#34;below&#34; it (note that this assumes a 32-bit system).</p><p>The exact size of the frame depends on how many arguments and local variables need to be stored, although the platform may also require it to be aligned to certain boundary (IOW, the size of the frame must be a multiple of some number of bytes, usually 4 or 8, sometimes 16; for the purposes of this discussion, we&#39;re not going to worry about alignment).</p><p>Suppose your <code>factorial</code> function is called with an argument value of 3:</p><pre><code>x = factorial( 3 );
</code></pre><p>A new stack frame will be set up that looks something like this:</p><pre><code> +--------------------+
 |         3          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | &lt;-- frame pointer, stack pointer
 +--------------------+
</code></pre><p>where the &#34;return address&#34; is the address of the instruction immediately following the function call in the caller (in this case, it would be the instruction that assigns the result of <code>factorial(3)</code> to <code>x</code>).</p><p>Since there are no local variables, no space is allocated for them in the stack frame.  Now, since <code>n</code> is not less than 2, you execute the line</p><pre><code>n = n * factorial( n - 1 );
</code></pre><p>This means <code>factorial</code> is called again, this time with an argument value of 2.  A new stack frame is created</p><pre><code> +--------------------+
 |         3          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | 
 +--------------------+
 |         2          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | &lt;-- frame pointer, stack pointer
 +--------------------+
</code></pre><p><code>n</code> is still not less than 2, so we call <code>factorial</code> again with an argument of 1:</p><pre><code> +--------------------+
 |         3          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | 
 +--------------------+
 |         2          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | 
 +--------------------+
 |         1          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | &lt;-- frame pointer, stack pointer
 +--------------------+
</code></pre><p><code>1</code> <em>is</em> less than 2, so we execute the line</p><pre><code>return n;  
</code></pre><p>The common convention for returning values from functions is to write the value to a particular register.  On x86, integer values are returned through register <code>%eax</code>, so the compiled code will do something like</p><pre><code>movl  8(%ebp), %eax
</code></pre><p>Now register <code>%eax</code> will contain the value <code>1</code>.</p><p>When the function returns, the stack and frame pointers are restored to their previous values (the stack <em>contents</em> are left as-is):</p><pre><code> +--------------------+
 |         3          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | 
 +--------------------+
 |         2          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | &lt;-- frame pointer, stack pointer
 +--------------------+
 |         1          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | 
 +--------------------+
</code></pre><p>So now we need to execute the remainder of</p><pre><code>n = n * factorial( n - 1 );  
</code></pre><p>which will look something like<sup>4</sup></p><pre><code>movl %eax, %edx     ;; save the value returned from factorial(1) to register %edx
movl 8(%ebp), %eax  ;; move the value of n (2) to %eax
imull %eax, %edx    ;; multiply the values in %eax and %edx, save the result in
                    ;; %eax
</code></pre><p>Once again, we return <code>n</code> and exit the function, bringing us back to the previous call:</p><pre><code> +--------------------+
 |         3          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | &lt;-- frame pointer, stack pointer
 +--------------------+
 |         2          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | 
 +--------------------+
 |         1          | &lt;-- n
 +--------------------+
 |   return address   |
 +--------------------+
 |  old frame pointer | 
 +--------------------+
</code></pre><p>Lather, rinse, repeat.  The value returned in <code>%eax</code> (<code>2</code>) is multiplied by the value in the argument <code>8(%ebp)</code> (<code>3</code>), and we write <code>6</code> back to <code>%eax</code>.</p><p>Now, the C language definition says <em>nothing</em> about stacks, or stack frames, or registers, or anything like that; it only specifies the <em>behavior</em> of variables within a program, not how to implement that behavior.  However, much of C&#39;s design is based on what most computer systems already provide (this is what people mean when they say that C is &#34;close to the hardware&#34;), so this is a very natural way of implementing that behavior.  If you were working on a machine that had no stack, C programs would be somewhat more difficult to implement.</p><p></p><hr/> <sup> 1.  By which I mean a <em>virtual address space</em>, which is an idealized model of memory that your program sees; the OS and memory controllers will map this idealized model to physical RAM.<br/><br/> 2.  A register is a memory cell on the CPU itself.  There are usually several special-purpose registers (program counter, stack pointer, frame pointer) and some number of general-purpose registers.  Reading and writing to registers is faster than reading and writing to RAM.<br/><br/> 3.  On 32-bit x86, the stack pointer register is <code>esp</code> and the frame pointer register is <code>ebp</code> (a.k.a. the base pointer).  On 64-bit x86, they&#39;re named <code>rsp</code> and <code>rbp</code>.<br/><br/> 4.  This is how the compiled code on my system does it, anyway. </sup><p></p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../implementing-non-fixed-length-array-support-in-a-compiler/'>Implementing non-fixed length array support in a compiler</a></li><li class="list-group-item"><a href='../structure-of-stack-of-a-function-call/'>Structure of stack of a function call</a></li><li class="list-group-item"><a href='../memory-allocation-in-c-while-calling-function/'>Memory allocation in C while calling function</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>