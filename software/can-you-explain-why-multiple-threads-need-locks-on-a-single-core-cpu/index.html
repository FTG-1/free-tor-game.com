<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="https://free-tor-game.com/wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Can you explain why multiple threads need locks on a single-core CPU &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js?ver=11.2.0' id='highlight-js'></script>     <script>( function( w, d, s, l, i ) {
				w[l] = w[l] || [];
				w[l].push( {'gtm.start': new Date().getTime(), event: 'gtm.js'} );
				var f = d.getElementsByTagName( s )[0],
					j = d.createElement( s ), dl = l != 'dataLayer' ? '&l=' + l : '';
				j.async = true;
				j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
				f.parentNode.insertBefore( j, f );
			} )( window, document, 'script', 'dataLayer', ' ' );</script>      <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1065810 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="https://free-tor-game.com/3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="https://free-tor-game.com/contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1065810" class="post-1065810 software type-software status-publish hentry category-software tag-multithreading"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Can you explain why multiple threads need locks on a single-core CPU</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">multithreading</span></p><div class="entry-content"><p>Assume these threads run in single core cpu. As a cpu only run one instruction in one cycle. That is said, even thought they share the cpu resource. but the computer ensure that one time one instruction. So is the lock un-necessary for multiplethreading?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>This is best illustrated with an example.</p><p>Suppose we have a simple task that we want to perform multiple times in parallel, and we want to keep track globally of the number of times that the task has been performed, for example, counting hits on a web page.</p><p>When each thread gets to the point at which it&#39;s incrementing the count, its execution will look like this:</p><ol><li>Read the number of hits from memory into a processor register</li><li>Increment that number.</li><li>Write that number back to memory</li></ol><p>Remember that every thread can suspend at any point in this process. So if thread A performs step 1, and then gets suspended, following by thread B performing all three steps, when thread A resumes, its registers will have the wrong number of hits: its registers will be restored, it will happily increment the old number of hits, and store that incremented number.</p><p>In addition, any number of other threads could have run during the time that thread A was suspended, so the count thread A writes at the end might be well below the correct count.</p><p>For that reason, it&#39;s necessary to ensure that if a thread performs step 1, it must perform step 3 before any other thread is allowed to perform step 1, which can be accomplished by all threads waiting to get a single lock before they begin this process, and freeing the lock only after the process is complete, so that this &#34;critical section&#34; of code cannot be incorrectly interleaved, resulting in a wrong count.</p><p><strong>But what if the operation were atomic?</strong></p><p>Yes, in the land of magical unicorns and rainbows, where the increment operation is atomic, then locking would not be necessary for the above example.</p><p>It&#39;s important to realize, however, that we spend very little time in the world of magical unicorns and rainbows. In almost every programming language, the increment operation is broken down into the above three steps. That&#39;s because, even if the processor supports an atomic increment operation, that operation is significantly more expensive: it has to read from memory, modify the number, and write it back to memory...and usually the atomic increment operation is an operation that can fail, meaning the simple sequence above has to be replaced with a loop (as we&#39;ll see below).</p><p>Since, even in multithreaded code, many variables are kept local to a single thread, programs are much more efficient if they assume each variable is local to a single thread, and let the programmers take care of protecting shared state between threads. Especially given that atomic operations are not usually enough to solve threading issues, as we&#39;ll see later.</p><p><strong>Volatile variables</strong></p><p>If we wanted to avoid locks for this particular problem, we first have to realize that the steps depicted in our first example aren&#39;t actually what happens in modern compiled code. Because compilers assume only one thread is modifying the variable, each thread will keep its own cached copy of the variable, until the processor register is needed for something else. As long as it has the cached copy, it assumes it doesn&#39;t need to go back to memory and read it again (which would be expensive). They also won&#39;t write the variable back to memory as long as it&#39;s kept in a register.</p><p>We can get back to the situation we gave in the first example (with all the same threading problems we identified above) by marking the variable as <strong>volatile</strong>, which tells the compiler that this variable is being modified by others, and so must be read from or written to memory whenever it&#39;s accessed or modified.</p><p>So a variable marked as volatile will not take us to the land of atomic increment operations, it only gets us as close as we thought we were already.</p><p><strong>Making the increment atomic</strong></p><p>Once we&#39;re using a volatile variable, we can make our increment operation atomic by using a low-level conditional set operation that most modern CPUs support (often called compare and set or <a href="http://en.wikipedia.org/wiki/Compare-and-swap">compare and swap</a>). This approach is taken, for example, in Java&#39;s <a href="http://www.docjar.com/html/api/java/util/concurrent/atomic/AtomicInteger.java.html">AtomicInteger</a> class:</p><pre><code>197       /**
198        * Atomically increments by one the current value.
199        *
200        * @return the updated value
201        */
202       public final int incrementAndGet() {
203           for (;;) {
204               int current = get();
205               int next = current + 1;
206               if (compareAndSet(current, next))
207                   return next;
208           }
209       }
</code></pre><p>The above loop repeatedly performs the following steps, until step 3 succeeds:</p><ol><li>Read the value of a volatile variable directly from memory.</li><li>Increment that value.</li><li>Change the value (in main memory) if and only if its current value in main memory is the same as the value we initially read, using a special atomic operation.</li></ol><p>If step 3 fails (because the value was changed by a different thread after step 1), it again reads the variable directly from main memory and tries again.</p><p>While the compare-and-swap operation is expensive, it&#39;s slightly better than using locking in this case, because if a thread is suspended after step 1, other threads that reach step 1 do not have to block and wait for the first thread, which can prevent costly context switching. When the first thread resumes, it will fail in its first attempt to write the variable, but will be able to continue by re-reading the variable, which again is likely less expensive than the context switch that would have been necessary with locking.</p><p>So, we can get to the land of atomic increments (or other operations on a single variable) without using actual locks, via compare and swap.</p><p><strong>So when is locking strictly necessary?</strong></p><p>If you need to modify more than one variable in an atomic operation, then locking will be necessary, you won&#39;t find a special processor instruction for that.</p><p>As long as you&#39;re working on a single variable, and you&#39;re prepared for whatever work you&#39;ve done to fail and to have to read the variable and start over again, compare-and-swap will be good enough, however.</p><p>Let&#39;s consider an example where each thread first adds 2 to a the variable X, and then multiplies X by two.</p><p>If X is initially one, and two threads run, we expect the result to be (((1 + 2) * 2) + 2) * 2 = 16.</p><p>However, if the threads interleave, we could, even with all operations being atomic, instead have both additions occur first, and the multiplications come after, resulting in (1 + 2 + 2) * 2 * 2 = 20.</p><p>This happens because multiplication and addition are not commutative operations.</p><p>So, the operations themselves being atomic is not enough, we must make the combination of operations atomic.</p><p>We can do that either by using locking to serialize the process, or we could use one local variable to store the value of X when we started our calculation, a second local variable for the intermediate steps, and then use compare-and-swap to set a new value only if the current value of X is the same as the original value of X. If we fail, we would have to start over again by reading X and performing the calculations again.</p><p>There are several trade-offs involved: as the calculations become longer, it becomes much more likely that the running thread will be suspended, and the value will be modified by another thread before we resume, meaning failures become much more likely, leading to wasted processor time. In the extreme case of large numbers of threads with very long running calculations, we might have 100 threads read the variable and be engaged in calculations, in which case only the first to finish will succeed in writing the new value, the other 99 will still complete their calculations, but discover upon completion that they can&#39;t update the value...at which point they&#39;ll each read the value and start the calculation over. We&#39;d likely have the remaining 99 threads repeat the same problem, wasting vast quantities of processor time.</p><p>Full serialization of the critical section via locks would be much better in that situation: 99 threads would suspend when they didn&#39;t get the lock, and we&#39;d run each thread in order of arrival at the locking point.</p><p>If serialization is not critical (as in our incrementing case), and the calculations that would be lost if updating the number fails are minimal, there may be a significant advantage to be gained from using the compare-and-swap operation, because that operation is less expensive than locking.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='https://free-tor-game.com/software/when-would-you-need-hundreds-of-thousands-of-threads/'>When would you need &#8220;hundreds of thousands&#8221; of threads</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/should-multi-threading-be-used-for-tasks-which-does-not-involve-io-operation/'>Should multi-threading be used for tasks which does not involve IO operation</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/context-switching-behavior/'>Context Switching behavior</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/why-would-a-program-require-a-specific-minimum-number-of-cpu-cores/'>Why would a program require a specific minimum number of CPU cores</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/java-performance-of-sharing-single-object-with-multiple-threads-in-java/'>Java &#8211; Performance of sharing single object with multiple threads in Java</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/how-does-a-single-thread-run-on-multiple-cores/'>How does a single thread run on multiple cores</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/c-one-process-using-stdthread-2-physical-cpus-4-cores-each-parallelism-level/'>C++ &#8211; One process using std::thread, 2 physical CPUs, 4 cores each, parallelism level</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='http://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="https://free-tor-game.com/wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>