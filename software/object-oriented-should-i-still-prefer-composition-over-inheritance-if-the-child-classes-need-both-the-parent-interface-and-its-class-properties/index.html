<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Should I still prefer composition over inheritance if the child classes need BOTH the parent interface AND its class properties &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1084112 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1084112" class="post-1084112 software type-software status-publish hentry category-software tag-coding-style tag-composition tag-inheritance tag-object-oriented"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Should I still prefer composition over inheritance if the child classes need BOTH the parent interface AND its class properties</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">coding-style</span><span class="mr-2 badge badge-info">composition</span><span class="mr-2 badge badge-warning">inheritance</span><span class="mr-2 badge badge-primary">object-oriented</span></p><div class="entry-content"><p>According to <a href="https://softwareengineering.stackexchange.com/questions/134097/why-should-i-prefer-composition-over-inheritance">Why should I prefer composition over inheritance?</a>, I should prefer composition over inheritance. But what if I need to access the interface and class member in generic way? For example, I have parent class Shape and some child classes:</p><pre><code>public class Shape{
    private String customId;
    public String getCustomId(){
        return customId;
    }
    public void setCustomId(String aCustomId){
        customId=aCustomId;
    }

    public abstract void draw();
}

public class Circle extends Shape{
    @Override
    public void draw(){
    }
} 
</code></pre><p>Some codes to use Shape interface</p><pre><code>for(Shape s : shapeArray){
    s.draw();
    //access customId
    if(s.getCustomId().equals(...)){
    }
}

...

public class User{
    private Shape shape;
    public void printInfo(){
        System.out.println(&#34;User Shape id:&#34;+shape.getCustomId());
    }
}
</code></pre><p>But it is violating composition over inheritance, so I change the inheritance to composition+interface:</p><pre><code>public interface Shape{
    String getCustomId();
    void setCustomId(String aCustomId);
    void draw();
}

public class Circle implements Shape{
    private String customId;
    public String getCustomId(){
        return customId;
    }
    public void setCustomId(String aCustomId){
        customId=aCustomId;
    }

    public void draw(){
    }
}
</code></pre><p>I found composition is more unmaintainable in this case because:</p><ol><li><p>when I add a new class, I need to copy and paste</p><pre><code>private String customId;
public String getCustomId(){
    return customId;
}
public void setCustomId(String aCustomId){
    customId=aCustomId;
}
</code></pre></li><li><p>If I need to add a new child class member to Shape, I also need to edit all child class to add the class member as well as getter and setter into it</p></li></ol><p>So my question is, do I need &#34;composition over inheritance&#34; if I need to access both the class member and methods in generic way?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>&#34;prefer composition over inheritance&#34; is not a braindead rule saying one should avoid inheritance under all circumstances - that would miss the point of that recommendation, and would be nothing but a form of <a href="https://en.wikipedia.org/wiki/Cargo_cult_programming" rel="nofollow noreferrer">cargo-cult programming</a>.</p><p>What the rule actually means is: using inheritance just for <strong>reusage</strong> is most often the wrong tool - especially when equivalent reusage can be achieved by composition. Same holds when there are parts inherited which are just needed <em>sometimes</em>, or have to be changed at runtime. However, for polymorphism, using inheritance is fine.</p><p>In your example, if each <code>Circle</code> <strong>is</strong> a <code>Shape</code> with a polymorphic <code>draw</code> method, then using inheritance is a perfectly valid option for this part of the class model. If in your specific context each kind of <code>Shape</code> object <strong>always, always, always</strong> needs an <code>Id</code>, with no exception, then putting the related implementation into the <code>Shape</code> base class is at least a pragmatic solution, not perfect, but still ok.</p><p>The situation changes if one needs sometimes shapes with an Id, and <strong>sometimes not</strong>, making the Id part of the base class implementation is quite questionable:</p><ul><li><p>It restricts the reusability and maintainability of the <code>Shape</code> class, because it violates the single responsibility principle - now the <code>Shape</code> has two different responsibilities: providing a generic <code>draw</code> interface <em>and</em> providing identifyability through an Id.</p></li><li><p>Moreover, the <code>setCustomId</code> makes a <code>Shape</code> mutable, which imposes also certain usage restrictions.</p></li><li><p>And as a minor drawback, each <code>Shape</code> object will allocate a small memory block for an additional string reference, required or not.</p></li></ul><p>So if one wants to create a highly reusable shape class, I would heavily recommend to remove the Id part from the <code>Shape</code> completely, and introduce another class like a <code>TaggedShape</code>, which is composed of an Id and a shape:</p><pre><code> class TaggedShape
 {
     private Shape shape;
     private String customId;
     // ... add some public getters and maybe setters for shape and customId here ...
     public TaggedShape(Shape s, String id)
     {
          shape=s;
          customId=id;
     }

     public Shape getShape(){return shape;}

     public void draw(){shape.draw();}
 }
</code></pre><p>Now, use the <code>TaggedShape</code> whereever you need shapes with an Id in your program, and a standard <code>Shape</code> whereever you don&#39;t require an ID. And whereever you need a <code>TaggedShape</code> as a <code>Shape</code>, use <code>taggedShape.getShape()</code>.</p><p>As you see, this solution does not force you to implement the same ID code for each new derived class of <code>Shape</code>. It uses <strong>composition</strong> for the ID part, and <strong>inheritance</strong> for the <code>draw</code> part. So each new Shape derivation can be combined with the ID, or not, without any necessity to implement some ID interface again. And the <code>Shape</code> class has only &#34;one reason to change&#34; - when the drawing rules change, that&#39;s all. If ID part needs to be changed, the <code>Shape</code> class hierarchy is not directly affected any more.</p><p>As a final note: in this example, the <code>draw</code> method is purely abstract, so <code>Shape</code> could also be an interface. But all I wrote above stays the same even if there would be some implementation inheritance involved, as long as it belongs to the &#34;drawing responsibility&#34;. For example, <code>draw</code> migh not be abstract, but provides an overridable default implementation in <code>Shape</code>. That is still a valid use case for inheritance.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../prefer-composition-over-inheritance/'>Prefer composition over inheritance</a></li><li class="list-group-item"><a href='../object-oriented-inheritance-using-non-abstract-base-class/'>Object-oriented &#8211; Inheritance using non-abstract base class</a></li><li class="list-group-item"><a href='../object-oriented-prefer-composition-over-inheritance-is-the-only-reason-to-defend-against-signature-changes/'>Object-oriented &#8211; &#8220;Prefer composition over inheritance&#8221; &#8211; Is the only reason to defend against signature changes</a></li><li class="list-group-item"><a href='../is-composition-over-inheritance-violating-dry-principle/'>Is &#8220;composition over inheritance&#8221; violating &#8220;dry principle&#8221;</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>