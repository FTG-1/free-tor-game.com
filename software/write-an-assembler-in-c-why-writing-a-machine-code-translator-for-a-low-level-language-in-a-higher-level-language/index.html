<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>&#8220;Write an Assembler in C.&#8221; Why writing a machine code translator for a low level language in a higher level language &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1064166 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1064166" class="post-1064166 software type-software status-publish hentry category-software tag-assembly tag-c tag-compiler tag-machine-code"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">&#8220;Write an Assembler in C.&#8221; Why writing a machine code translator for a low level language in a higher level language</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">assembly</span><span class="mr-2 badge badge-info">c</span><span class="mr-2 badge badge-warning">compiler</span><span class="mr-2 badge badge-primary">machine-code</span></p><div class="entry-content"><p>My Microprocessor class instructor gave us an assignment and said:</p><blockquote><p><em>&#34;Write an Assembler in C.&#34;</em> &#8211; My beloved Professor</p></blockquote><p>So it seemed a little bit illogical to me.</p><p>If I&#39;m not wrong Assembly Language is the first step from Machine Code to the journey of higher level languages. I mean C is higher level language than Assembly. So what is the point of writing an Assembler in C? What were they doing in the past while the absence of C language? Were they writing Assembler in Machine Code?</p><p>It doesn&#39;t make sense to me writing a machine code translator for a low level language in a higher level language.</p><p>Let&#39;s say we have created a brand new microprocessor architecture that there is not even a C compiler for that architecture. Will our Assembler that written in C be able simulate the new architecture? I mean will it be useless or not?</p><p>By the way I&#39;m aware that GNU Assembler and Netwide Assembler have been written in C. I am also wondering why they are written in C?</p><p>Lastly this is the example source code for a simple assembler that our Professor gave to us:</p><pre><code>// to compile, gcc assembler.c -o assembler
// No error check is provided.
// Variable names cannot start with 0-9.
// hexadecimals are twos complement.
// first address of the code section is zero, data section follows the code section.
//fout tables are formed: jump table, ldi table, label table and variable table.

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


//Converts a hexadecimal string to integer.
int hex2int( char* hex)  
{
    int result=0;

    while ((*hex)!=&#39;\0&#39;)
    {
        if ((&#39;0&#39;&lt;=(*hex))&amp;&amp;((*hex)&lt;=&#39;9&#39;))
            result = result*16 + (*hex) -&#39;0&#39;;
        else if ((&#39;a&#39;&lt;=(*hex))&amp;&amp;((*hex)&lt;=&#39;f&#39;))
            result = result*16 + (*hex) -&#39;a&#39;+10;
        else if ((&#39;A&#39;&lt;=(*hex))&amp;&amp;((*hex)&lt;=&#39;F&#39;))
            result = result*16 + (*hex) -&#39;A&#39;+10; 
        hex++;
    }
    return(result);
}


main()
{   
    FILE *fp;
        char line[100];
        char *token = NULL;
    char *op1, *op2, *op3, *label;
    char ch;
    int  chch;

    int program[1000];
    int counter=0;  //holds the address of the machine code instruction




// A label is a symbol which mark a location in a program. In the example 
// program above, the string &#34;lpp&#34;, &#34;loop&#34; and &#34;lp1&#34; are labels.
    struct label  
    {
        int location;
        char *label;
    };
    struct label labeltable[50]; //there can be 50 labels at most in our programs
    int nooflabels = 0; //number of labels encountered during assembly.




// Jump instructions cannot be assembled readily because we may not know the value of 
// the label when we encountered a jump instruction. This happens if the label used by
// that jump instruction appear below that jump instruction. This is the situation 
// with the label &#34;loop&#34; in the example program above. Hence, the location of jump 
// instructions must be stored.
    struct jumpinstruction   
    {
        int location;
        char *label;
    };
    struct jumpinstruction jumptable[100]; //There can be at most 100 jumps
    int noofjumps=0;  //number of jumps encountered during assembly.    




// The list of variables in .data section and their locations.
    struct variable
    {
        int location;
        char *name;
    };
    struct variable variabletable[50]; //There can be 50 varables at most.
    int noofvariables = 0;




//Variables and labels are used by ldi instructions.
//The memory for the variables are traditionally allocated at the end of the code section.
//Hence their addresses are not known when we assemble a ldi instruction. Also, the value of 
//a label may not be known when we encounter a ldi instruction which uses that label.
//Hence, the location of the ldi instructions must be kept, and these instructions must be 
//modified when we discover the address of the label or variable that it uses.
    struct ldiinstruction   
    {
        int location;
        char *name;
    };
    struct ldiinstruction lditable[100];
    int noofldis=0;




    fp = fopen(&#34;name_of_program&#34;,&#34;r&#34;);

    if (fp != NULL)
    {
        while(fgets(line,sizeof line,fp)!= NULL)  //skip till .code section
        {
            token=strtok(line,&#34;\n\t\r &#34;);
            if (strcmp(token,&#34;.code&#34;)==0 )
                break;
        } 
        while(fgets(line,sizeof line,fp)!= NULL)
        {
            token=strtok(line,&#34;\n\t\r &#34;);  //get the instruction mnemonic or label

//========================================   FIRST PASS  ======================================================
            while (token)
            {
                if (strcmp(token,&#34;ldi&#34;)==0)        //---------------LDI INSTRUCTION--------------------
                {
                    op1 = strtok(NULL,&#34;\n\t\r &#34;);                                //get the 1st operand of ldi, which is the register that ldi loads
                    op2 = strtok(NULL,&#34;\n\t\r &#34;);                                //get the 2nd operand of ldi, which is the data that is to be loaded
                    program[counter]=0x1000+hex2int(op1);                        //generate the first 16-bit of the ldi instruction
                    counter++;                                                   //move to the second 16-bit of the ldi instruction
                    if ((op2[0]==&#39;0&#39;)&amp;&amp;(op2[1]==&#39;x&#39;))                            //if the 2nd operand is twos complement hexadecimal
                        program[counter]=hex2int(op2+2)&amp;0xffff;              //convert it to integer and form the second 16-bit 
                    else if ((  (op2[0])==&#39;-&#39;) || ((op2[0]&gt;=&#39;0&#39;)&amp;&amp;(op2[0]&lt;=&#39;9&#39;)))       //if the 2nd operand is decimal 
                        program[counter]=atoi(op2)&amp;0xffff;                         //convert it to integer and form the second 16-bit 
                    else                                                           //if the second operand is not decimal or hexadecimal, it is a laber or a variable.
                    {                                                               //in this case, the 2nd 16-bits of the ldi instruction cannot be generated.
                        lditable[noofldis].location = counter;                 //record the location of this 2nd 16-bit  
                        op1=(char*)malloc(sizeof(op2));                         //and the name of the label/variable that it must contain
                        strcpy(op1,op2);                                        //in the lditable array.
                        lditable[noofldis].name = op1;
                        noofldis++;                                             
                    }       
                    counter++;                                                     //skip to the next memory location 
                }                                       

                else if (strcmp(token,&#34;ld&#34;)==0)      //------------LD INSTRUCTION---------------------         
                {
                    op1 = strtok(NULL,&#34;\n\t\r &#34;);                //get the 1st operand of ld, which is the destination register
                    op2 = strtok(NULL,&#34;\n\t\r &#34;);                //get the 2nd operand of ld, which is the source register
                    ch = (op1[0]-48)| ((op2[0]-48) &lt;&lt; 3);        //form bits 11-0 of machine code. 48 is ASCII value of &#39;0&#39;
                    program[counter]=0x2000+((ch)&amp;0x00ff);       //form the instruction and write it to memory
                    counter++;                                   //skip to the next empty location in memory
                }
                else if (strcmp(token,&#34;st&#34;)==0) //-------------ST INSTRUCTION--------------------
                {
                    //to be added
                }
                else if (strcmp(token,&#34;jz&#34;)==0) //------------- CONDITIONAL JUMP ------------------
                {
                    //to be added
                }
                else if (strcmp(token,&#34;jmp&#34;)==0)  //-------------- JUMP -----------------------------
                {
                    op1 = strtok(NULL,&#34;\n\t\r &#34;);           //read the label
                    jumptable[noofjumps].location = counter;    //write the jz instruction&#39;s location into the jumptable 
                    op2=(char*)malloc(sizeof(op1));         //allocate space for the label                  
                    strcpy(op2,op1);                //copy the label into the allocated space
                    jumptable[noofjumps].label=op2;         //point to the label from the jumptable
                    noofjumps++;                    //skip to the next empty location in jumptable
                    program[counter]=0x5000;            //write the incomplete instruction (just opcode) to memory
                    counter++;                  //skip to the next empty location in memory.
                }               
                else if (strcmp(token,&#34;add&#34;)==0) //----------------- ADD -------------------------------
                {
                    op1 = strtok(NULL,&#34;\n\t\r &#34;);    
                    op2 = strtok(NULL,&#34;\n\t\r &#34;);
                    op3 = strtok(NULL,&#34;\n\t\r &#34;);
                    chch = (op1[0]-48)| ((op2[0]-48)&lt;&lt;3)|((op3[0]-48)&lt;&lt;6);  
                    program[counter]=0x7000+((chch)&amp;0x00ff); 
                    counter++; 
                }
                else if (strcmp(token,&#34;sub&#34;)==0)
                {
                    //to be added
                }
                else if (strcmp(token,&#34;and&#34;)==0)
                {
                    //to be added
                }
                else if (strcmp(token,&#34;or&#34;)==0)
                {
                    //to be added
                }
                else if (strcmp(token,&#34;xor&#34;)==0)
                {
                    //to be added
                }                       
                else if (strcmp(token,&#34;not&#34;)==0)
                {
                    op1 = strtok(NULL,&#34;\n\t\r &#34;);
                    op2 = strtok(NULL,&#34;\n\t\r &#34;);
                    ch = (op1[0]-48)| ((op2[0]-48)&lt;&lt;3);
                    program[counter]=0x7500+((ch)&amp;0x00ff);  
                    counter++;
                }
                else if (strcmp(token,&#34;mov&#34;)==0)
                {
                    //to be added
                }
                else if (strcmp(token,&#34;inc&#34;)==0)
                {
                    op1 = strtok(NULL,&#34;\n\t\r &#34;);
                    ch = (op1[0]-48)| ((op1[0]-48)&lt;&lt;3);
                    program[counter]=0x7700+((ch)&amp;0x00ff);  
                    counter++;
                }
                else if (strcmp(token,&#34;dec&#34;)==0)
                {
                                    //to be added
                }
                else //------WHAT IS ENCOUNTERED IS NOT AN INSTRUCTION BUT A LABEL. UPDATE THE LABEL TABLE--------
                {
                    labeltable[nooflabels].location = counter;  //buraya bir counter koy. error check
                    op1=(char*)malloc(sizeof(token));
                    strcpy(op1,token);
                    labeltable[nooflabels].label=op1;
                    nooflabels++;
                } 
                token = strtok(NULL,&#34;,\n\t\r &#34;);  
            }
        }


//================================= SECOND PASS ==============================

                //supply the address fields of the jump and jz instructions from the 
        int i,j;         
        for (i=0; i&lt;noofjumps;i++)                                                                   //for all jump/jz instructions
        {
            j=0;
            while ( strcmp(jumptable[i].label , labeltable[j].label) != 0 )             //if the label for this jump/jz does not match with the 
                j++;                                                                // jth label in the labeltable, check the next label..
            program[jumptable[i].location] +=(labeltable[j].location-jumptable[i].location-1)&amp;0x0fff;       //copy the jump address into memory.
        }                                                     




                // search for the start of the .data segment
        rewind(fp);  
        while(fgets(line,sizeof line,fp)!= NULL)  //skip till .data, if no .data, also ok.
        {
            token=strtok(line,&#34;\n\t\r &#34;);
            if (strcmp(token,&#34;.data&#34;)==0 )
                break;

        }


                // process the .data segment and generate the variabletable[] array.
        int dataarea=0;
        while(fgets(line,sizeof line,fp)!= NULL)
        {
            token=strtok(line,&#34;\n\t\r &#34;);
            if (strcmp(token,&#34;.code&#34;)==0 )  //go till the .code segment
                break;
            else if (token[strlen(token)-1]==&#39;:&#39;)
            {               
                token[strlen(token)-1]=&#39;\0&#39;;  //will not cause memory leak, as we do not do malloc
                variabletable[noofvariables].location=counter+dataarea;
                op1=(char*)malloc(sizeof(token));
                strcpy(op1,token);
                variabletable[noofvariables].name=op1;
                token = strtok(NULL,&#34;,\n\t\r &#34;);
                if (token==NULL)
                    program[counter+dataarea]=0;
                else if (strcmp(token, &#34;.space&#34;)==0)
                {
                    token=strtok(NULL,&#34;\n\t\r &#34;);
                    dataarea+=atoi(token);
                }
                else if((token[0]==&#39;0&#39;)&amp;&amp;(token[1]==&#39;x&#39;)) 
                    program[counter+dataarea]=hex2int(token+2)&amp;0xffff; 
                else if ((  (token[0])==&#39;-&#39;) || (&#39;0&#39;&lt;=(token[0])&amp;&amp;(token[0]&lt;=&#39;9&#39;))  )
                    program[counter+dataarea]=atoi(token)&amp;0xffff;  
                noofvariables++;
                dataarea++;
            }
        }






// supply the address fields for the ldi instructions from the variable table
        for( i=0; i&lt;noofldis;i++)
        {
            j=0;
            while ((j&lt;noofvariables)&amp;&amp;( strcmp( lditable[i].name , variabletable[j].name)!=0 ))
                j++;
            if (j&lt;noofvariables)
                program[lditable[i].location] = variabletable[j].location;              
        } 

// supply the address fields for the ldi instructions from the label table
        for( i=0; i&lt;noofldis;i++)
        {
            j=0;
            while ((j&lt;nooflabels)&amp;&amp;( strcmp( lditable[i].name , labeltable[j].label)!=0 ))
                j++;
            if (j&lt;nooflabels){
                program[lditable[i].location] = (labeltable[j].location)&amp;0x0fff;
                printf(&#34;%d %d %d\n&#34;, i, j, (labeltable[j].location));   
            }           
        } 

//display the resulting tables
        printf(&#34;LABEL TABLE\n&#34;);
        for (i=0;i&lt;nooflabels;i++)
            printf(&#34;%d %s\n&#34;, labeltable[i].location, labeltable[i].label); 
        printf(&#34;\n&#34;);
        printf(&#34;JUMP TABLE\n&#34;);
        for (i=0;i&lt;noofjumps;i++)
            printf(&#34;%d %s\n&#34;, jumptable[i].location, jumptable[i].label);   
        printf(&#34;\n&#34;);
        printf(&#34;VARIABLE TABLE\n&#34;);
        for (i=0;i&lt;noofvariables;i++)
            printf(&#34;%d %s\n&#34;, variabletable[i].location, variabletable[i].name);    
        printf(&#34;\n&#34;);
        printf(&#34;LDI INSTRUCTIONS\n&#34;);
        for (i=0;i&lt;noofldis;i++)
            printf(&#34;%d %s\n&#34;, lditable[i].location, lditable[i].name);  
        printf(&#34;\n&#34;);
        fclose(fp);
        fp = fopen(&#34;RAM&#34;,&#34;w&#34;);
        fprintf(fp,&#34;v2.0 raw\n&#34;);
        for (i=0;i&lt;counter+dataarea;i++)
            fprintf(fp,&#34;%04x\n&#34;,program[i]);
    }   
}
</code></pre></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>People have written assemblers in machine code. They&#39;ve also written then in assembly language--often a subset of the language they translate themselves, so they start with a simple &#34;bootstrap&#34; version of the assembler, then add features to it as they need them for the assembler itself.</p><p>However, none of this is particularly a necessity. In the end, an assembler is a (usually fairly) simple translation program. It takes in a file in one (text) format, and writes out a file in another (usually an object file format).</p><p>The fact that the text that&#39;s input represents machine instructions in a textual format and the result represents the same instructions in binary format doesn&#39;t make much difference to the language that&#39;s used to implement the assembler--in fact, even higher languages than C such as SNOBOL and Python can work quite nicely--I (fairly) recently worked on an assembler written in Python, and it worked pretty well for the job.</p><p>As far as how you bootstrap things initially: typically on another machine that has decent development tools and such. If you&#39;re developing new hardware, you usually start by writing a simulator (or at least emulator) for the new machine anyway, so at first you&#39;re building and running the code on some host system in any case.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../why-do-some-compilers-generate-direct-machine-code/'>Why do some compilers generate direct machine code</a></li><li class="list-group-item"><a href='../why-cant-native-machine-code-be-easily-decompiled/'>Why can&#8217;t native machine code be easily decompiled</a></li><li class="list-group-item"><a href='../why-convert-to-assembly-language-instead-of-machine-code/'>Why convert to assembly language instead of machine code</a></li><li class="list-group-item"><a href='../how-does-a-compiler-know-the-machine-language-of-targeted-processor-to-which-the-source-code-has-to-be-converted/'>How does a compiler know the machine language of targeted processor to which the source code has to be converted</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>