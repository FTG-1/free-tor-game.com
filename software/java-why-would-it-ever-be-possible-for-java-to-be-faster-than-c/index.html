<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Java &#8211; Why would it ever be possible for Java to be faster than C++ &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1064025 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1064025" class="post-1064025 software type-software status-publish hentry category-software tag-c tag-java tag-performance"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Java &#8211; Why would it ever be possible for Java to be faster than C++</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">java</span><span class="mr-2 badge badge-warning">performance</span></p><div class="entry-content"><p>Sometimes Java outperforms C++ in benchmarks.  Of course, sometimes C++ outperforms.</p><p>See the following links:</p><ul><li><a href="http://keithlea.com/javabench/">http://keithlea.com/javabench/</a></li><li><a href="http://blog.dhananjaynene.com/2008/07/performance-comparison-c-java-python-ruby-jython-jruby-groovy/">http://blog.dhananjaynene.com/2008/07/performance-comparison-c-java-python-ruby-jython-jruby-groovy/</a></li><li><a href="http://blog.cfelde.com/2010/06/c-vs-java-performance/">http://blog.cfelde.com/2010/06/c-vs-java-performance/</a></li></ul><p>But how is this even possible?  It boggles my mind that interpreted bytecode could ever be faster than a compiled language.</p><p>Can someone please explain?  Thanks!</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>First, most JVMs include a compiler, so &#34;interpreted bytecode&#34; is actually pretty rare (at least in benchmark code -- it&#39;s not quite as rare in real life, where your code is usually more than a few trivial loops that get repeated extremely often).</p><p>Second, a fair number of the benchmarks involved appear to be quite biased (whether by intent or incompetence, I can&#39;t really say). Just for example, years ago I looked at some of the source code linked from one of the links you posted. It had code like this:</p><pre><code>  init0 = (int*)calloc(max_x,sizeof(int));
  init1 = (int*)calloc(max_x,sizeof(int));
  init2 = (int*)calloc(max_x,sizeof(int));
  for (x=0; x&lt;max_x; x++) {
    init2[x] = 0;
    init1[x] = 0;
    init0[x] = 0;
  }
</code></pre><p>Since <code>calloc</code> provides memory that&#39;s already zeroed, using the <code>for</code> loop to zero it again is obviously useless. This was followed (if memory serves) by filling the memory with other data anyway (and no dependence on it being zeroed), so all the zeroing was completely unnecessary anyway. Replacing the code above with a simple <code>malloc</code> (like any sane person would have used to start with) improved the speed of the C++ version enough to beat the Java version (by a fairly wide margin, if memory serves).</p><p>Consider (for another example) the <code>methcall</code> benchmark used in the blog entry in your last link. Despite the name (and how things might even look), the C++ version of this is <em>not</em> really measuring much about method call overhead at all. The part of the code that turns out to be critical is in the Toggle class:</p><pre><code>class Toggle {
public:
    Toggle(bool start_state) : state(start_state) { }
    virtual ~Toggle() {  }
    bool value() {
        return(state);
    }
    virtual Toggle&amp; activate() {
        state = !state;
        return(*this);
    }
    bool state;
};
</code></pre><p>The critical part turns out to be the <code>state = !state;</code>. Consider what happens when we change the code to encode the state as an <code>int</code> instead of a <code>bool</code>:</p><pre><code>class Toggle {
    enum names{ bfalse = -1, btrue = 1};
    const static names values[2];
    int state;

public:
    Toggle(bool start_state) : state(values[start_state]) 
    { }
    virtual ~Toggle() {  }
    bool value() {  return state==btrue;    }

    virtual Toggle&amp; activate() {
        state = -state;
        return(*this);
    }
};
</code></pre><p>This minor change improves the overall speed by about a <strong>5:1 margin</strong>. Even though the benchmark was <em>intended</em> to measure method call time, in reality most of what it was measuring was the time to convert between <code>int</code> and <code>bool</code>. I&#39;d certainly agree that the inefficiency shown by the original is unfortunate -- but given how rarely it seems to arise in real code, and the ease with which it can be fixed when/if it does arise, I have a difficult time thinking of it as meaning much.</p><p>In case anybody decides to re-run the benchmarks involved, I should also add that there&#39;s an almost equally trivial modification to the Java version that produces (or at least at one time produced -- I haven&#39;t re-run the tests with a recent JVM to confirm they still do) a fairly substantial improvement in the Java version as well. The Java version has an NthToggle::activate() that looks like this:</p><pre><code>public Toggle activate() {
this.counter += 1;
if (this.counter &gt;= this.count_max) {
    this.state = !this.state;
    this.counter = 0;
}
return(this);
}
</code></pre><p>Changing this to call the base function instead of manipulating <code>this.state</code> directly gives quite a substantial speed improvement (though not enough to keep up with the modified C++ version).</p><p>So, what we end up with is a false assumption about interpreted byte codes vs. some of the worst benchmarks (I&#39;ve) ever seen. Neither is giving a meaningful result.</p><p>My own experience is that with equally experienced programmers paying equal attention to optimizing, C++ will beat Java more often than not -- but (at least between these two), the language will rarely make as much difference as the programmers and design. The benchmarks being cited tell us more about the (in)competence/(dis)honesty of their authors than they do about the languages they purport to benchmark.</p><p>[Edit: As implied in one place above but never stated as directly as I probably should have, the results I&#39;m quoting are those I got when I tested this ~5 years ago, using C++ and Java implementations that were current at that time. I haven&#39;t rerun the tests with current implementations. A glance, however, indicates that the code hasn&#39;t been fixed, so all that would have changed would be the compiler&#39;s ability to cover up the problems in the code.]</p><p>If we ignore the Java examples, however, it <em>is</em> actually possible for interpreted code to run faster than compiled code (though difficult and somewhat unusual).</p><p>The usual way this happens is that the code being interpreted is much more compact than the machine code, or it&#39;s running on a CPU that has a larger data cache than code cache.</p><p>In such a case, a small interpreter (e.g., the inner interpreter of a Forth implementation) may be able to fit entirely in the code cache, and the program it&#39;s interpreting fits entirely in the data cache. The cache is typically faster than main memory by a factor of at least 10, and often much more (a factor of 100 isn&#39;t particularly rare any more).</p><p>So, if the cache is faster than main memory by a factor of N, and it takes fewer than N machine code instructions to implement each byte code, the byte code should win (I&#39;m simplifying, but I think the general idea should still be apparent).</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-why-do-the-java-programs-run-faster-in-eclipse-than-in-bluej/'>Java &#8211; Why do the java programs run faster in eclipse than in BlueJ</a></li><li class="list-group-item"><a href='../are-bools-bits-faster-than-integers/'>Are Bools/Bits Faster Than Integers</a></li><li class="list-group-item"><a href='../why-is-nosql-faster-than-sql/'>Why is NoSQL faster than SQL</a></li><li class="list-group-item"><a href='../java-heap-allocation-faster-than-c/'>Java Heap Allocation Faster than C++</a></li><li class="list-group-item"><a href='../why-does-haskells-built-in-max-function-run-faster-than-mine/'>Why does Haskell&#8217;s built in max function run faster than mine</a></li><li class="list-group-item"><a href='../java-why-would-the-final-keyword-ever-be-useful/'>Java &#8211; Why would the &#8216;final&#8217; keyword ever be useful</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>