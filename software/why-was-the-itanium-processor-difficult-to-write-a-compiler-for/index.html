<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Why was the Itanium processor difficult to write a compiler for &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1066233 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1066233" class="post-1066233 software type-software status-publish hentry category-software tag-compiler tag-history"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Why was the Itanium processor difficult to write a compiler for</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">compiler</span><span class="mr-2 badge badge-info">history</span></p><div class="entry-content"><p>It&#39;s commonly stated that Intel&#39;s Itanium 64-bit processor architecture failed because the revolutionary <a href="http://en.wikipedia.org/wiki/Explicitly_parallel_instruction_computing">EPIC instruction set</a> was very difficult to write a good compiler for, which meant a lack of good developer tools for IA64, which meant a lack of developers creating programs for the architecture, and so no one wanted to use hardware without much software for it, and so the platform failed, and all for the want of <del>a horseshoe nail</del> good compilers.</p><p>But why was the compiler stuff such a difficult technical problem?  It seems to me that if the explicit parallelism in EPIC was difficult for compiler vendors to implement&#8230; why put that burden on them in the first place?  It&#39;s not like a good, well-understood solution to this problem didn&#39;t already exist: put that burden on Intel instead and give the compiler-writers a simpler target.</p><p>Itanium came out in 1997.  By this point, the <a href="http://en.wikipedia.org/wiki/UCSD_Pascal">UCSD P-Code</a> bytecode system was nearly 20 years old, the <a href="http://en.wikipedia.org/wiki/Z-machine">Z-machine</a> just slightly younger, and the JVM was the hot new rising star in the world of programming languages.  Is there any reason why Intel didn&#39;t specify a &#34;simple Itanium bytecode&#34; language, and provide a tool that converts this bytecode into optimized EPIC code, leveraging their expertise as the folks who designed the system in the first place?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>The <a href="http://en.wikipedia.org/wiki/Explicitly_parallel_instruction_computing">Wikipedia article on EPIC</a> has already outlined the many perils common to VLIW and EPIC.</p><p>If anyone does not catch the sense of fatalism from that article, let me highlight this:</p><blockquote><p>Load responses from a memory hierarchy which includes CPU caches and DRAM do not have a deterministic delay.</p></blockquote><p>In other words, any hardware design that fails to cope with (*) the non-deterministic latency from memory access will just become a spectacular failure.</p><p>(*) By &#34;cope with&#34;, it is necessary to achieve reasonably good execution performance (in other words, &#34;cost-competitive&#34;), which necessitates not letting the CPU fall idle for tens to hundreds of cycles ever so often.</p><p>Note that the coping strategy employed by EPIC (mentioned in the Wikipedia article linked above) does not actually solve the issue. It merely says that the burden of indicating data dependency now falls on the compiler. That&#39;s fine; the compiler already has that information, so it is straightforward for the compiler to comply. The problem is that the CPU is still going to idle for tens to hundreds of cycles over a memory access. In other words, it externalizes a secondary responsibility, while still failing to cope with the primary responsibility.</p><p>The question can be rephrased as: &#34;Given a hardware platform that is destined to be a failure, why (1) didn&#39;t (2) couldn&#39;t the compiler writers make a heroic effort to redeem it?&#34;</p><p>I hope my rephrasing will make the answer to that question obvious.</p><hr/><p>There is a second aspect of the failure which is also fatal.</p><p>The coping strategies (mentioned in the same article) assumes that software-based prefetching can be used to recover at least part of the performance loss due to non-deterministic latency from memory access.</p><p>In reality, prefetching is only profitable if you are performing streaming operations (reading memory in a sequential, or highly predictable manner).</p><p>(That said, if your code makes frequent access to some localized memory areas, caching will help.)</p><p>However, most general-purpose software must make plenty of random memory accesses. If we consider the following steps:</p><ul><li>Calculate the address, and then</li><li>Read the value, and then</li><li>Use it in some calculations</li></ul><p>For most general-purpose software, these three must be executed in quick succession. In other words, it is not always possible (within the confines of software logic) to calculate the address up front, or to find enough work to do to fill up the stalls between these three steps.</p><p>To help explain why it is not always possible to find enough work to fill up the stalls, here is how one could visualize it.</p><ul><li>Let&#39;s say, to effectively hide the stalls, we need to fill up 100 instructions which do not depend on memory (so will not suffer from additional latency).</li><li>Now, as a programmer, please load up any software of your choice into a disassembler. Choose a random function for analysis.</li><li>Can you identify anywhere a sequence of 100 instructions (*) which are exclusively free of memory accesses?</li></ul><p>(*) If we could ever make <code>NOP</code> do useful work ...</p><hr/><p>Modern CPUs try to cope with the same using dynamic information - by concurrently tracking the progress of each instruction as they circulate through the pipelines. As I mentioned above, part of that dynamic information is due to non-deterministic memory latency, therefore it cannot be predicted to any degree of accuracy by compilers. In general, there is simply not enough information available at the compile-time to make decisions that could possibly fill up those stalls.</p><hr/><p><strong>In response to the answer by AProgrammer</strong></p><p>It is not that &#34;compiler ... extracting parallelism is hard&#34;.</p><p>Reordering of memory and arithmetic instructions by modern compilers is the evidence that it has no problem identifying operations that are independently and thus concurrently executable.</p><p>The main problem is that non-deterministic memory latency means that whatever &#34;instruction pairing&#34; one has encoded for the VLIW/EPIC processor will end up being stalled by memory access.</p><p>Optimizing instructions that do not stall (register-only, arithmetic) will not help with the performance issues caused by instructions that are very likely to stall (memory access).</p><p>It is an example of failure to apply the 80-20 rule of optimization: Optimizing things that are already fast will not meaningfully improve overall performance, unless the slower things are also being optimized.</p><hr/><p><strong>In response to answer by Basile Starynkevitch</strong></p><p>It is not &#34;... (whatever) is hard&#34;, it is that EPIC is unsuitable for any platform that has to cope with high dynamism in latency.</p><p>For example, if a processor has all of the following:</p><ul><li>No direct memory access;<ul><li>Any memory access (read or write) has to be scheduled by DMA transfer;</li></ul></li><li>Every instruction has the same execution latency;</li><li>In-order execution;</li><li>Wide / vectorized execution units;</li></ul><p>Then VLIW/EPIC will be a good fit.</p><p>Where does one find such processors? DSP. And this is where VLIW has flourished.</p><hr/><p>In hindsight, the failure of Itanium (and the continued pouring of R&amp;D effort into a failure, despite obvious evidence) is an example of organizational failure, and deserves to be studied in depth.</p><p>Granted, the vendor&#39;s other ventures, such as hyperthreading, SIMD, etc., appears to be highly successful. It is possible that the investment in Itanium may have had an enriching effect on the skills of its engineers, which may have enabled them to create the next generation of successful technology.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../how-to-know-if-the-compiler-broke-the-code-and-what-do-i-do-if-it-was-the-compiler/'>How to know if the compiler broke the code and what do I do if it was the compiler</a></li><li class="list-group-item"><a href='../c-why-c-to-write-a-compiler/'>C++ &#8211; Why C++ to write a compiler</a></li><li class="list-group-item"><a href='../what-came-first-the-compiler-or-the-source/'>What came first, the compiler, or the source</a></li><li class="list-group-item"><a href='../why-was-f-created/'>Why was F# created</a></li><li class="list-group-item"><a href='../is-the-microsoft-c-compiler-cl-exe-a-compiler-driver-or-a-compiler/'>Is the microsoft C compiler (cl.exe) a compiler driver or a compiler</a></li><li class="list-group-item"><a href='../why-was-the-first-compiler-written-before-the-first-interpreter/'>Why was the first compiler written before the first interpreter</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>