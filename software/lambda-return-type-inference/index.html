<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Lambda Return Type Inference &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1079323 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1079323" class="post-1079323 software type-software status-publish hentry category-software tag-generics tag-lambda tag-return-type tag-type-systems"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Lambda Return Type Inference</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">generics</span><span class="mr-2 badge badge-info">lambda</span><span class="mr-2 badge badge-warning">return-type</span><span class="mr-2 badge badge-primary">type-systems</span></p><div class="entry-content"><p>Writing my own JVM compiler, I am facing a giant problem that I am desperately unable to solve:</p><h1>Lambda Return Type Inference</h1><h2>1. Overview of the compiler lifecycle</h2><p>More specifically, the order in which things should happen in a compiler to make this work correctly. First of all, as probably every compiler, mine is divided in several <em>phases</em> that run on the AST and do the work. After tokenizing, parsing and building the ast, the following phases happen in that order:</p><ol><li><strong>RESOLVE_TYPES</strong> &#8211; Links type tokens to their classes</li><li><strong>RESOLVE</strong> &#8211; Links fields and methods</li><li><strong>CHECK_TYPES</strong> &#8211; Re-checks types (boxing, &#8230;), Infers generic type arguments</li><li><strong>CHECK</strong> &#8211; More uninteresting semantic checks that could be skipped in a perfect world</li></ol><p>The phases in question are RESOLVE and CHECK_TYPES. The first resolves method calls and field accesses / assignments as well as their callees and arguments, basically everything important. Between the two, something happens that I call <code>withType</code>. Basically, the context in which an expression appears calls the <code>withType</code> method of the expression with the type it expects the expression to have.</p><p><strong><em>Example</em></strong></p><p>Consider this method and an invocation:</p><pre><code>class List[E]
{
    public List[U] mapped(Function[E, U] mapper) = ...
}

List[String] list = [ &#34;a&#34;, &#34;b&#34;, &#34;c&#34; ]
var list2 = list.mapped { s =&gt; s.toUpperCase }
</code></pre><p><strong><em>What the compiler does</em></strong></p><p>This is what is going to happen in my compiler now (we ignore what happens with the <code>List</code> class):</p><ol><li>Read File, Tokenize, Parse &#8211; nothing spectacular</li><li>Resolve Types &#8211; nothing special, link all explicit types (<code>List[String]</code>)</li><li><strong>Resolve</strong> &#8211; link method calls</li></ol><p>It is known that <code>list</code> has the type <code>List[String]</code>, so we can search that for methods called <code>mapped</code>. Iterate through all methods in the class, and if the name matches the method name, continue with argument types. This works like this: The argument type is <code>Function[E, U]</code>, so call <code>isType(Function[E, U])</code> on the argument <code>{ s =&gt; s.toUpperCase }</code>.<br /> The Statement List <code>{ }</code> delegates the call to the lambda expression, which checks if the type has a functional method.</p><pre><code>interface Function[T, R]
{
    R apply(T par1) // &lt;-- Here it is
}
</code></pre><p>Now, link the method and the type <code>Function[E, U]</code> to the lambda expression.</p><ol start="3"><li><strong>Check Types</strong> &#8211; Infer the type arguments of generic types</li></ol><p>We start with <code>Function[E, U]</code>. It is known that <code>E</code> is a type parameter of the generic type <code>List[E]</code>, which is also the type of the callee, but more concrete: <code>List[String]</code>. That means that <code>E</code> can be inferred to <code>String</code>. But here comes the problem: Since we need <code>E</code> for the type of the lambda parameter <code>s</code>, it was not possible to <strong>resolve</strong> the lambda body, i.e. <code>s.toUpperCase</code>. Because of that, it is not possible to infer <code>U</code> at the moment, so the compiler continues without inferring the right type (it simply uses <code>any</code>, which is <code>java.lang.Object</code>). That means that our inferred type is now <code>Function[String, any]</code>.</p><p>In the next step, the compiler calls the <code>withType</code> method of the lambda expression, which updates the type stored in the lambda AST node. Now we can actually call <code>lambda.checkTypes</code>, which will a) infer the type of <code>s</code> to <code>String</code> and b) call <strong>resolve</strong> (!), <strong>withType</strong> and <strong>checkTypes</strong> on the lambda body, allowing us to compute the return type of the lambda.</p><h2>2. The problem</h2><p>As you can see, although we now have the type of the lambda parameter <code>s</code> and the return type of the lambda (<code>String</code>), the type of the lambda is still <code>Function[String, any]</code>, which means the result of the call to <code>mapped</code> and therefore the type of the variable list2 is <code>List[any]</code>. However, since the return type of the lambda is actually <code>String</code>, this is not the correct type (since <code>List</code> is invariant on <code>E</code>, the types are not even compatible). The generic type system of the compiler is not advanced enough to make things like</p><pre><code>List[String] list2 = list.mapped { s =&gt; s.toUpperCase }
</code></pre><p>impossible, but neither variant is technically correct as long as the lambda type gets inferred to <code>Function[String, any]</code> while it is actually <code>Function[String, String]</code>.</p><p>Furthermore, consider this expression:</p><pre><code>int length = list.mapped(s =&gt; s.replace(&#34;a&#34;, &#34;&#34;)).getFirst.length
</code></pre><p>The call to <code>mapped</code> returns a <code>List[any]</code>, therefore <code>getFirst</code> returns an <code>any</code>, which does not have a <code>length</code> member. Normally, one would expect this expression to work, and in fact lambda expressions work like this in Java and Scala (which makes things a little simpler by enforcing their built-in function types, disallowing <code>FunctionInterface</code>s).</p><h2>3. The question</h2><p>Now that you know the details of my compiler lifecycle, type inference and lambda expressions in my programming language, is there any way I could restructure it to make lambda return type inference work correctly? Although they have very different compiler phases and -lifecycles, Java 8 and Scala have to do similar things after all as well.</p><h2>4. My potential solution</h2><p>I was able to come up with at least a sort of solution that covers around 10% of the problem, which would be to infer types in <strong>RESOLVE</strong> so the lambda can actually call <code>resolve</code> of its body in <strong>resolve</strong> instead of <strong>checkTypes</strong>. That means that the return type of the lambda is known after <strong>resolve</strong> and further calls in the chain have the proper callee type (e.g., the <code>getFirst</code> method). However, I am unsure if that would be possible with my current type inference system. Any opinion / advice is greatly appreciated.</p><h3>Compiler Source Code:</h3><ul><li><a href="https://github.com/Clashsoft/Dyvil" rel="nofollow">GitHub Repository</a></li><li><a href="https://github.com/Clashsoft/Dyvil/blob/master/src/compiler/dyvil/tools/compiler/ast/type/IType.java" rel="nofollow">IType class</a></li><li><a href="https://github.com/Clashsoft/Dyvil/blob/master/src/compiler/dyvil/tools/compiler/ast/type/GenericType.java" rel="nofollow">GenericType class</a></li><li><a href="https://github.com/Clashsoft/Dyvil/blob/master/src/compiler/dyvil/tools/compiler/ast/method/Method.java" rel="nofollow">Method class</a> (<code>inferType</code> around line 880)</li><li><a href="https://github.com/Clashsoft/Dyvil/blob/master/src/compiler/dyvil/tools/compiler/ast/expression/IValue.java" rel="nofollow">IValue class</a></li><li><a href="https://github.com/Clashsoft/Dyvil/blob/master/src/compiler/dyvil/tools/compiler/ast/expression/LambdaExpression.java" rel="nofollow">LambdaExpression</a> class</li></ul><p><em>View at own risk, 90k lines of code.</em></p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Your problem is that you link method calls before the program is fully type-checked. In a complicated language with subtype polymorphism and parametric polymorphism, you cannot do any kind of linking before you know the type (or in the case of subtyping, the type bounds) of an expression. The solution is to introduce type variables for expressions of (initially) unknown type, and properly unify type variables with concrete types. If you cannot resolve a type variable, that&#39;s an error and not an invitation to deduce the most general type.</p><p>A proper type inferer would look at the code</p><pre><code>var list2 = list.mapped { s =&gt; s.toUpperCase }
</code></pre><p>in the static environment</p><pre><code>list : List[String]
List[E]#mapped[U] : (E =&gt; U) =&gt; List[U]
String#toUpperCase : () =&gt; String
</code></pre><p>like this:</p><ul><li>infer <code>var list2 = list.mapped { s =&gt; s.toUpperCase }</code><ul><li>infer <code>list.mapped { s =&gt; s.toUpperCase }</code><ul><li>infer <code>list</code><ul><li>known to be <code>List[String]</code></li><li>save <code>E = String</code> to the static environment for this expression.</li></ul></li><li>resolves to <code>List[E]#mapped[U]</code></li><li>introduce variable <code>$U</code> for <code>U</code>.</li><li>known to be <code>(E =&gt; $U) =&gt; List[$U]</code></li><li>unify arguments: <code>(E =&gt; $U) &gt;: typeof({ s =&gt; s.toUpperCase })</code><ul><li>infer <code>{ s =&gt; s.toUpperCase }</code><ul><li>introduce variables <code>$a, $b</code></li><li>known to be <code>$a =&gt; $b</code></li><li>unify <code>(E =&gt; $U) &gt;: ($a =&gt; $b)</code>: <code>E &lt;: $a</code> and <code>$b &lt;: $U</code>. Technically, these are just type bounds, but let&#39;s consider them equal.</li><li>save <code>E = $a</code>, <code>$b = $U</code> to the static environment for this expression</li><li>save <code>s : $a</code> to the static environment for this expression</li><li>infer <code>s.toUpperCase</code><ul><li>infer <code>s</code><ul><li>known to be <code>String</code></li></ul></li><li>infer <code>.toUpperCase</code>.<ul><li>matches <code>String#toUpperCase</code></li><li>known to be <code>() =&gt; String</code></li></ul></li><li>is <code>String</code></li></ul></li><li>unify <code>String &lt;: $b</code>, but lets consider them equal</li><li>save <code>$b = String</code> to the static environment for this expression</li></ul></li><li>is <code>($a =&gt; $b) = (String =&gt; String)</code></li><li>already unified <code>(E =&gt; $U) &gt;: ($a =&gt; $b)</code>.</li></ul></li><li>is <code>List[$U] = List[String]</code></li></ul></li><li>infer <code>var list2</code><ul><li>introduce variable <code>$c</code></li><li>save <code>list2 : $c</code> into the static environment for this scope</li><li>is <code>$c</code></li></ul></li><li>unify <code>$c &gt;: List[String]</code>, but let&#39;s consider them equal</li><li>save <code>$c = List[String]</code> into the static environment</li></ul></li></ul><p>After this round of type inference, asking the static environment for the type of <code>list2</code> gives us <code>List[String]</code>. The above steps roughly follow along the type inference steps for a Hindley-Milner type system, but note that you are probably dealing with subtyping, which makes type inference far more complicated: unifying a type only provides us bounds on the type and very rarely a concrete type. In the above example, I ignored these details and always unified the types as equals.</p><p>The second major problem is infering the type of the object on which to dispatch for a method call. In this example, I always tried to infer the type of the object before resolving the method call. However, this is not necessary. A method <code>List[E]#mapper[U] : (E =&gt; U) =&gt; List[U]</code> could also be viewed as a free function <code>.mapper[E, U]: (List[E], E =&gt; U) =&gt; List[U]</code>. In other words, the implicit <code>this</code> argument is transformed to an explicit argument. This allows us use type variables for the invocant variable, and makes it easier to deal with a set of overloads. Consider the following example:</p><pre><code>static env:
  .add[E]    : (List[E], E) =&gt; void
  .add[E]    : (List[E], List[E]) =&gt; void
  .add[K, V] : (Map[K, V], K, V) =&gt; void
  .add       : (Integer, Integer) =&gt; Integer
  a          : $a
  b          : $b

expression:
    a.add(b)
</code></pre><p>when type-infering that expression, we initially only know that this is some kind of <code>.add</code> call, but we do not know which one â€“ we cannot resolve it at this point. We have to unify each of the possible types with the given types. If one unification fails, we remove that possibility from the set of overloads.</p><ul><li>infer <code>a.add(b)</code><ul><li>candidate <code>(List[E], E) =&gt; void</code><ul><li>variable <code>$c</code> for <code>E</code></li><li>unify arguments<ul><li><code>$a = List[$c]</code></li><li><code>$b = $c</code></li></ul></li><li>is <code>void</code></li></ul></li><li>candidate <code>(List[E], List[E]) =&gt; void</code><ul><li>variable <code>$c</code> for <code>E</code></li><li>unify arguments<ul><li><code>$a = List[$c]</code></li><li><code>$b = List[$c]</code></li></ul></li><li>is void</li></ul></li><li>candidate <code>(Map[K, V], K, V) =&gt; void</code><ul><li>variable <code>$c</code> for <code>K</code></li><li>variable <code>$d</code> for <code>V</code></li><li>unify arguments<ul><li><code>$a = Map[$c, $d]</code></li><li><code>$b = $c</code></li><li>ERROR: no argument for <code>V</code>-parameter</li></ul></li><li>discard candidate</li></ul></li><li>candidate <code>(Integer, Integer) =&gt; Integer</code><ul><li>unifiy arguments<ul><li><code>$a = Integer</code></li><li><code>$b = Integer</code></li></ul></li><li>is <code>Integer</code></li></ul></li></ul></li></ul><p>So after doing a round of type inference, we are still left with a number of choices. Some languages employ some ranking mechanism, e.g. methods on subtypes are preferred over methods on supertypes. In our example, there is no sensible ranking. If you want your type-checker to be moderately well-performing, you should issue a compiler exception here, e.g.</p><pre><code>foo.sourcefile:42:3 error: could not resolve call to method `add`
    a.add(b)
      ^
    candidates are:
    List[E]#add(E elem)
    List[E]#add(List[E] elems)
    Integer#add(Integer rhs)
</code></pre><p>Likewise, you should display an error when the set of possible methods is empty after attempting unification.</p><p>Note that for a different static environment, the the set of possible solutions would only contain one method which you could bind to. E.g.:</p><pre><code>a : List[$c]
b : $c
</code></pre><p>Since the call can be resolved unambiguously in that case, we can continue doing type inference for the rest of the compilation unit in hopes of resolving the <code>$c</code> type variable.</p><p>Depending on how you implement generics, you could link the method call directly after successfully infering the type for the call. If you need to know the value of the type variable <code>$c</code>, you need to wait until type inference for the compilation unit has completed, and can do linking in a second pass. This is now easy to do since all expressions are already annotated with their inferred type.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-is-a-lambda-expression-something-more-than-an-anonymous-inner-class-with-a-single-method/'>Java &#8211; Is a lambda expression something more than an anonymous inner class with a single method</a></li><li class="list-group-item"><a href='../when-writing-an-interpreter-how-should-the-type-inference-algorithm-change-the-parsed-ast-should-it/'>When writing an interpreter, how should the type inference algorithm change the parsed AST? Should it</a></li><li class="list-group-item"><a href='../whats-the-tradeoff-for-type-inference/'>What&#8217;s the tradeoff for type inference</a></li><li class="list-group-item"><a href='../c-converting-method-to-return-generic-type/'>C# &#8211; Converting Method to Return Generic Type</a></li><li class="list-group-item"><a href='../type-inference-with-duck-typing-does-this-work-why-is-it-not-used/'>Type inference with duck typing &#8211; does this work? Why is it not used</a></li><li class="list-group-item"><a href='../the-common-procedure-used-when-compilers-statically-type-check-complex-expressions/'>The common procedure used when compilers statically type check &#8220;complex&#8221; expressions</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>