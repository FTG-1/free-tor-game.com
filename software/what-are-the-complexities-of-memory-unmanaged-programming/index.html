<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>What are the complexities of memory-unmanaged programming &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1079284 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1079284" class="post-1079284 software type-software status-publish hentry category-software tag-garbage-collection tag-low-level"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">What are the complexities of memory-unmanaged programming</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">garbage-collection</span><span class="mr-2 badge badge-info">low-level</span></p><div class="entry-content"><p>Or in other words, what specific problems did automated garbage collection solve? I&#39;ve never done low-level programming, so I don&#39;t know how complicated can freeing resources get.</p><p>The kind of bugs that GC addresses seem (at least to an external observer) the kind of things that a programmer that knows well his language, libraries, concepts, idioms, etc, wouldn&#39;t do. But I could be wrong: is manual memory handling intrinsically complicated?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>I&#39;ve never done low-level programming, so I don&#39;t know how complicated
 can freeing resources get.</p></blockquote><p>Funny how the definition of &#34;low-level&#34; changes over time.  When I was first learning to program, any language that provided a standardized heap model that makes a simple allocate/free pattern possible was considered high-level indeed.  In <em>low-level programming</em>, you&#39;d have to keep track of the memory yourself, (not the allocations, but the memory locations themselves!), or write your own heap allocator if you were feeling really fancy.</p><p>Having said that, there&#39;s really nothing scary or &#34;complicated&#34; about it, at all.  Remember when you were a child and your mom told you to put away your toys when you&#39;re done playing with them, that she is not your maid and wasn&#39;t going to clean up your room for you?  Memory management is simply this same principle applied to code.  (GC is like having a maid who <em>will</em> clean up after you, but she&#39;s very lazy and slightly clueless.)  The principle of it is simple: Each variable in your code has one and only one owner, and it’s the responsibility of that owner to free the variable’s memory when it is no longer needed.  (<a href="http://tech.turbu-rpg.com/106/delphi-memory-management-made-simple" rel="noreferrer">The Single Ownership Principle</a>)  This requires one call per allocation, and several schemes exist that automate ownership and cleanup in one way or another so you don&#39;t even have to write that call into your own code.</p><p>Garbage collection is supposed to solve two problems.  It invariably does a very bad job at one of them, and depending on the implementation may or may not do well with the other one.  The problems are memory leaks (holding on to memory after you&#39;re done with it) and dangling references (freeing memory before you&#39;re done with it.)  Let&#39;s look at both issues:</p><p>Dangling references: Discussing this one first because it&#39;s the really serious one.  You&#39;ve got two pointers to the same object.  You free one of them and don&#39;t notice the other one.  Then at some later point you attempt to read (or write to or free) the second one.  Undefined behavior ensues.  If you don&#39;t notice it, you can easily corrupt your memory.  Garbage collection is supposed to make this problem impossible by ensuring that nothing is ever freed until all references to it are gone.  In a fully-managed language, this almost works, until you have to deal with external, unmanaged memory resources.  Then it&#39;s right back to square 1.  And in a non-managed language, things are trickier still.  (Poke around on Mozilla&#39;s bug-tracker for Firefox sometime and see if you can find how many different crash bugs were caused by their garbage collector screwing up and freeing things too early!)</p><p>Fortunately, dealing with this issue is basically a solved problem.  You don&#39;t need a garbage collector, you need a <em>debugging memory manager.</em> I use Delphi, for example, and with a single external library and a simple compiler directive I can set the allocator to &#34;Full Debug Mode.&#34;  This adds a negligible (less than 5%) performance overhead in return for enabling some features that keep track of used memory.  If I free an object, it fills its memory with <code>0x80</code> bytes (easily recognizable in the debugger) and if I ever attempt to call a virtual method (including the destructor) on a freed object, it notices and interrupts the program with an error box with three stack traces--when the object was created, when it was freed, and where I am now--plus some other useful information, then raises an exception. This is obviously not suitable for release builds, but it makes tracking down and fixing dangling reference issues trivial.</p><p>The second issue is memory leaks.  This is what happens when you continue to hold on to allocated memory when you no longer need it.  It can happen in any language, with or without garbage collection, and can only be fixed by writing your code right.  Garbage collection helps to mitigate <em>one specific form</em> of memory leak, the kind that happens when you have no valid references to a piece of memory that has not yet been freed, which means the memory stays allocated until the program ends.  Unfortunately, the only way to accomplish this in an automated manner is by turning every allocation into a memory leak!</p><p>I&#39;m probably going to get dinged by GC proponents if I try to say something like that, so allow me to explain.  Remember that the definition of a memory leak is holding on to allocated memory when you no longer need it.  In addition to having no references to something, you can also leak memory by having an unnecessary reference to it, such as holding it in a container object when you should have freed it.  I&#39;ve seen some memory leaks caused by doing this, and they are very difficult to track down whether you have a GC or not, since they involve a perfectly valid reference to the memory and there are no clear &#34;bugs&#34; for debugging tools to catch.  As far as I know, there is no automated tool that allows you to catch this type of memory leak.</p><p>So a garbage collector only concerns itself with the no-references variety of memory leaks, because that&#39;s the only type that can be dealt with in an automated fashion.  If it could watch all your references to everything and free every object as soon as it has zero references pointing to it, it would be perfect, at least with regards to the no-references problem.  Doing this in an automated manner is called <em>reference counting,</em> and it can be done in some limited situations, but it has its own issues to deal with.  (For example, object A holding a reference to object B, which holds a reference to object A. In a reference-counting scheme, neither object can be freed automatically, even when there are no external references to either A or B.)  So garbage collectors use <em>tracing</em> instead: Start with a set of known-good objects, find all objects that they reference, find all objects that <em>they</em> reference, and so on recursively until you&#39;ve found everything.  Whatever does not get found in the tracing process is garbage and can be thrown away.  (Doing this successfully, of course, requires a managed language that puts certain restrictions on the type system to ensure that the tracing garbage collector can always tell the difference between a reference and some random piece of memory that happens to look like a pointer.)</p><p>There are two problems with tracing.  First, it&#39;s slow, and while it&#39;s happening the program has to be more or less paused to avoid race conditions.  This can lead to noticeable execution hiccups when the program is supposed to be interacting with a user, or bogged-down performance in a server app.  This can be mitigated by various techniques, such as breaking allocated memory up into &#34;generations&#34; on the principle that if an allocation doesn&#39;t get collected the first time you try, it&#39;s likely to stick around for a while.  Both the .NET framework and the JVM use generational garbage collectors.</p><p>Unfortunately, this feeds into the second problem: memory not getting freed when you&#39;re done with it.  Unless the tracing runs immediately after you finish with an object, it will stick around until the next trace, or even longer if it makes it past the first generation.  In fact, <a href="http://blog.barrkel.com/2009/12/commonly-confused-tidbits-re-net.html" rel="noreferrer">one of the best explanations of the .NET garbage collector I&#39;ve seen</a> explains that, in order to make the process as fast as possible, the GC has to defer collection for as long as it can!  So the problem of memory leaks is &#34;solved&#34; rather bizarrely by <em>leaking as much memory as possible for as long as possible!</em> This is what I mean when I say that a GC turns every allocation into a memory leak.  In fact, <a href="https://stackoverflow.com/a/5737813/32914">there is no guarantee that any given object will <em>ever</em> be collected.</a></p><p>Why is this an issue, when the memory still gets reclaimed when needed?  For a couple of reasons.  First, imagine allocating a large object (a bitmap, for example,) that takes a significant amount of memory.  And then soon after you&#39;re done with it, you need another large object that takes the same (or close to the same) amount of memory.  Had the first object been freed, the second one can reuse its memory.  But on a garbage-collected system, you may well be still waiting for the next trace to run, and so you end up unnecessarily wasting memory for a second large object.  It&#39;s basically a race condition.</p><p>Second, holding memory unnecessarily, especially in large amounts, can cause problems in a modern multitasking system.  If you take up too much physical memory, it can cause your program or other programs to have to page (swap some of their memory out to disc) which really slows things down.  For certain sytems, such as servers, paging can not only slow the system down, <a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/03/17/91178.aspx" rel="noreferrer">it can crash the whole thing if it&#39;s under load.</a></p><p>Like the dangling references problem, the no-references problem can be solved with a debugging memory manager.  Again, I&#39;ll mention the Full Debug Mode from Delphi&#39;s FastMM memory manager, since it&#39;s the one I&#39;m most familiar with.  (I&#39;m sure similar systems exist for other languages.)</p><p>When a program running under FastMM terminates, you can optionally have it report the existence of all allocations that never got freed.  Full Debug Mode takes it a step further: it can save a file to disc containing not only the type of allocation, but a stack trace from when it was allocated and other debug info, for each leaked allocation.  This makes tracking down no-references memory leaks trivial.</p><p>When you really look at it, garbage collection may or may not do well with preventing dangling references, and universally does a bad job at handling memory leaks.  Its one virtue, in fact, is not the garbage collection itself, but a side-effect: it provides an automated way to perform heap compaction.  This can prevent an arcane problem (memory exhaustion through heap fragmentation) that can kill programs that run continually for a long time and have a high degree of memory churn, and heap compaction is pretty much impossible without garbage collection.  However, any good memory allocator these days uses buckets to minimize fragmentation, which means that fragmentation only truly becomes a problem in extreme circumstances.  For a program in which heap fragmentation is likely to be a problem, it&#39;s advisable to use a compacting garbage collector.  But IMO in any other case, the use of garbage collection is premature optimization, and better solutions exist to the problems that it &#34;solves.&#34;</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../what-are-the-algorithms-behind-low-pause-gc/'>What are the algorithms behind low pause GC</a></li><li class="list-group-item"><a href='../how-does-a-garbage-collector-prevent-the-whole-memory-from-being-scanned-on-every-collect/'>How does a garbage collector prevent the whole memory from being scanned on every collect</a></li><li class="list-group-item"><a href='../java-which-part-of-the-memory-is-used-for-the-garbage-collector/'>Java &#8211; Which part of the Memory is used for the Garbage Collector</a></li><li class="list-group-item"><a href='../c-how-to-find-out-what-resources-are-unmanaged/'>C# &#8211; How to find out what resources are unmanaged</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>