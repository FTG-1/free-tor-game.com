<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++ &#8211; How does Rust diverge from the concurrency facilities of C++ &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1074576 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1074576" class="post-1074576 software type-software status-publish hentry category-software tag-c tag-c14 tag-concurrency tag-rust"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++ &#8211; How does Rust diverge from the concurrency facilities of C++</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">c++14</span><span class="mr-2 badge badge-warning">concurrency</span><span class="mr-2 badge badge-primary">rust</span></p><div class="entry-content"><h3>Questions</h3><p>I am trying to understand whether Rust fundamentally and sufficiently improves upon the concurrency facilities of C++ so that to decide if I should spend the time to learn Rust.</p><p>Specifically, how does idiomatic Rust improve upon, or at any rate diverge from, the concurrency facilities of idiomatic C++?</p><p>Is the improvement (or divergence) mostly syntactical, or is it substantially an improvement (divergence) in paradigm? Or is it something else? Or is it not really an improvement (divergence) at all?</p><hr/><h3>Rationale</h3><p>I have recently been trying to teach myself C++14&#39;s concurrency facilities, and something feels not quite right. Something feels off. <em>What</em> feels off? Hard to say.</p><p>It feels almost as though the compiler were not really trying to help me to write correct programs when it comes to concurrency. It feels almost as though I were using an assembler rather than a compiler.</p><p>Admittedly, it is entirely probable that I yet suffer from a subtle, faulty concept when it comes to concurrency.  Maybe I do not yet grok Bartosz Milewski&#39;s tension between stateful programming and data races.  Maybe I don&#39;t quite understand how much of sound concurrent methodology is in the compiler and how much of it is in the OS.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>A better concurrency story is one of the main goals of the Rust project, so improvements should be expected, provided we trust the project to achieve its goals. Full disclaimer: I have a high opinion of Rust and am invested in it. As requested, I&#39;ll try to avoid value judgements and describe <em>differences</em> rather than (IMHO) <em>improvements</em>.</p><h2>Safe and unsafe Rust</h2><p>&#34;Rust&#34; is composed of two languages: One that tries very hard to isolate you from the dangers of systems programming, and a more powerful one without any such aspirations.</p><p>Unsafe Rust is a nasty, brutish language that feels a lot like C++. It allows you to do arbitrarily dangerous things, talk to the hardware, (mis-)manage memory manually, shoot yourself in the foot, etc. It is very much like C and C++ in that the correctness of the program is ultimately in your hands and the hands of all other programmers involved in it.
You opt into this language with the keyword <code>unsafe</code>, and as in C and C++, a single mistake in a single location can bring the whole project crashing down.</p><p>Safe Rust is the &#34;default&#34;, the vast vast majority of Rust code is safe, and if you never mention the keyword <code>unsafe</code> in your code, you never leave the safe language. The rest of the post will mostly concern itself with that language, because <code>unsafe</code> code can break any and all of the guarantees that safe Rust works so hard to give you. On the flip side, <code>unsafe</code> code is <strong>not evil</strong> and not treated as such by the community (it is, however, strongly discouraged when not necessary).</p><p>It&#39;s dangerous, yes, but also important, because it allows building the abstractions that safe code uses. Good unsafe code uses the type system to prevent others from misusing it, and therefore the presence of unsafe code in a Rust program need not disturb the safe code. All the following differences exist because Rust&#39;s type systems has tools that C++&#39;s doesn&#39;t have, and because the unsafe code that implements the concurrency abstractions uses these tools effectively.</p><h2>Non-difference: Shared/mutable memory</h2><p>Although Rust places more emphasis on message passing and very strictly controls shared memory, it does not rule out shared memory concurrency and explicitly supports the common abstractions (locks, atomic operations, condition variables, concurrent collections).</p><p>Moreover, like C++ and unlike functional languages, Rust really likes traditional imperative data structures. There&#39;s no persistent/immutable linked list in the standard library. There&#39;s <code>std::collections::LinkedList</code> but it&#39;s like <code>std::list</code> in C++ and discouraged for the same reasons as <code>std::list</code> (bad use of cache).</p><p>However, with reference to the title of this section (&#34;shared/mutable memory&#34;), Rust has one difference to C++:
It strongly encourages that memory be &#34;shared XOR mutable&#34;, i.e., that memory is never shared and mutable at the same time.
Mutate memory as you like &#34;in the privacy of your own thread&#34;, so to speak.
Contrast this with C++ where shared mutable memory is the default option and widely used.</p><p>While the shared-xor-mutable paradigm is very important to the below differences, it is also a quite different programming paradigm that takes a while to get used to, and that places significant restrictions.
Occasionally one has to opt out of this paradigm, e.g., with atomic types (<code>AtomicUsize</code> is the essence of shared mutable memory).
Note that locks also obey the shared-xor-mutable rule, because it rules out <em>concurrent</em> reads and writes (while one thread writes, no other threads can read or write).</p><h2>Non-difference: Data races are undefined behavior (UB)</h2><p>If you trigger a data race in Rust code, it&#39;s game over, just as in C++. All bets are off and the compiler can do whatever it pleases.</p><p>However, it is a hard guarantee that <strong>safe Rust code does not have data races</strong> (or any UB for that matter).
This extends both to the core language and to the standard library.
If you can write a Rust program that doesn&#39;t use <code>unsafe</code> (including in third party libraries but excluding the standard library) which triggers UB, then that is considered a bug and will be fixed (this has already happened several times). This if of course in stark contrast to C++, where it&#39;s trivial to write programs with UB.</p><h2>Difference: Strict locking discipline</h2><p>Unlike C++, a lock in Rust (<code>std::sync::Mutex</code>, <code>std::sync::RwLock</code>, etc.) <em>owns</em> the data it&#39;s protecting. Instead of taking a lock and then manipulating some shared memory that is associated to the lock only in the documentation, the shared data is inaccessible while you don&#39;t hold the lock. A RAII guard keeps the lock and simultaneously gives access to the locked data (this much could be implemented by C++, but isn&#39;t by the <code>std::</code> locks). The lifetime system ensures that you can&#39;t keep accessing the data after you release the lock (drop the RAII guard).</p><p>You can of course have a lock that contains no useful data (<code>Mutex&lt;()&gt;</code>), and just share some memory without explicitly associating it with that lock. However, having potentially unsynchronized shared memory requires <code>unsafe</code>.</p><h2>Difference: Prevention of accidental sharing</h2><p>Although you can have shared memory, you only share when you explicitly ask for it.
For example, when you use message passing (e.g. the channels from <code>std::sync</code>), the lifetime system ensures that you don&#39;t keep any references to the data after you sent it to another thread. To share data behind a lock, you explicitly construct the lock and give it to another thread. To share unsynchronized memory with <code>unsafe</code> you, well, have to use <code>unsafe</code>.</p><p>This ties into the next point:</p><h2>Difference: Thread-safety tracking</h2><p>Rust&#39;s type system tracks some notion of thread safety. Specifically, the <code>Sync</code> trait denotes types that can be shared by several threads without risk of data races, while <code>Send</code> marks those that can be moved from one thread to another. This is enforced by the compiler throughout the program, and thus library designers dare make optimizations that would be stupidly dangerous without these static checks. For example, C++&#39;s <code>std::shared_ptr</code> which always uses atomic operations to manipulate its reference count, to avoid UB if a <code>shared_ptr</code> happens to be used by several threads. Rust has <code>Rc</code> and <code>Arc</code>, which differ only in that <code>Rc</code> uses non-atomic refcount operations and isn&#39;t threadsafe (i.e. doesn&#39;t implement <code>Sync</code> or <code>Send</code>) while <code>Arc</code> is very much like <code>shared_ptr</code> (and implements both traits).</p><p>Note that if a type <em>doesn&#39;t</em> use <code>unsafe</code> to manually implement synchronization, the presence or absence of the traits are inferred correctly.</p><h2>Difference: Very strict rules</h2><p>If the compiler cannot be absolutely sure that some code is free from data races and other UB, <em>it will not compile, period</em>. The aforementioned rules and other tools can get you quite far, but sooner or later you will want to do something that&#39;s correct, but for subtle reasons that escape the compiler&#39;s notice. It could be a tricky lock-free data structure, but it could also be something as mundane as &#34;I write to random locations in a shared array but the indices are computed such that every location is written to by only one thread&#34;.</p><p>At that point you can either bite the bullet and add a bit of unnecessary synchronization, or you reword the code such that the compiler can see its correctness (often doable, sometimes quite hard, occasionally impossible), or you drop into <code>unsafe</code> code. Still, it&#39;s extra mental overhead, and Rust does not give you any guarantees for the correctness of the <code>unsafe</code> code.</p><h2>Difference: Fewer tools</h2><p>Because of the aforementioned differences, in Rust it&#39;s much more rare that one writes code that may have a data race (or a use after free, or a double free, or ...).
While this is nice, it has the unfortunate side effect that the ecosystem for tracking down such errors is even more underdeveloped than one would expect given the youth and small size of the community.</p><p>While tools like valgrind and LLVM&#39;s thread sanitizer could in principle be applied to Rust code, whether this actually works yet varies from tool to tool (and even those that work may be hard to set up, especially since you may not find any up-to-date resources on how to do it).
It doesn&#39;t really help that Rust currently lacks a real specification and in particular a formal memory model.</p><p>In short, writing <code>unsafe</code> Rust code correctly is <em>harder</em> than writing C++ code correctly, despite both languages being roughly comparable in terms of capabilities and risks. Of course this must be weighted against the fact that a typical Rust program will contain only a relatively small fraction of <code>unsafe</code> code, whereas a C++ program is, well, fully C++.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../design-concurrency-how-to-approach-the-design-and-debug-the-implementation/'>Design &#8211; Concurrency: How to approach the design and debug the implementation</a></li><li class="list-group-item"><a href='../how-does-a-movie-theater-seat-booking-system-prevent-multiple-users-from-reserving-the-same-seats/'>How does a movie theater seat booking system prevent multiple users from reserving the same seats</a></li><li class="list-group-item"><a href='../how-are-rust-traits-different-from-go-interfaces/'>How are Rust Traits different from Go Interfaces</a></li><li class="list-group-item"><a href='../why-does-rust-require-external-linkers-any-other-similar-languages/'>Why does Rust require external linkers? Any other similar languages</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>