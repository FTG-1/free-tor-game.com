<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>The reasoning behind making non-determinism a feature of Haskell &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1087244 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1087244" class="post-1087244 software type-software status-publish hentry category-software tag-haskell tag-non-determinism"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">The reasoning behind making non-determinism a feature of Haskell</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">haskell</span><span class="mr-2 badge badge-info">non-determinism</span></p><div class="entry-content"><p>We know that in <a href="../../../en.wikipedia.org/wiki/Prolog.html" rel="noreferrer">Prolog</a> &#8211; <a href="https://news.ycombinator.com/item?id=3302827" rel="noreferrer">non-deterministic predicates</a> are a feature used to whittle down <a href="http://kti.ms.mff.cuni.cz/~bartak/prolog/combinatorics.html" rel="noreferrer">combinatorial problems</a>.</p><p>In Haskell we see some <a href="http://mgaut72.github.io/2014/05/07/Backtracking-in-Haskell.html" rel="noreferrer">similar non-deterministic behaviour</a> to Prolog in the <a href="https://www.schoolofhaskell.com/school/starting-with-haskell/basics-of-haskell/13-the-list-monad" rel="noreferrer">List Monad</a>.</p><p>In Haskell we also see non-determinism in <a href="https://wiki.haskell.org/Evaluation_order_and_state_tokens" rel="noreferrer">choosing thunk evaluation order</a>:</p><blockquote><p>But there is nothing telling GHC which of those thunks should be evaluated first, and therefore GHC is at full liberty to choose whichever thunk to evaluate first.</p></blockquote><p>This is fascinating &#8211; and somewhat liberating. I&#39;m wondering (apart from noodling with logic problems like <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle" rel="noreferrer">eight-queens</a>) what principle this serves. Was there some big idea or big problem they were trying to solve with non-determinism?</p><p>My question is: <strong>What is the reasoning behind making <a href="../../../en.wikipedia.org/wiki/Nondeterministic_programming.html" rel="noreferrer">non-determinism</a> a feature of Haskell?</strong></p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>While it is true that both aspects cited in the questions appear as forms of non-determinism, they are indeed quite different both in how they work and in their goals. Hence any answer has to be necessarily split in two parts.</p><h3>Evaluation order</h3><p>Haskell mandates no particular execution order in the evaluation of thunks essentially because of two reasons.</p><ol><li>First of all, Haskell is a purely functional language, so you are guaranteed to have <em>referential transparency</em> (if you don&#39;t mess around with <code>unsafePerformIO</code> &amp; co.). This means that the evaluation of any expression, <em>e.g.</em> <code>f x</code> will result in the same outcome no matter how many times it is evaluated and no matter in which part of the program it is evaluated (assuming <code>f</code> and <code>x</code> bind to the same values in the considered scopes, of course). Hence mandating any particular order of execution would have <em>no purpose</em>, because changing it would not produce any observable effects in the outcome of the program. In this regard, this is not really a form of nondeterminism, at least not any form of <em>observable</em> one, since the different possible executions of the program are all semantically equivalent.</li></ol><p>Changing order of execution can, however, have an effect on the <em>performance</em> of the program, and leaving the compiler the freedom of manipulating the order at its will is fundamental to achieve the
 amazing performance that a compiler like GHC can obtain compiling
 such an high-level language. As an example, think about a classic
 stream-fusion transformation:</p><pre><code>map f . map g = map (f.g)
</code></pre><p>This equality simply means that applying two functions to a list with <code>map</code> has the same outcome than applying once the composition of the two functions instead. This is only true because of referential transparency, and is a kind of transformation that the compiler can <em>always</em> apply, no matter what. If changing the order of execution of the three functions had effects on the result of the expression, this would not be possible. On the other hand, compiling it in the second form instead of the first may have a huge performance impact, because it avoids the construction of one temporary list and only traverses the list once. The fact that GHC can automatically apply such transformation is a direct consequence of referential transparency and the non-fixed order of execution and it is one of the key aspects of the great performance that Haskell can achieve.</p><ol start="2"><li>Haskell is a <em>lazy</em> language. This means that any particular expression is not required to be evaluated unless its result is actually needed, and this could as well be never. Laziness is a sometimes debated feature and some other functional languages avoid it or limit it to be opt-in, but in the context of Haskell it is a key feature in the way the language is used and designed. Laziness is another powerful tool in the hands of the compiler&#39;s optimizer, and most importantly allows code to be <em>composed</em> easily.</li></ol><p>To see what I mean by ease of composition, consider an example when you have a function <code>producer :: Int -&gt; [Int]</code> that performs some complex task to compute a list of some sort of data from an input argument, and <code>consumer :: [Int] -&gt; Int</code> which is another complex function computing a result from a list of input data. You have separately written them, tested them, <em>optimized</em> them very carefully, and used them in isolation in different projects. Now in the next project it happens that you have to call <code>consumer</code> on the result of <code>producer</code>. In a non-lazy language this may be non-optimal, since it may be the case that the combined task may be most efficiently implemented without building a temporary list structure. To obtain an optimized implementation you would have to reimplement the combined task from scratch, re-test it, and re-optimize it.</p><p>In haskell this is not needed, and calling the composition of the two functions <code>consumer . producer</code> is perfectly fine. The reason is that the program is not required to actually produce the whole result of <code>producer</code> before giving it to <code>consumer</code>. In fact, as soon as <code>consumer</code> will need the first element of its input list, then the corresponding code from <code>producer</code> will run as far as needed to produce it, and no more. When the second element is needed, it will be computed. If some element will not be needed by <code>consumer</code>, it will not be computed at all, effectively saving useless computations. The execution of <code>consumer</code> and <code>producer</code> will effectively be interleaved, not only avoiding the memory usage of the intermediate list structure, but also possibly avoiding useless computations, and the execution would probably be similar to the hand-written combined version that you had to write yourself otherwise. This is what I meant by <em>composition</em>. You had two well-tested and performant pieces of code and you could compose them obtaining for free a well-tested and performant piece of code.</p><h3>Nondeterministic monads</h3><p>The use of nondeterministic behavior provided by the List monads and similar ones is instead totally different. Here the point is not that of providing the compiler with means of optimizing your program, but clearly and concisely express computations that are inherently nondeterministic.</p><p>An example of what I mean is provided by the interface of the <a href="https://hackage.haskell.org/package/incremental-sat-solver-0.1.8/docs/Data-Boolean-SatSolver.html" rel="noreferrer"><code>Data.Boolean.SatSolver</code></a> library. It provides a very simple DPLL SAT solver implemented in Haskell. As you may know, solving the SAT problem involves finding an assignment of boolean variables that satisfies a boolean formula. There may be more than one such assignments, however, and one may need to find any of them, or iterate over all of them, depending on the application. Hence, many libraries will have two different functions like <code>getSolution</code> and <code>getAllSolutions</code>. This library instead has only one function, <code>solve</code>, with the following type:</p><pre><code>solve :: MonadPlus m =&gt; SatSolver -&gt; m SatSolver
</code></pre><p>Here, the result is a <code>SatSolver</code> value wrapped inside a monad of unspecified type, which however is constrained to implement the <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#t:MonadPlus" rel="noreferrer"><code>MonadPlus</code></a> type class. This type class is the one that represent the kind of nondeterminism provided by the list monad, and in fact lists are instances. All the functions that operate on <code>SatSolver</code> values returns their results wrapped into a <code>MonadPlus</code> instance. So suppose you have the formula <code>p || !q</code> and you want to solve it by restricting on the results that set <code>q</code> true, then the usage is the following (variables are numbered instead of being identified by name):</p><pre><code>expr = Var 1 :||: Not (Var 2)

task :: MonadPlus m =&gt; m SatSolver
task = do
  pure newSatSolver
  assertTrue expr
  assertTrue (Var 2)
</code></pre><p>Note how the monad instance and the do notation mask all the low-level details of how the functions manages the <code>SatSolver</code> data structure, and lets us express clearly our intent.</p><p>Now, if you want to obtain <em>all</em> the results, you simply use <code>solve</code> in a context where its result has to be a list. The following will print all the results on screen (assuming a <code>Show</code> instance for <code>SatSolver</code>, which does not exist, but forgive me this point).</p><pre><code>main = sequence . map print . solve task
</code></pre><p>However, lists are not the only instances of <code>MonadPlus</code>. <code>Maybe</code> is another instance. So if you just need <em>one</em> solution, no matter which one, you can just use <code>solve</code> as if it returned a <code>Maybe SatSolver</code> value:</p><pre><code>main = case solve task of 
  Nothing -&gt; putStrLn &#34;No solution&#34;
  Just result -&gt; print result
</code></pre><p>Now suppose that you have two tasks so built, <code>task</code> and <code>task2</code>, and you want to obtain a solution to either one. Once again everything comes together to let us compose our pre-existing building blocks:</p><pre><code>combinedTask = task &lt;|&gt; task2
</code></pre><p>where <code>&lt;|&gt;</code> is a binary operation provided by the <code>Alternative</code> typeclass, which is a super class of <code>MonadPlus</code>. This again let us clearly express our intent, reusing code without changes. The nondeterminism is clearly expressed in code, not buried under the details of how the nondeterminism is actually implemented. I suggest you to take a look at the combinators built on top of the <code>Alternative</code> type class to get further examples.</p><p>The nondeterministic monads like lists are not just a way to express nice exercises but offers a way to design elegant and reusable code that clearly expresses intent in the implementation of tasks which are inherently nondeterministic.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../what-is-the-object-oriented-counterpart-to-haskell-coq/'>What is the object oriented counterpart to haskell / coq</a></li><li class="list-group-item"><a href='../whats-the-progress-on-haskell-records/'>What&#8217;s the progress on Haskell records</a></li><li class="list-group-item"><a href='../the-logic-behind-the-use-of-different-arrows/'>The logic behind the use of different arrows (-> <-) in Haskell</a></li><li class="list-group-item"><a href='../what-does-the-symbol-do-in-haskell/'>What does the => symbol do in haskell</a></li><li class="list-group-item"><a href='../the-purpose-of-wrapped-values-in-haskell/'>The purpose of wrapped values in Haskell</a></li><li class="list-group-item"><a href='../a-haskell-value/'>A Haskell value</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>