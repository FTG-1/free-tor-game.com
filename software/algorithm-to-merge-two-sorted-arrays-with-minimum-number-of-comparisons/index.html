<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Algorithm to merge two sorted arrays with minimum number of comparisons &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1064832 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1064832" class="post-1064832 software type-software status-publish hentry category-software tag-algorithms tag-big-o tag-comparison"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Algorithm to merge two sorted arrays with minimum number of comparisons</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">algorithms</span><span class="mr-2 badge badge-info">big o</span><span class="mr-2 badge badge-warning">comparison</span></p><div class="entry-content"><p>Given are two sorted arrays <strong>a</strong>, <strong>b</strong> of type <strong>T</strong> with size <strong>n</strong> and <strong>m</strong>. I am looking for an algorithm that merges the two arrays into a new array (of maximum size n+m).</p><p>If you have a cheap comparison operation, this is pretty simple. Just take from the array with the lowest first element until one or both arrays are completely traversed, then add the remaining elements. Something like this <a href="https://stackoverflow.com/questions/5958169/how-to-merge-two-sorted-arrays-into-a-sorted-array">https://stackoverflow.com/questions/5958169/how-to-merge-two-sorted-arrays-into-a-sorted-array</a></p><p>However, the situation changes when <strong><em>comparing two elements is much more expensive than copying an element from the source array to the target array</em></strong>. For example you might have an array of large arbitrary precision integers, or strings, where a comparison can be quite expensive. <em>Just assume that creating arrays and copying elements is free, and the only thing that costs is comparing elements.</em></p><p>In this case, you want to merge the two arrays <em>with a minimum number of element comparisons</em>. Here are some examples where you should be able to do much better than the simple merge algorithm:</p><pre><code>a = [1,2,3,4, ... 1000]
b = [1001,1002,1003,1004, ... 2000]
</code></pre><p>Or</p><pre><code>a = [1,2,3,4, ... 1000]
b = [0,100,200, ... 1000]
</code></pre><p>There are some cases where the simple merge algorithm will be optimal, like</p><pre><code>a = [1,3,5,7,9,....,999]
b = [2,4,6,8,10,....,1000]
</code></pre><p>So the algorithm should ideally gracefully degrade and perform a maximum of n+m-1 comparisons in case the arrays are interleaved, or at least not be significantly worse.</p><p>One thing that should do pretty well for lists with a large size difference would be to use binary search to insert the elements of the smaller array into the larger array. But that won&#39;t degrade gracefully in case both lists are of the same size and interleaved.</p><p>The only thing available for the elements is a (total) ordering function, so any scheme that makes comparisons cheaper is not possible.</p><p>Any ideas?</p><p>I have come up with <a href="https://github.com/non/spire/blob/master/core/shared/src/main/scala/spire/math/Merging.scala" rel="nofollow noreferrer">this bit in Scala</a>. I believe it is optimal regarding the number of comparisons, but it is beyond my ability to prove it. At least it is <em>much</em> simpler than the things I have found in the literature.</p><p>And since the original posting, I wrote a <a href="http://rklaehn.github.io/2016/01/05/binarymerge/" rel="nofollow noreferrer">blog post</a> about how this works.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>The normal merge sort algorithm - merge step with normally apply n + m -1 comparisons, where one list is of size n and and the other list is of size m. Using this algorithm is the most simplest approach to combine two sorted lists.</p><p>If the comparisons are too expensive you could do two things - either you minimize the number of comparisons or you minimize the cost of comparisons.</p><p>Let&#39;s focus on the minimization of the cost of comparison. You and only you can decide whether the data you are comparing can be quantized or not. If you can quantize them, which is a form of implementing a hash method, which is keeping the ordering. E.g. if your Data is compared by Name, Then the first tname, ... you can take the first to Chars of the name &#34;Klaehn, Ruediger&#34; and reduce/quantize your data element to &#34;Kl.Ru&#34;, if you compare it to &#34;Packer, The&#34; you preserve the ordering &#34;Pa.Th&#34; - you can now apply a cheaper comparison algorithm, comparing the reduced values. But if you find another &#34;Kl.Ru&#34;, you now have a near value, and you might now switch to a more expensive approach comparing these elements.</p><p>If you can extract this quantized value from your data, faster than comparing it, this is the first thing you do, you compare the quantized or hashed value first. Please keep in mind, that this value needs to be computed only once, so you can compute it on creating the data element.</p><p>I also mentioned another way, to minimize your comparisons.</p><p>I had a look into the classic book TAOCP- Volume 3-Sorting and Searching, (pp.197-207, section 5.3.2) which has full 10 pages on this topic. I found two references to algorithms which are faster than n+m-1 comparisons.</p><p>First there is the Hwang-Lin merge algorithm and the second an improvement by Glenn K Manacher - both are cited by TAOCP as well as an algorithm by Christen, which approaches the lower bound of needed comparisons, on special conditions on the length n and m of the lists.</p><p>The algorithm of Manacher was presented in Journal of the ACM Vol. 26 Number 3 on pages 434-440: &#34;Significant Improvements to the &#34;Hwan-Lin&#34; Merging Algorithm&#34;. the list with m items and the list with n items can be of different length, but they must also be odered by the numbers of elements they contain m&lt;=n</p><p>The Hwang-Lin algorithm breaks the lists to merge, apart to smaller lists and sorts the lists by comparing the first element of each sublist, and to decide whether some elements in the sublist need to be compared or not. If the first list is smaller than the second list, then the chance is high, that consecutive elements of the longer list can be transferred into the resulting list without comparison. If the first element of the small ist is greater than the first element of the splitted larger list, all elements in front of sublist can be copied without comparison.</p><p><a href="http://www.math.cmu.edu/~af1p/Texfiles/HL.pdf">Average case analysis of the merging alorithm of Hwang and Lin (Vega, Frieze, Santha)</a> in Section 2 you can find a pseudocode of the HL-Algorithm. Which is a lot better than my description. And you can see why there are fewer comparisons - the algorithm uses a binary search, to find the index, where to insert the element from the shorter list.</p><p>If the lists are not interleaved like in your last example, you should have a remaining smaller and a remaining larger list in most cases. This is when the the HL-algorithm starts to perform better.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-and-net-why-different-sorting-algorithms-are-used-by-default/'>Java and .NET: Why different sorting algorithms are used by default</a></li><li class="list-group-item"><a href='../c-efficient-way-to-find-unique-elements-in-a-vector-compared-against-multiple-vectors/'>C++ &#8211; Efficient way to find unique elements in a vector compared against multiple vectors</a></li><li class="list-group-item"><a href='../fully-stable-in-place-unique-algorithm-in-on/'>Fully Stable, In-Place Unique Algorithm in O(n)</a></li><li class="list-group-item"><a href='../c-optimal-fixed-size-sequential-sorting-algorithms/'>C++ &#8211; Optimal fixed-size sequential sorting algorithms</a></li><li class="list-group-item"><a href='../efficient-algorithm-to-merge-n-successive-sorted-arrays-in-place/'>Efficient algorithm to merge n successive sorted arrays in place</a></li><li class="list-group-item"><a href='../how-does-krs-qsort-work/'>How does K&#038;R&#8217;s qsort work</a></li><li class="list-group-item"><a href='../why-is-the-optimal-choice-for-a-pivot-in-quicksort-algorithm-the-median-element/'>Why is the optimal choice for a pivot in quicksort algorithm the median element</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>