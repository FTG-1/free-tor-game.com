<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>When is it a good idea to force garbage collection &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1064669 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1064669" class="post-1064669 software type-software status-publish hentry category-software tag-garbage-collection tag-language-agnostic tag-memory"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">When is it a good idea to force garbage collection</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">garbage-collection</span><span class="mr-2 badge badge-info">language-agnostic</span><span class="mr-2 badge badge-warning">memory</span></p><div class="entry-content"><p>So I was reading <a href="https://stackoverflow.com/q/4257372/555690">a question about forcing the C# garbage collector to run</a> where almost every single answer is the same: you can do it, but you shouldn&#39;t &#8211; except for some <strong>very rare cases</strong>. Sadly, nobody there elaborates on what are such cases.</p><p>Can you tell me in what sort of scenario it is actually a good or reasonable idea to force garbage collection?</p><p>I&#39;m not asking for C# specific cases but rather, all programing languages that have a garbage collector. I know that you can&#39;t force GC on all languages, like Java, but let&#39;s suppose you can.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>You really can&#39;t make blanket statements about appropriate way to use <em>all</em> GC implementations. They vary wildly. So I&#39;ll speak to the .NET one which you originally referred to.</p><p>You must know the behaviour of the GC pretty intimately to do this with any logic or reason.</p><p>The only advice on collection I can give is: <strong>Never do it.</strong></p><p>If you truly know the intricate details of the GC, you&#39;ll not need my advice so it won&#39;t matter. If you don&#39;t already know with 100% confidence it will help, and have to look online and find an answer like this: <strong>You should not be calling GC.Collect</strong>, or alternatively: <strong>You should go learn the details of how the GC works inside and out, and only then will you <em>know</em> the answer</strong>.</p><p><strong>There is one safe place it makes some sense to use GC.Collect</strong>:</p><p>GC.Collect is an API available that you can use for profiling timings of things. You could profile one algorithm, collect, and profile another algorithm immediately afterwards knowing GC of the first algo wasn&#39;t occurring during your second one skewing the results.</p><p>This sort of profiling is the single time I would ever suggest manually collecting to anyone.</p><hr/><h2>Contrived Example Anyway</h2><p>One possible use case is if you load really large things, they&#39;ll end up in the Large Object Heap which will go straight to Gen 2, though again Gen 2 is for long lived objects because it collects less frequently. If you <em>know</em> that you are loading short lived objects into Gen 2 for any reason, you could clear them out more quickly to keep your Gen 2 smaller and it&#39;s collections faster.</p><p>This is the best example I could come up with, and it&#39;s not good - the LOH pressure you&#39;re building here would cause more frequent collections, and collections are so frequent as it is - chances are it would be clearing out the LOH just as fast as you were blowing it out with temporary objects. I simply don&#39;t trust <em>myself</em> to presume a better collection frequency than the GC itself - tuned by people far <em>far</em> smarter than I.</p><hr/><p><strong>So let&#39;s talk about some of the semantics and mechanisms in the .NET GC... or..</strong></p><h1>Everything I <em>think</em> I know about the .NET GC</h1><p>Please, anyone who finds errors here - do correct me. Much of the GC is well known to be black magic and while I tried to leave out details I was uncertain of, I probably still got some things wrong.</p><p><strong>Below is purposely missing numerous details I&#39;m not certain about, as well as a far larger body of information I&#39;m simply unaware of. Use this information at your own risk.</strong></p><hr/><h2>GC Concepts</h2><p>The .NET GC occurs at inconsistent times, which is why it&#39;s called &#34;non-deterministic&#34;, this means you can&#39;t rely on it to occur at specific times. It&#39;s also a generational garbage collector, which means it partitions your objects into how many GC passes they&#39;ve lived through.</p><p>Objects in Gen 0 heap have lived through 0 collections, these have been newly made so recently no collection has occurred since their instantiation. Objects in your Gen 1 heap have lived through one collection pass, and likewise objects in your Gen 2 heap have lived through 2 collection passes.</p><p>Now it&#39;s worth noting the reason it qualifies these specific generations and partitions accordingly. The .NET GC only recognizes these three generations, because the collection passes that go over these three heaps are all slightly different. Some objects may survive collection passes thousands of times. The GC merely leaves these on the other side of the Gen 2 heap partition, there&#39;s no point in partitioning them anywhere further because they&#39;re actually Gen 44; the collection pass on them is the same as everything in Gen 2 heap.</p><p>There are semantic purposes to these specific generations, as well as implemented mechanisms that honor these, and I&#39;ll get to those in a moment.</p><hr/><h2>What&#39;s in a collection</h2><p>The basic concept of a GC collection pass is that it checks each object in a heap space to see if there are still live references (GC roots) to these objects. If a GC root is found for an object, it means currently executing code can still possible reach and use that object, so it cannot be deleted. However if a GC root is not found for an object, it means the running process no longer needs the object, so it can remove it to free up memory for new objects.</p><p>Now after it&#39;s finished cleaning up a bunch of objects and leaving some alone, there will be an unfortunate side effect: Free space gaps between live objects where the dead ones were removed. This memory fragmentation if left alone would simply waste memory, so collections will typically do what&#39;s called &#34;compaction&#34; where they take all the live objects left and squeeze them together in the heap so the free memory is contiguous on one side of the heap for Gen 0.</p><p>Now given the idea of 3 heaps of memory, all partitioned by the number of collection passes they&#39;ve lived through, let&#39;s talk about why these partitions exist.</p><hr/><h2>Gen 0 Collection</h2><p>Gen 0 being the absolute newest objects, tends to be very small - so you can safely collect it <em>very frequently</em>. The frequency ensures the heap stays small and the collections are <em>very fast</em> because they are collecting over such a small heap. This is based more or less on a heuristic that claims: A large majority of <em>temporary</em> objects which you create, are <em>very</em> temporary, so temporary they&#39;ll no longer be used or referenced almost immediately after use, and thus can be collected.</p><hr/><h2>Gen 1 Collection</h2><p>Gen 1 being objects that didn&#39;t fall into this <em>very</em> temporary category of objects, may still be rather short lived, because still- a vast portion of the objects created are not used for long. Therefore Gen 1 collects rather frequently as well, again keeping it&#39;s heap small so it&#39;s collections are fast. However the assumption is <em>less</em> of it&#39;s objects are temporary than Gen 0, so it collects less frequently than Gen 0</p><p>I will say I frankly don&#39;t know the technical mechanisms that differ between Gen 0&#39;s collection pass and Gen 1&#39;s, if there are any at all other than the frequency they collect.</p><hr/><h2>Gen 2 Collection</h2><p>Gen 2 now must be the mother of all heaps right? Well, yes, that&#39;s more or less right. It&#39;s where all your permanent objects live - the object your <code>Main()</code> lives in for instance, and everything that <code>Main()</code> references because those will be rooted until your <code>Main()</code> returns at the end of your process.</p><p>Given that Gen 2 is a bucket for basically everything the other generations couldn&#39;t collect, it&#39;s objects are largely permanent, or long lived at the least. So recognizing very little of what&#39;s in Gen 2 will actually be something that can be collected, it doesn&#39;t have need to collect frequently. This allows it&#39;s collection to also be slower, since it executes so much less frequent. So this is basically where they&#39;ve tacked on all the extra behaviours for odd scenarios, because they have the time to execute them.</p><hr/><h2>Large Object Heap</h2><p>One example of the extra behaviours of Gen 2 is that it <em>also</em> does the collection on the Large Object Heap. Up until now I&#39;ve been talking entirely about the Small Object Heap, but the .NET runtime allocates things of certain sizes to a separate heap because of what I referred to as compaction above. Compaction requires moving objects around when collections finish on the Small Object Heap. If there&#39;s a living 10mb object in Gen 1, it&#39;s going to take far longer for it to complete the compaction after collection, thus slowing down Gen 1&#39;s collection. So that 10mb object is allocated to the Large Object Heap, and collected during Gen 2 which runs so infrequently.</p><hr/><h2>Finalization</h2><p>Another example is objects with finalizers. You put a finalizer on an object that references resources beyond the scope of .NETs GC (unmanaged resources). The finalizer is the only way the GC gets to demand an unmanaged resource is collected - you implement your finalizer to do the manual collection/removal/release of the unmanaged resource to ensure it doesn&#39;t leak from your process. When the GC gets to executing your objects finalizer, then your implementation will clear the unmanaged resource, making the GC capable of removing your object without risking a resource leak.</p><p>The mechanism with which finalizers do this is by being referenced directly in a finalization queue. When the runtime allocates an object with a finalizer, it adds a pointer to that object to the finalization queue, and locks your object in place (called pinning) so compaction won&#39;t move it which would break the finalization queue reference. As collection passes occur, eventually your object will be found to no longer have a GC root, but the finalization must be executed before it can be collected. So when the object is dead, the collection will move it&#39;s reference from the finalization queue and place a reference to it on what&#39;s known as the &#34;FReachable&#34; queue. Then the collection continues on. At another &#34;non-deterministic&#34; time in the future, a separate thread known as the Finalizer thread will go through the FReachable queue, executing the finalizers for each of the objects referenced. After it&#39;s finished, the FReachable queue is empty, and it has flipped a bit on the header of each object that says they don&#39;t need finalization (This bit can also be flipped manually with <code>GC.SuppressFinalize</code> which is common in <code>Dispose()</code> methods), I also <em>suspect</em> it has unpinned the objects, but don&#39;t quote me on that. The next collection that comes around on whatever heap this object is in, will finally collect it. Gen 0 collections don&#39;t even pay attention to objects with that finalization-needed bit on, it automatically promotes them, without even checking for their root. An unrooted object needing finalization in Gen 1, will get tossed on the <code>FReachable</code> queue, but the collection doesn&#39;t do anything else with it, so it lives into Gen 2. In this way, all objects which have a finalizer, and don&#39;t <code>GC.SuppressFinalize</code> will be collected in Gen 2.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-custom-heap-allocators/'>C++ &#8211; Custom heap allocators</a></li><li class="list-group-item"><a href='../when-a-garbage-collector-compacts-objects-in-the-heap-does-it-change-the-references-on-the-stack/'>When a garbage collector compacts objects in the heap, does it change the references on the stack</a></li><li class="list-group-item"><a href='../is-garbage-collection-needed-for-implementing-safe-closures/'>Is garbage collection needed for implementing safe closures</a></li><li class="list-group-item"><a href='../demonstration-of-garbage-collection-being-faster-than-manual-memory-management/'>Demonstration of garbage collection being faster than manual memory management</a></li><li class="list-group-item"><a href='../garbage-collection-memory-leaks-on-hash-tables/'>Garbage collection &#038; memory leaks on hash tables</a></li><li class="list-group-item"><a href='../how-different-is-garbage-collection-in-pure-languages/'>How different is garbage collection in pure languages</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>