<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>What&#8217;s the REAL benefit of using CDECL? (more specifically pushing instead of reg-ing) &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1073302 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1073302" class="post-1073302 software type-software status-publish hentry category-software tag-abi tag-assembly tag-c tag-calling-conventions tag-x86"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">What&#8217;s the REAL benefit of using CDECL? (more specifically pushing instead of reg-ing)</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">abi</span><span class="mr-2 badge badge-info">assembly</span><span class="mr-2 badge badge-warning">c</span><span class="mr-2 badge badge-primary">calling-conventions</span><span class="mr-2 badge badge-danger">x86</span></p><div class="entry-content"><p>So, I&#39;m learning assembly, and I&#39;ve come to know the <a href="https://en.wikipedia.org/wiki/Application_binary_interface" rel="noreferrer">ABIs</a> and i got some basics tests working using the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl" rel="noreferrer">cdecl</a> calling convention to use the c&#39;s stdlib under nasm.<br /> But I&#39;ve seen other Calling Conventions (like topspeed/Clarion/JPI/watcom/borland register(delphi), fastcall, etc).<br /> And I wonder, what are the REAL benefits of using cdecl instead of Clarion.<br /> More specifically Pushing instead of using the registers.</p><p>This are some of the benefits i <em>imagined</em> please let me know which of these apply.</p><ol><li><p>I&#39;ve read that cdecl is important because it allows to use variable parameters, but as I see it, I can do the same using registers.<br /> The problems are to know the count, type and order of the params, but that problem exists on cdecl too. It can be inferred from the format string (in printf) or from the function signature. And if I run out of registers I can push the rest of the params.</p></li><li><p>I imagine that performance shouldn&#39;t be a big thing because cpus manufactures might have optimized everything that they could regardless of the calling convention of mayor use (and this time is cdecl?Â¿?).<br /> But if I think of raw operations (and disregard caches and writeback buffers) I <em>think</em> it should be faster to use registers instead of the stack (which should be located in ram right?). I mean, is like &#34;inc eax&#34; vs &#34;add eax, 1&#34; (am I right?).</p></li><li><p>By pushing i create a memory space that goes off when I ret (just like creating a local variable).<br /> That might seem handy (to have a local var just by the time of being called).<br /> But, as most params (in my experience) are used as a read value, and very few times we need them as a variable, to store mutated values, and when you do you are actually dealing with complex structures that are passed as pointers anyway.<br /> So I don&#39;t really see the value on creating a memory space BEFORE actually needing it.</p><p>As I see, if I <em>do</em> need a variable is better to have the <em>option</em> to create it (like in clarion), but if I <em>don&#39;t</em> it would be nice to be able to <em>not</em> create it (like you can&#39;t in cdecl).</p></li><li><p>You preserve the registers.<br /> I can&#39;t even think of a positive side. AFAIK the registers are used for intermediary calculations, and as such are volatile in nature. If I think of them as volatile I could push/pop/mov them whenever i need to &#34;hold&#34; the value and <em>only</em> in such cases.<br /> In that sense I see it as the most efficient use (I only access the ram when i need it).</p></li></ol><p>But if I don&#39;t do that, and try to &#34;preserve the registers&#34;:</p><ul><li><p>callee: I have no certainty whatsoever what the callee code will do with a register (unless is being documented or they adhere to the same calling convention). By hoping it will preserve them, it imposes an artificial constraint on the callee. As the callee has no idea which registers need to be <em>really</em> preserved they&#39;ll tend to overpreserve unnecessary registers. (like pusha/popa in x86?) Which <em>sounds</em> really inefficient to me.</p></li><li><p>caller: the caller have no idea what registers will the callee [s]taint?[/s] use, so it&#39;ll just preserve all of them. It&#39;ll end up with the same inefficient result as before.</p></li></ul><p>I noticed that linux syscalls as well as 8086 (from my old classes) use registers instead of stack to pass parameters. What happened there?</p><p>So those are my thoughts, thanks for all the clarification possible.</p><p>Notes:</p><ul><li>I am learning, most of this are <em>assumptions</em> based on what i&#39;ve readed/tried so far. i&#39;ll be glad if you correct me as needed (just be nice).</li><li>I do understand this are all x86 CC, and in 64 there is another (which i&#39;m not familiar with).</li><li>I am not asking which is the &#34;best&#34;, i just want to understand more and clarify my <em>assumptions</em>.</li><li>I am looking for benefits of the calling convention by itself (by contrasting with others). not by it&#39;s side-effects (like compilers and cpus being optimized or its ubiquity)</li><li>Basically a theoretical question to understand more of why that way was chosen</li></ul></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Raymond Chen put together a <a href="https://blogs.msdn.microsoft.com/oldnewthing/20040102-00/?p=41213/" rel="nofollow">history of calling conventions</a> here. While he doesn&#39;t touch on Clarion, he does touch on Fastcall, which while not the same as Clarion does use more of a register-based approach.</p><p>He has this to say:</p><blockquote><p>Fastcall (__fastcall)</p><p>The Fastcall calling convention passes the first parameter in the DX register and the second in the CX register (I think). Whether this was actually faster depended on your call usage. It was generally faster since parameters passed in registers do not need to be spilled to the stack, then reloaded by the callee. On the other hand, if significant computation occurs between the computation of the first and second parameters, the caller has to spill it anyway. To add insult to injury, the called function often spilled the register into memory because it needed to spare the register for something else, which in the &#34;significant computation between the first two parameters&#34; case means that you get a double-spill. Ouch!</p><p>Consequently, __fastcall was typically faster only for short leaf functions, and even then it might not be.</p></blockquote><p>I believe the criticism applied here is still relevant - Clarion is likely faster for certain types of calls, but not others.</p><p>That being said, your points about the register usage are quite valid. While you did not want to consider x64 in the scope of your question, the pattern discussed <a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/01/13/58199.aspx" rel="nofollow">later in that series for Itanium</a> might interest you!</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../object-oriented-whats-the-benefit-of-object-oriented-programming-over-procedural-programming/'>Object-oriented &#8211; What&#8217;s the benefit of object-oriented programming over procedural programming</a></li><li class="list-group-item"><a href='../c-understanding-stack-frame-of-function-call-in-c-c/'>C++ &#8211; Understanding stack frame of function call in C/C++</a></li><li class="list-group-item"><a href='../c-do-i-need-to-declare-a-delay-timer-variable-as-volatile-even-if-i-access-it-from-another-module/'>C++ &#8211; Do I need to declare a delay timer variable as volatile even if I access it from another module</a></li><li class="list-group-item"><a href='../how-does-a-cpu-load-multiple-bytes-at-once-if-memory-is-byte-addressed/'>How does a CPU load multiple bytes at once if memory is byte addressed</a></li><li class="list-group-item"><a href='../why-would-you-ever-use-malloc0/'>Why would you ever use `malloc(0)`</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>