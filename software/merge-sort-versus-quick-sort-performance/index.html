<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Merge sort versus quick sort performance &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1065406 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1065406" class="post-1065406 software type-software status-publish hentry category-software tag-algorithms tag-complexity tag-performance tag-sorting"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Merge sort versus quick sort performance</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">algorithms</span><span class="mr-2 badge badge-info">complexity</span><span class="mr-2 badge badge-warning">performance</span><span class="mr-2 badge badge-primary">sorting</span></p><div class="entry-content"><p>I have implemented merge sort and quick sort using C (GCC 4.4.3 on Ubuntu 10.04 running on a 4 GB RAM laptop with an Intel DUO CPU at 2GHz) and I wanted to compare the performance of the two algorithms.</p><p>The prototypes of the sorting functions are:</p><pre><code>void merge_sort(const char **lines, int start, int end);

void quick_sort(const char **lines, int start, int end);
</code></pre><p>i.e. both take an array of pointers to strings and sort the elements with index i : start &lt;= i &lt;= end.</p><p>I have produced some files containing random strings with length on average 4.5 characters. The test files range from 100 lines to 10000000 lines.</p><p>I was a bit surprised by the results because, even though I know that merge sort has complexity O(n log(n)) while quick sort is O(n^2), I have often read that on average quick sort should be as fast as merge sort. However, my results are the following.</p><ul><li>Up to 10000 strings, both algorithms perform equally well. For 10000 strings, both require about 0.007 seconds.</li><li>For 100000 strings, merge sort is slightly faster with 0.095 s against 0.121 s.</li><li>For 1000000 strings merge sort takes 1.287 s against 5.233 s of quick sort.</li><li>For 5000000 strings merge sort takes 7.582 s against 118.240 s of quick sort.</li><li>For 10000000 strings merge sort takes 16.305 s against 1202.918 s of quick sort.</li></ul><p>So my question is: are my results <strong>as expected</strong>, meaning that quick sort is comparable in speed to merge sort for small inputs but, as the size of the input data grows, the fact that its complexity is quadratic will become evident?</p><p>Here is a sketch of what I did.<br /> In the merge sort implementation, the partitioning consists in calling merge sort recursively, i.e.</p><pre><code>merge_sort(lines, start, (start + end) / 2);
merge_sort(lines, 1 + (start + end) / 2, end);
</code></pre><p>Merging of the two sorted sub-array is performed by reading the data from the array <code>lines</code> and writing it to a global temporary array of pointers (this global array is allocate only once). After each merge the pointers are copied back to the original array. So the strings are stored once but I need twice as much memory for the pointers.</p><p>For quick sort, the partition function chooses the last element of the array to sort as the pivot and scans the previous elements in one loop. After it has produced a partition of the type</p><pre><code>start ... {elements &lt;= pivot} ... pivotIndex ... {elements &gt; pivot} ... end
</code></pre><p>it calls itself recursively:</p><pre><code>quick_sort(lines, start,          pivotIndex - 1);
quick_sort(lines, pivotIndex + 1, end);
</code></pre><p>Note that this quick sort implementation sorts the array in-place and does not require additional memory, therefore it is more memory efficient than the merge sort implementation.</p><p>So my question is: is there a better way to implement quick sort that is worthwhile trying out? If I improve the quick sort implementation and<br /> perform more tests on different data sets (computing the average of the running times on different data sets) can I expect a better performance<br /> of quick sort wrt merge sort?</p><p><strong>EDIT</strong></p><p>Thank you for your answers.</p><p>My implementation is in-place and is based on the pseudo-code I have found<br /> on <a href="http://en.wikipedia.org/wiki/Quicksort" rel="nofollow">wikipedia</a> in Section <strong>In-place version</strong>:</p><pre><code>function partition(array, &#39;left&#39;, &#39;right&#39;, &#39;pivotIndex&#39;)
</code></pre><p>where I choose the last element in the range to be sorted as a pivot, i.e. pivotIndex := right.<br /> I have checked the code over and over again and it seems correct to me.<br /> In order to rule out the case that I am using the wrong implementation<br /> I have uploaded the source code on <a href="https://gist.github.com/2503116" rel="nofollow">github</a> (in case you would like<br /> to take a look at it).</p><p>Your answers seem to suggest that I am using the wrong test data. I will look into it and try out different test data sets. I will report as soon as I have some results.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>If you look at your code for swapping you:</p><pre><code>// If current element is lower than pivot
// then swap it with the element at store_index
// and move the store_index to the right.
</code></pre><p>But, ~50% of the time that string you just swapped needs to be moved back, which is why faster merge sorts work from both ends at the same time.</p><p>Next if you check to see if the first and last elements are the same before doing each of the recursive call you avoid wasting time calling a function only to quickly exit it.  This happens 10000000 in your final test which does add noticeable amounts of time.</p><p>Use,</p><p>if (pivot_index -1 &gt; start)
 quick_sort(lines, start, pivot_index - 1);</p><p>if (pivot_index + 1 &lt; end)
 quick_sort(lines, pivot_index + 1, end);</p><p>You still want an outer function to do an initial   if (start &lt; end) but that only needs to happen once so that function can just call an unsafe version of your code without that outer comparison.</p><p>Also, picking a random pivot tends to avoid N^2 worst case results, but it&#39;s probably not a big deal with your random data set.</p><p>Finally, the hidden problem is QuickSort is comparing strings in ever smaller buckets that are ever closer together,</p><p>(Edit: So, AAAAA, AAAAB, AAAAC, AAAAD then AAAAA, AAAAB.  So, strcmp needs to step though a lot of A&#39;s before looking the useful parts of the strings.)</p><p>but with Merge sort you look at the smallest buckets first while they are vary random.  Mergsorts final passes do compare a lot of strings close to each other, but it&#39;s less of an issue then.  One way to make Quick sorts faster for strings is to compare the first digits of the outer strings and if there the same ignore them when doing the inner comparisons, but you have to be careful that all strings have enough digits that your not skipping past the null terminator.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-and-net-why-different-sorting-algorithms-are-used-by-default/'>Java and .NET: Why different sorting algorithms are used by default</a></li><li class="list-group-item"><a href='../sublinear-extra-space-mergesort/'>Sublinear Extra Space MergeSort</a></li><li class="list-group-item"><a href='../dual-pivot-quicksort-in-face-of-expensive-swaps/'>Dual pivot quicksort in face of expensive swaps</a></li><li class="list-group-item"><a href='../what-makes-for-a-bad-case-for-quick-sort/'>What makes for a bad case for quick sort</a></li><li class="list-group-item"><a href='../python-sort-a-list-while-putting-together-or-after/'>Python &#8211; Sort a list while putting together or after</a></li><li class="list-group-item"><a href='../how-does-the-dividing-step-in-merge-sort-have-constant-time-complexity/'>How does the dividing Step in Merge Sort have Constant Time Complexity</a></li><li class="list-group-item"><a href='../find-k-max-integers-of-an-array-min-heap-vs-selection-algo-vs-selection-sort/'>Find k max integers of an array &#8212; Min Heap vs. Selection Algo vs. Selection Sort</a></li><li class="list-group-item"><a href='../insertion-sort-vs-merge-sort-memory-access/'>Insertion sort vs Merge sort &#8211; memory access</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>