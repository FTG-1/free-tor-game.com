<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Is it possible to &#8220;bake dimension into a type&#8221; in haskell &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1082769 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1082769" class="post-1082769 software type-software status-publish hentry category-software tag-haskell tag-type-safety tag-type-systems"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Is it possible to &#8220;bake dimension into a type&#8221; in haskell</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">haskell</span><span class="mr-2 badge badge-info">type-safety</span><span class="mr-2 badge badge-warning">type-systems</span></p><div class="entry-content"><p>Suppose I want to write a library that deals with vectors and matrices. Is it possible to bake the dimensions into the types, so that operations of incompatible dimensions generate an error at compile time?</p><p>For example I would like the signature of dot product to be something like</p><pre><code>dotprod :: Num a, VecDim d =&gt; Vector a d -&gt; Vector a d -&gt; a
</code></pre><p>where the <code>d</code> type contains a single integer value (representing the dimension of these Vectors).</p><p>I suppose this could be done by defining (by hand) a separate type for each integer, and group them in a type class called <code>VecDim</code>. Is there some mechanism to &#34;generate&#34; such types?</p><p>Or perhaps some better/simpler way of achieving the same thing?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>To expand on @KarlBielefeldt&#39;s answer, here&#39;s a full example of how to implement <em>Vectors</em> - lists with a statically-known number of elements - in Haskell. Hold on to your hat...</p><pre><code>{-# LANGUAGE DataKinds #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE TypeFamilies #-}

import Prelude hiding (foldr, zipWith)
import qualified Prelude
import Data.Type.Equality
import Data.Foldable
import Data.Traversable
</code></pre><p>As you can see from the long list of <code>LANGUAGE</code> directives, this&#39;ll only work with a recent version of GHC.</p><p>We need a way of representing lengths within the type system. By definition, a natural number is either zero (<code>Z</code>) or it&#39;s the successor of some other natural number (<code>S n</code>). So, for example, the number 3 would be written <code>S (S (S Z))</code>.</p><pre><code>data Nat = Z | S Nat
</code></pre><p>With the <a href="http://dreixel.net/research/pdf/ghp.pdf" rel="noreferrer">DataKinds extension</a>, this <code>data</code> declaration introduces a <em>kind</em> called <code>Nat</code> and two <em>type</em> constructors called <code>S</code> and <code>Z</code> - in other words we have <em>type-level</em> natural numbers. Note that the types <code>S</code> and <code>Z</code> don&#39;t have any member values - only types of kind <code>*</code> are inhabited by values.</p><p>Now we introduce a <a href="http://en.wikibooks.org/wiki/Haskell/GADT" rel="noreferrer">GADT</a> representing vectors with a known length. Note the kind signature: <code>Vec</code> requires a type <em>of kind <code>Nat</code></em> (ie a <code>Z</code> or an <code>S</code> type) to represent its length.</p><pre><code>data Vec :: Nat -&gt; * -&gt; * where
    VNil :: Vec Z a
    VCons :: a -&gt; Vec n a -&gt; Vec (S n) a
deriving instance (Show a) =&gt; Show (Vec n a)
deriving instance Functor (Vec n)
deriving instance Foldable (Vec n)
deriving instance Traversable (Vec n)
</code></pre><p>The definition of vectors is similar to that of linked lists, with some extra type-level information about its length. A vector is either <code>VNil</code>, in which case it has a length of <code>Z</code>(ero), or it&#39;s a <code>VCons</code> cell adding an item to another vector, in which case its length is one more than the other vector (<code>S n</code>). Note that there&#39;s no constructor argument of type <code>n</code>. It&#39;s just used at compile time to track lengths, and will be erased before the compiler generates machine code.</p><p>We&#39;ve defined a vector type which carries around static knowledge of its length. Let&#39;s query the type of a few <code>Vec</code>s to get a feel for how they work:</p><pre><code>ghci&gt; :t (VCons &#39;a&#39; (VCons &#39;b&#39; VNil))
(VCons &#39;a&#39; (VCons &#39;b&#39; VNil)) :: Vec (&#39;S (&#39;S &#39;Z)) Char  -- (S (S Z)) means 2
ghci&gt; :t (VCons 13 (VCons 11 (VCons 3 VNil)))
(VCons 13 (VCons 11 (VCons 3 VNil))) :: Num a =&gt; Vec (&#39;S (&#39;S (&#39;S &#39;Z))) a  -- (S (S (S Z))) means 3
</code></pre><hr/><p>The dot product proceeds just as it would for a list:</p><pre><code>-- note that the two Vec arguments are declared to have the same length
vap :: Vec n (a -&gt; b) -&gt; Vec n a -&gt; Vec n b
vap VNil VNil = VNil
vap (VCons f fs) (VCons x xs) = VCons (f x) (vap fs xs)

zipWith :: (a -&gt; b -&gt; c) -&gt; Vec n a -&gt; Vec n b -&gt; Vec n c
zipWith f xs ys = fmap f xs `vap` ys

dot :: Num a =&gt; Vec n a -&gt; Vec n a -&gt; a
dot xs ys = foldr (+) 0 $ zipWith (*) xs ys
</code></pre><p><code>vap</code>, which &#39;zippily&#39; applies a vector of functions to a vector of arguments, is <code>Vec</code>&#39;s applicative <code>&lt;*&gt;</code>; I didn&#39;t put it in an <code>Applicative</code> instance because <a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/hasochism.pdf" rel="noreferrer">it gets messy</a>. Note also that I&#39;m using the <code>foldr</code> from the compiler-generated instance of <code>Foldable</code>.</p><p>Let&#39;s try it out:</p><pre><code>ghci&gt; let v1 = VCons 2 (VCons 1 VNil)
ghci&gt; let v2 = VCons 4 (VCons 5 VNil)
ghci&gt; v1 `dot` v2
13
ghci&gt; let v3 = VCons 8 (VCons 6 (VCons 1 VNil))
ghci&gt; v1 `dot` v3
&lt;interactive&gt;:20:10:
    Couldn&#39;t match type ‘&#39;S &#39;Z’ with ‘&#39;Z’
    Expected type: Vec (&#39;S (&#39;S &#39;Z)) a
      Actual type: Vec (&#39;S (&#39;S (&#39;S &#39;Z))) a
    In the second argument of ‘dot’, namely ‘v3’
    In the expression: v1 `dot` v3
</code></pre><p>Great! You get a compile-time error when you try to <code>dot</code> vectors whose lengths don&#39;t match.</p><hr/><p>Here&#39;s an attempt at a function to concatenate vectors together:</p><pre><code>-- This won&#39;t compile because the type checker can&#39;t deduce the length of the returned vector
-- VNil +++ ys = ys
-- (VCons x xs) +++ ys = VCons x (concat xs ys)
</code></pre><p>The length of the output vector would be the <em>sum</em> of the lengths of the two input vectors. We need to teach the type checker how to add <code>Nat</code>s together. For this we use a <a href="https://wiki.haskell.org/GHC/Type_families" rel="noreferrer">type-level function</a>:</p><pre><code>type family (n :: Nat) :+: (m :: Nat) :: Nat where
    Z :+: m = m
    (S n) :+: m = S (n :+: m)
</code></pre><p>This <code>type family</code> declaration introduces a <em>function on types</em> called <code>:+:</code> - in other words, it&#39;s a recipe for the type checker to calculate the sum of two natural numbers. It&#39;s defined recursively - whenever the left operand is greater than <code>Z</code>ero we add one to the output and reduce it by one in the recursive call. (It&#39;s a good exercise to write a type function which multiplies two <code>Nat</code>s.) Now we can make <code>+++</code> compile:</p><pre><code>infixr 5 +++
(+++) :: Vec n a -&gt; Vec m a -&gt; Vec (n :+: m) a
VNil +++ ys = ys
(VCons x xs) +++ ys = VCons x (concat xs ys)
</code></pre><p>Here&#39;s how you use it:</p><pre><code>ghci&gt; VCons 1 (VCons 2 VNil) +++ VCons 3 (VCons 4 VNil)
VCons 1 (VCons 2 (VCons 3 (VCons 4 VNil)))
</code></pre><hr/><p>So far so simple. What about when we want to do the opposite of concatenation and split a vector in two? The lengths of the output vectors depend on the runtime value of the arguments. We&#39;d like to write something like this:</p><pre><code>-- this won&#39;t work because there aren&#39;t any values of type `S` and `Z`
-- split :: (n :: Nat) -&gt; Vec (n :+: m) a -&gt; (Vec n a, Vec m a)
</code></pre><p>but unfortunately Haskell won&#39;t let us do that. Allowing the <em>value</em> of the <code>n</code> argument to appear in the <em>return type</em> (this is commonly called a <em>dependent function</em> or <em>pi type</em>) would require &#34;full-spectrum&#34; dependent types, whereas <code>DataKinds</code> only gives us promoted type constructors. To put it another way, the type constructors <code>S</code> and <code>Z</code> don&#39;t appear at the value level. We&#39;ll have to settle for <a href="https://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf" rel="noreferrer"><em>singleton values</em></a> for a run-time representation of a certain <code>Nat</code>.*</p><pre><code>data Natty (n :: Nat) where
    Zy :: Natty Z  -- pronounced &#39;zed-y&#39;
    Sy :: Natty n -&gt; Natty (S n)  -- pronounced &#39;ess-y&#39;
deriving instance Show (Natty n)
</code></pre><p>For a given type <code>n</code> (with kind <code>Nat</code>), there is precisely one term of type <code>Natty n</code>. We can use the singleton value as a run-time witness for <code>n</code>: learning about a <code>Natty</code> teaches us about its <code>n</code> and vice versa.</p><pre><code>split :: Natty n -&gt;
         Vec (n :+: m) a -&gt;  -- the input Vec has to be at least as long as the input Natty
         (Vec n a, Vec m a)
split Zy xs = (Nil, xs)
split (Sy n) (Cons x xs) = let (ys, zs) = split n xs
                           in (Cons x ys, zs)
</code></pre><p>Let&#39;s take it for a spin:</p><pre><code>ghci&gt; split (Sy (Sy Zy)) (VCons 1 (VCons 2 (VCons 3 VNil)))
(VCons 1 (VCons 2 VNil), VCons 3 VNil)
ghci&gt; split (Sy (Sy Zy)) (VCons 3 VNil)
&lt;interactive&gt;:116:21:
    Couldn&#39;t match type ‘&#39;S (&#39;Z :+: m)’ with ‘&#39;Z’
    Expected type: Vec (&#39;S (&#39;S &#39;Z) :+: m) a
      Actual type: Vec (&#39;S &#39;Z) a
    Relevant bindings include
      it :: (Vec (&#39;S (&#39;S &#39;Z)) a, Vec m a) (bound at &lt;interactive&gt;:116:1)
    In the second argument of ‘split’, namely ‘(VCons 3 VNil)’
    In the expression: split (Sy (Sy Zy)) (VCons 3 VNil)
</code></pre><p>In the first example, we successfully split a three-element vector at position 2; then we got a type error when we tried to split a vector at a position past the end. Singletons are the standard technique for making a type depend on a value in Haskell.</p><p><sub>* The <a href="https://hackage.haskell.org/package/singletons" rel="noreferrer"><code>singletons</code> library</a> contains some Template Haskell helpers to generate singleton values like <code>Natty</code> for you.</sub></p><hr/><p>Last example. What about when you don&#39;t know the dimensionality of your vector statically? For example, what if we&#39;re trying to build a vector from run-time data in the form of a list? You need the <em>type</em> of the vector to depend on the <em>length</em> of the input list. To put it another way, we can&#39;t use <code>foldr VCons VNil</code> to build a vector because the type of the output vector changes with each iteration of the fold. We need to keep the length of the vector a secret from the compiler.</p><pre><code>data AVec a = forall n. AVec (Natty n) (Vec n a)
deriving instance (Show a) =&gt; Show (AVec a)

fromList :: [a] -&gt; AVec a
fromList = Prelude.foldr cons nil
    where cons x (AVec n xs) = AVec (Sy n) (VCons x xs)
          nil = AVec Zy VNil
</code></pre><p><code>AVec</code> is an <a href="https://wiki.haskell.org/Existential_type" rel="noreferrer"><em>existential type</em></a>: the type variable <code>n</code> does not appear in the return type of the <code>AVec</code> data constructor. We&#39;re using it to simulate a <a href="http://en.wikipedia.org/wiki/Dependent_type#Dependent_pair_type" rel="noreferrer"><em>dependent pair</em></a>: <code>fromList</code> can&#39;t tell you the length of the vector statically, but it can return something you can pattern-match on to <em>learn</em> the length of the vector - the <code>Natty n</code> in the first element of the tuple. As Conor McBride puts it in <a href="https://stackoverflow.com/a/27030038/1523776">a related answer</a>, &#34;You look at one thing, and in doing so, learn about another&#34;.</p><p>This is a common technique for existentially quantified types. Because you can&#39;t actually do anything with data for which you don&#39;t know the type - try writing a function of <code>data Something = forall a. Sth a</code> - existentials often come bundled up with GADT evidence which allows you to recover the original type by performing pattern-matching tests. Other common patterns for existentials include packaging up functions to process your type (<code>data AWayToGetTo b = forall a. HeresHow a (a -&gt; b)</code>) which is a neat way of doing first-class modules, or building-in a type class dictionary (<code>data AnOrd = forall a. Ord a =&gt; AnOrd a</code>) which can help emulate subtype polymorphism.</p><pre><code>ghci&gt; fromList [1,2,3]
AVec (Sy (Sy (Sy Zy))) (VCons 1 (VCons 2 (VCons 3 Nil)))
</code></pre><p>Dependent pairs are useful whenever the static properties of data depend on dynamic information not available at compile time. Here&#39;s <code>filter</code> for vectors:</p><pre><code>filter :: (a -&gt; Bool) -&gt; Vec n a -&gt; AVec a
filter f = foldr (\x (AVec n xs) -&gt; if f x
                                    then AVec (Sy n) (VCons x xs)
                                    else AVec n xs) (AVec Zy VNil) 
</code></pre><p>To <code>dot</code> two <code>AVec</code>s, we need to prove to GHC that their lengths are equal. <a href="https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Type-Equality.html" rel="noreferrer"><code>Data.Type.Equality</code></a> defines a GADT which can only be constructed when its type arguments are the same:</p><pre><code>data (a :: k) :~: (b :: k) where
    Refl :: a :~: a  -- short for &#39;reflexivity&#39;
</code></pre><p>When you pattern-match on <code>Refl</code>, GHC knows that <code>a ~ b</code>. There are also a few functions to help you work with this type: we&#39;ll be using <a href="https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Type-Equality.html#g:2" rel="noreferrer"><code>gcastWith</code></a> to convert between equivalent types, and <a href="https://hackage.haskell.org/package/base-4.7.0.2/docs/Data-Type-Equality.html#g:3" rel="noreferrer"><code>TestEquality</code></a> to determine whether two <code>Natty</code>s are equal.</p><p>To test the equality of two <code>Natty</code>s, we&#39;re going to need to make use of the fact that if two numbers are equal, then their successors are also equal (<code>:~:</code> is <em>congruent</em> over <code>S</code>):</p><pre><code>congSuc :: (n :~: m) -&gt; (S n :~: S m)
congSuc Refl = Refl
</code></pre><p>Pattern matching on <code>Refl</code> on the left-hand side lets GHC know that <code>n ~ m</code>. With that knowledge, it&#39;s trivial that <code>S n ~ S m</code>, so GHC lets us return a new <code>Refl</code> right away.</p><p>Now we can write an instance of <code>TestEquality</code> by straightforward recursion. If both numbers are zero, they are equal. If both numbers have predecessors, they are equal iff the predecessors are equal. (If they&#39;re not equal, just return <code>Nothing</code>.)</p><pre><code>instance TestEquality Natty where
    -- testEquality :: Natty n -&gt; Natty m -&gt; Maybe (n :~: m)
    testEquality Zy Zy = Just Refl
    testEquality (Sy n) (Sy m) = fmap congSuc (testEquality n m)  -- check whether the predecessors are equal, then make use of congruence
    testEquality Zy _ = Nothing
    testEquality _ Zy = Nothing
</code></pre><p>Now we can put the pieces together to <code>dot</code> a pair of <code>AVec</code>s of unknown length.</p><pre><code>dot&#39; :: Num a =&gt; AVec a -&gt; AVec a -&gt; Maybe a
dot&#39; (AVec n u) (AVec m v) = fmap (\proof -&gt; gcastWith proof (dot u v)) (testEquality n m)
</code></pre><p>First, pattern match on the <code>AVec</code> constructor to pull out a runtime representation of the vectors&#39; lengths. Now use <code>testEquality</code> to determine whether those lengths are equal. If they are, we&#39;ll have <code>Just Refl</code>; <code>gcastWith</code> will use that equality proof to ensure that <code>dot u v</code> is well-typed by discharging its implicit <code>n ~ m</code> assumption.</p><pre><code>ghci&gt; let v1 = fromList [1,2,3]
ghci&gt; let v2 = fromList [4,5,6]
ghci&gt; let v3 = fromList [7,8]
ghci&gt; dot&#39; v1 v2
Just 32
ghci&gt; dot&#39; v1 v3
Nothing  -- they weren&#39;t the same length
</code></pre><p>Note that, since a vector without static knowledge of its length is basically a list, we&#39;ve effectively re-implemented the list version of <code>dot :: Num a =&gt; [a] -&gt; [a] -&gt; Maybe a</code>. The difference is that this version is implemented in terms of the vectors&#39; <code>dot</code>. Here&#39;s the point: before the type checker will allow you to call <code>dot</code>, <strong>you must have tested</strong> whether the input lists have the same length using <code>testEquality</code>. I am prone to getting <code>if</code>-statements the wrong way round, but not in a dependently-typed setting!</p><p>You can&#39;t avoid using existential wrappers at the edges of your system, when you&#39;re dealing with runtime data, but you can use dependent types everywhere inside your system and keep the existential wrappers at the edges, when you perform input validation.</p><p>Since <code>Nothing</code>is not very informative, you could further refine the type of <code>dot&#39;</code> to return <em>a proof that the lengths aren&#39;t equal</em> (in the form of evidence that their difference is not 0) in the failure case. This is pretty similar to the standard Haskell technique of using <code>Either String a</code> to possibly return an error message, although a proof term is far more computationally useful than a string!</p><hr/><p>Thus ends this whistle-stop tour of some of the techniques that are common in dependently-typed Haskell programming. Programming with types like this in Haskell is really cool, but really awkward at the same time. Breaking up all your dependent data into lots of representations which mean the same thing - <code>Nat</code> the type, <code>Nat</code> the kind, <code>Natty n</code> the singleton - is really quite cumbersome, despite the existence of code-generators to help with the boilerplate. There are also presently limitations on what can be promoted to the type level. It&#39;s tantalising though! The mind boggles at the possibilities - in the literature there are examples in Haskell of strongly typed <code>printf</code>, database interfaces, UI layout engines...</p><p>If you want some further reading, there&#39;s a growing body of literature about dependently typed Haskell, both published and on sites like Stack Overflow. A good starting point is <a href="https://personal.cis.strath.ac.uk/conor.mcbride/pub/hasochism.pdf" rel="noreferrer">the <em>Hasochism</em> paper</a> - the paper goes through this very example (among others), discussing the painful parts in some detail. <a href="https://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf" rel="noreferrer">The <em>Singletons</em> paper</a> demonstrates the technique of singleton values (such as <code>Natty</code>). For more information about dependent typing in general, the <a href="http://www.cse.chalmers.se/~ulfn/darcs/AFP08/LectureNotes/AgdaIntro.pdf" rel="noreferrer">Agda</a> tutorial is a good place to start; also, <a href="http://eb.host.cs.st-andrews.ac.uk/writings/idris-tutorial.pdf" rel="noreferrer">Idris</a> is a language in development that&#39;s (roughly) designed to be &#34;Haskell with dependent types&#34;.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../why-doesnt-haskell-have-type-level-lambda-abstractions/'>Why doesn&#8217;t Haskell have type-level lambda abstractions</a></li><li class="list-group-item"><a href='../what-are-the-safety-benefits-of-a-type-system/'>What are the safety benefits of a type system</a></li><li class="list-group-item"><a href='../type-checking-and-recursive-types-writing-the-y-combinator-in-haskell-ocaml/'>Type checking and recursive types (Writing the Y combinator in Haskell/Ocaml)</a></li><li class="list-group-item"><a href='../are-types-erased-in-haskell/'>Are types erased in Haskell</a></li><li class="list-group-item"><a href='../type-inference-in-golang-haskell/'>Type inference in Golang/Haskell</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>