<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Can a pimpl variation be implemented without any performance penalty &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1071950 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1071950" class="post-1071950 software type-software status-publish hentry category-software tag-c11 tag-design-patterns tag-optimization tag-performance"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Can a pimpl variation be implemented without any performance penalty</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c++11</span><span class="mr-2 badge badge-info">design-patterns</span><span class="mr-2 badge badge-warning">optimization</span><span class="mr-2 badge badge-primary">performance</span></p><div class="entry-content"><p>One of the issues of pimpl is the performance penalty of using it (additional memory allocation, non-contiguous data members, additional indirections, etc..). I would like to propose a variation on the pimpl idiom that will avoid these performance penalties at the expense of not getting all the benefits of pimpl. The idea is to leave all private data members in the class itself and move only the private methods to the pimpl class.<br /> The benefit compared to basic pimpl is that the memory remains contiguous (no additional indirection). The benefits compared to not using pimpl at all are:</p><ol><li>It hides the private functions.</li><li>You can structure it so that all these functions will have internal linkage and allow the compiler to more aggressively optimize it.</li></ol><p>So my idea is to make the pimpl inherit from the class itself (sounds a bit crazy I know, but bear with me).<br /> It would look something like this:</p><p>In A.h file:</p><pre><code>class A
{
    A();
    void DoSomething();
protected:  //All private stuff have to be protected now
    int mData1;
    int mData2;
//Not even a mention of a PImpl in the header file :)
};
</code></pre><p>In A.cpp file:</p><pre><code>#define PCALL (static_cast&lt;PImpl*&gt;(this))

namespace //anonymous - guarantees internal linkage
{
struct PImpl : public A
{
    static_assert(sizeof(PImpl) == sizeof(A), 
                  &#34;Adding data members to PImpl - not allowed!&#34;);
    void DoSomething1();
    void DoSomething2();
    //No data members, just functions!
};

void PImpl::DoSomething1()
{
    mData1 = bar(mData2); //No Problem: PImpl sees A&#39;s members as it&#39;s own
    DoSomething2();
}

void PImpl::DoSomething2()
{
    mData2 = baz();
}

}
A::A(){}

void A::DoSomething()
{
    mData2 = foo();
    PCALL-&gt;DoSomething1(); //No additional indirection, everything can be completely inlined
}
</code></pre><p>As far as I see there are absolutely no performance penalties in using this vs no pimpl and some possible performance gains and cleaner header file interface. One disadvantage this has vs standard pimpl is that you can&#39;t hide the data members so changes to those data members will still trigger a recompilation of everything that depends on the header file. But the way I see it, it&#39;s either get that benefit or the performance benefit of having the members contiguous in memory (or do <a href="http://www.gotw.ca/gotw/028.htm" rel="nofollow">this hack</a> &#8211; &#34;Why Attempt #3 is Deplorable&#34;). Another caveat is that if A is a templated class the syntax gets annoying (you know, you can&#39;t use mData1 directly, you need to do this-&gt;mData1, and you need to start using the typename and maybe template keywords for dependent types and templated types, etc.). Yet another caveat is that you can no longer use private in the original class, only protected members, so you can&#39;t restrict access from any inheriting class, no just the pimpl. I tried but couldn&#39;t get around this issue. For example, I tried making the pimpl a friend template class in the hopes of making the friend declaration broad enough to allow me to define the actual pimpl class in an anonymous namespace, but that just doesn&#39;t work. If anyone has any idea of how to keep the data members private and still allow an inheriting pimpl class defined in an anonymous namepsace to access those, I&#39;d really like to see it! That would eliminate my main reservation from using this.</p><p>I feel though, that these caveats are acceptable for the benefits of what I propose.</p><p>I tried looking online for some reference to this &#34;function-only pimpl&#34; idiom but couldn&#39;t find anything. I&#39;m really interested in what people think about this. Are there other issues with this or reasons I shouldn&#39;t use this?</p><p>UPDATE:</p><p>I&#39;ve found <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3863.html" rel="nofollow">this proposal</a> that more or less tries to accomplish exactly what I am, but doing so by changing the standard. I completely agree with that proposal and hope it will make it into the standard (I know nothing of that process so I have no idea of how likely that&#39;s to happen). I&#39;d much rather have it possible to do this through a built in language mechanism. The proposal also explains the benefits of what I&#39;m trying to achieve much better than me. It also doesn&#39;t have the issue of breaking encapsulation like my suggestion has (private -&gt; protected). Still, until that proposal makes it into the standard (if that ever happens), I think my suggestion makes it possible to get those benefits, with the caveats I listed.</p><p>UPDATE2:</p><p>One of the answers mentions LTO as a possible alternative to getting some of the benefits (more aggressive optimizations I&#39;m guessing). I&#39;m not really sure exactly what goes on in various compiler optimization passes but I do have a bit of experience with the resulting code (I use gcc). Simply putting the private methods in the original class will force those to have external linkage.</p><p>I might be wrong here, but the way I interpret that is that the compile-time optimizer cannot eliminate the function even if all its call instances are completely inlined inside that TU. For some reason even LTO refuses to get rid of the function definition even if it seems that all the call instances in the entire linked binary are all inlined. I found some references stating that it&#39;s because the linker doesn&#39;t know if you&#39;ll somehow still call the function using function pointers (though I don&#39;t understand why the linker can&#39;t figure out that the address of that method is never taken).</p><p>This is not the case if you use my suggestion and put those private methods in a pimpl inside an anonymous namespace. If those get inlined, the functions will NOT appear in (with -O3, that includes -finline-functions) the object file.</p><p>The way I understand it, the optimizer, when deciding whether or not to inline a function, takes into account its impact on code size. So, using my suggestion I&#39;m making it slightly &#34;cheaper&#34; for the optimizer to inline those private methods.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>The selling points of the Pimpl pattern are:</p><ul><li>total encapsulation: there are no (private) data members mentioned in the header file of the interface object.</li><li>stability: until you break the public interface (which in C++ includes private members), you&#39;ll never have to recompile code that depends on the interface object. This makes the Pimpl a great pattern for libraries that don&#39;t want their users to recompile all code on every internal change.</li><li>polymorphism and dependency injection: the implementation or behaviour of the interface object can be easily swapped out at runtime, without requiring dependent code to be recompiled. Great if you need to mock something for an unit test.</li></ul><p>To this effect, the classic Pimpl consists of three parts:</p><ul><li><p>An interface for the implementation object, which must be public, and use virtual methods for the interface:</p><pre class="lang-cpp prettyprint-override"><code>class IFrobnicateImpl
{
public:
    virtual int frobnicate(int) const = 0;
};
</code></pre><p>This interface is required to be stable.</p></li><li><p>An interface object that proxies to the private implementation. It does not have to use virtual methods. The only allowed member is a pointer to the implementation:</p><pre class="lang-cpp prettyprint-override"><code>class Frobnicate
{
    std::unique_ptr&lt;IFrobnicateImpl&gt; _impl;
public:
    explicit Frobnicate(std::unique_ptr&lt;IFrobnicateImpl&gt;&amp;&amp; impl = nullptr);
    int frobnicate(int x) const { return _impl-&gt;frobnicate(x); }
};

...

Frobnicate::Frobnicate(std::unique_ptr&lt;IFrobnicateImpl&gt;&amp;&amp; impl /* = nullptr */)
: _impl(std::move(impl))
{
    if (!_impl)
        _impl = std::make_unique&lt;DefaultImplementation&gt;();
}
</code></pre><p>The header file of this class must be stable.</p></li><li><p>At least one implementation</p></li></ul><p>The Pimpl then buys us a great deal of stability for a library class, at the cost of one heap allocation and additional virtual dispatch.</p><p>How does your solution measure up?</p><ul><li>It does away with encapsulation. Since your members are protected, any subclass can mess with them.</li><li>It does away with interface stability. Whenever you change your data members – and that change is just one refactoring away – you&#39;ll have to recompile all dependent code.</li><li>It does away with the virtual dispatch layer, preventing easy swapping of the implementation.</li></ul><p>So for every objective of the Pimpl pattern, you fail to fulfil this objective. It is therefore not reasonable to call your pattern a variation of the Pimpl, it is much more an ordinary class. Actually, it&#39;s worse than an ordinary class because your member variables are private. And because of that cast which is a glaring point of fragility.</p><p>Note that the Pimpl pattern is not always optimal – there&#39;s a tradeoff between stability and polymorphism on the one hand, and memory compactness on the other. It is semantically impossible for a language to have both (without JIT compilation). So if you&#39;re micro-optimizing for memory compactness, clearly the Pimpl is not a suitable solution for your use case. You&#39;ll also probably stop using half the standard library, since these awful string and vector classes involve dynamic memory allocations ;-)</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-the-exact-syntax-of-inline/'>C++ &#8211;  the exact syntax of inline</a></li><li class="list-group-item"><a href='../whats-is-the-point-of-pimpl-pattern-while-we-can-use-interface-for-the-same-purpose-in-c/'>What&#8217;s is the point of PImpl pattern while we can use interface for the same purpose in C++</a></li><li class="list-group-item"><a href='../object-oriented-are-first-class-functions-a-substitute-for-the-strategy-pattern/'>Object-oriented &#8211; Are first-class functions a substitute for the Strategy pattern</a></li><li class="list-group-item"><a href='../how-to-add-link-time-optimization-capabilities-to-the-llvm-based-compiler/'>How to add link-time optimization capabilities to the LLVM-based compiler</a></li><li class="list-group-item"><a href='../c-do-i-get-valid-profiling-results-with-optimization-turned-off/'>C++ &#8211; Do I get valid profiling results with optimization turned off</a></li><li class="list-group-item"><a href='../c-why-is-accessing-virtual-protected-functions-of-a-base-class-not-allowed-through-a-pointer-of-the-base-class-type-inside-a-derived-class/'>C++ &#8211; Why is accessing virtual protected functions of a base class not allowed through a pointer of the base class type inside a derived class</a></li><li class="list-group-item"><a href='../object-oriented-abstract-base-class-with-only-protected-members/'>Object-oriented &#8211; Abstract base class with only protected members</a></li><li class="list-group-item"><a href='../object-oriented-using-friend-classes-to-encapsulate-private-member-functions-in-c-good-practice-or-abuse/'>Object-oriented &#8211; Using friend classes to encapsulate private member functions in C++ &#8211; good practice or abuse</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>