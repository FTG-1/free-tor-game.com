<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; OOP ECS vs Pure ECS &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1070576 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1070576" class="post-1070576 software type-software status-publish hentry category-software tag-design-patterns tag-entity-component-system tag-game-development tag-object-oriented"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; OOP ECS vs Pure ECS</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">design-patterns</span><span class="mr-2 badge badge-info">entity-component-system</span><span class="mr-2 badge badge-warning">game development</span><span class="mr-2 badge badge-primary">object-oriented</span></p><div class="entry-content"><p>Firstly, I am aware that this question links with the topic of game development but I have decided to ask it here since it really comes down to a more general software engeneering problem.</p><p>During the past month, I have read a lot about Entity-Component-Systems and now are quite comfortable with the concept. However, there is one aspect that seems to be missing a clear &#39;definition&#39; and different articles have suggested radically different solutions:</p><p>This is the question of whether an ECS should break encapsulation or not. In other words its the <em>OOP style ECS</em> (components are objects with both state and behaivour that encapsulate the data specific to them) vs the <em>pure ECS</em> (components are c style structs that only have public data and systems provide the functionality).</p><p>Note that I am developping a Framework / API / Engine. So the goal is that it can easily be extended by whoever is using it. This includes stuff like adding a new type of render or collision component.</p><h2>Problems with the OOP approach</h2><ul><li><p>Components must access data of other components. E.g. the render component&#39;s draw method must access the transform component&#39;s position. This creates dependencies in code.</p></li><li><p>Components can be polymorphic which further introduces some complexity. E.g. There might be a sprite render component that overrides the render component&#39;s virtual draw method.</p></li></ul><h2>Problems with the pure approach</h2><ul><li><p>Since the polymorphic behaivour (e.g. for rendering) has to be implemented somewhere, it is just outsourced into the systems. (e.g. the sprite render system creates a sprite render node that inherits render node and adds it to the render engine)</p></li><li><p>The communication between systems can be difficult to avoid. E.g. the collision system might need the bounding box which is calculated from whatever concrete render component there is. This can be solved by letting them communicate via data. However, this removes instant updates since the render system would update the bounding box component and the collision system would then use it. This may lead to preblems if the order of calling the system&#39;s update functions is not defined. There is an event system in place that allows for systems to raise events that other systems can subscribe their handlers to. However, this only works for telling systems what to do i.e. void functions.</p></li><li><p>There are additional flags needed. Take a tile map component for example. It would have a size, tile size and index list field. The tile map system would handle the respective vertex array and assign the texture coordinates based on the component&#39;s data. However, recalculating the entire tilemap every frame is expensive. Therefore, a list would be needed to keep track of all the changes made to then update them in the system. In the OOP way this could be encapsulated by the tile map component. E.g. the SetTile() method would update the vertex array whenever its called.</p></li></ul><p>Although I see the beauty of the pure approach, I don&#39;t really understand what kind of concrete benefits it would have over a more traditional OOP. The dependencies between components still exist although being hidden away in the systems. Also I would need a lot more classes to accomplish the same goal. This seems to me like a somewhat over engineered solution which is never a good thing.</p><p>Furthermore, I am not that interrested in performance so this whole idea of data-oriented design and cashe misses doesn&#39;t really matter to me. I just want a nice architecture ^^</p><p>Still, most of the articles and discussion I read suggest the second approach. <strong>WHY?</strong></p><h2>Animation</h2><p>Lastly, I want to ask the question of how I would handle animation in a pure ECS. Currently I have defined an animation as a functor that manipulates an entity based on some progress between 0 and 1. The animation component has a list of animators which has a list of animations. In its update function it then applies whatever animations are currently active to the entity.</p><p><strong>Note:</strong></p><p>I have just read this post <a href="https://softwareengineering.stackexchange.com/questions/211708/is-the-entity-component-system-architecture-object-oriented-by-definition?rq=1">Is the Entity Component System architecture object oriented by definition?</a> which explains the problem a bit better than I do. Although basically being on the same topic it still doesn&#39;t give any answers <strong>as to why</strong> the pure data approach is better.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>This is a tough one. I&#39;ll just try to tackle some of the questions based on my particular experiences (YMMV):</p><blockquote><blockquote><p>Components must access data of other components. E.g. the render component&#39;s draw method must access the transform component&#39;s position. This creates dependencies in code.</p></blockquote></blockquote><p>Don&#39;t underestimate the amount and complexity (not degree) of coupling/dependencies here. You could be looking at the difference between this (and this diagram is already ridiculously simplified to toy-like levels, and the real-world example would have interfaces in between to loosen the coupling):</p><p><a href="../../../i.stack.imgur.com/Vpzop.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/Vpzop.png" alt="enter image description here"/></a></p><p>... and this:</p><p><a href="../../../i.stack.imgur.com/lNYsk.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/lNYsk.png" alt="enter image description here"/></a></p><p>... or this:</p><p><a href="../../../i.stack.imgur.com/JL6Gq.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/JL6Gq.png" alt="enter image description here"/></a></p><blockquote><blockquote><p>Components can be polymorphic which further introduces some complexity. E.g. There might be a sprite render component that overrides the render component&#39;s virtual draw method.</p></blockquote></blockquote><p>So? The analogical (or literal) equivalent of a vtable and virtual dispatch can be invoked via the system rather than the object hiding its underlying state/data. Polymorphism is still very practical and feasible with the &#34;pure&#39; ECS implementation when the analogical vtable or function pointer(s) turns into &#34;data&#34; of sorts for the system to invoke.</p><blockquote><blockquote><p>Since the polymorphic behaivour (e.g. for rendering) has to be implemented somewhere, it is just outsourced into the systems. (e.g. the sprite render system creates a sprite render node that inherits render node and adds it to the render engine)</p></blockquote></blockquote><p>So? I hope this is not coming off as sarcasm (not my intent though I&#39;ve been accused of it often but I wish I could communicate emotions better through text), but &#34;outsourcing&#34; polymorphic behavior in this case doesn&#39;t necessarily incur an additional cost to productivity.</p><blockquote><blockquote><p>The communication between systems can be difficult to avoid. E.g. the collision system might need the bounding box which is calculated from whatever concrete render component there is.</p></blockquote></blockquote><p>This example seems particularly weird to me. I don&#39;t know why a renderer would be outputting data back to the scene (I generally consider renderers read-only in this context), or for a renderer to be figuring out AABBs instead of some other system to do this for both renderer and collision/physics (I might be getting hung up on the &#34;render component&#34; name here). Yet I don&#39;t want to get too hung up on this example since I realize that&#39;s not the point you&#39;re trying to make. Still the communication between systems (even in the indirect form of read/writes to the central ECS database with systems depending rather directly on transformations made by others) shouldn&#39;t need to be frequent, if at all necessary. That&#39;s contradicting some of what I wrote immediately below about the importance of determining order of evaluation upfront but that&#39;s with practical needs for user response rather than &#34;correctness&#34; (it&#39;s not necessarily a temporal coupling issue but a user-end design issue of ensuring frames output the latest results without lagging behind).</p><blockquote><p>This may lead to preblems if the order of calling the system&#39;s update functions is not defined.</p></blockquote><p>This absolutely should be defined. The ECS is not the end-all solution to rearrange system processing evaluation order of every possible system in the codebase and get back exactly same kind of results to the end user dealing with frames and FPS. This is one of the things, when designing an ECS, that I&#39;d at least strongly suggest should be anticipated somewhat upfront (though with a lot of forgiving breathing room to change minds later provided it&#39;s not altering the most critical aspects of the ordering of system invocation/evaluation).</p><blockquote><blockquote><p>However, recalculating the entire tilemap every frame is expensive. Therefore, a list would be needed to keep track of all the changes made to then update them in the system. In the OOP way this could be encapsulated by the tile map component. E.g. the SetTile() method would update the vertex array whenever its called.</p></blockquote></blockquote><p>I didn&#39;t quite understand this one except that it&#39;s a data-oriented concern. And there are no pitfalls as to representing and storing data in an ECS, including memoization, to avoid such performance pitfalls (the biggest ones with an ECS tend to relate to things like systems querying for available instances of particular component types which is one of the most challenging aspects of optimizing a generalized ECS). The fact that logic and data are separated in a &#34;pure&#34; ECS doesn&#39;t mean you suddenly have to recompute things you could have otherwise cached/memoized in an OOP representation. That&#39;s a moot/irrelevant point unless I glossed over something very important.</p><p>With the &#34;pure&#34; ECS you can still store this data in the tile map component. The only major difference is that the logic to update this vertex array would move to a system somewhere.</p><p>You can even lean on the ECS to simplify the invalidation and removal of this cache from the entity if you create a separate component like <code>TileMapCache</code>. At that point when the cache is desired but not available in an entity with a <code>TileMap</code> component, you can compute it and add it. When it&#39;s invalidated or no longer needed, you can remove it through the ECS without having to write more code specifically for such invalidation and removal.</p><blockquote><blockquote><p>The dependencies between components still exist although being hidden away in the systems</p></blockquote></blockquote><p>There&#39;s no dependency between components in a &#34;pure&#34; rep (I don&#39;t think it&#39;s quite right to say that dependencies are being hidden here by the systems). Data doesn&#39;t depend on data, so to speak. Logic depends on logic. And a &#34;pure&#34; ECS tends to promote the logic to be written in a way so as to depend on the absolute minimal subset of data and logic (often none) a system requires to work, which is unlike many alternatives which often encourage depending on far more functionality than required for the actual task. If you&#39;re using the pure ECS right, one of the first things you should appreciate is the decoupling benefits while simultaneously questioning everything you ever learned to appreciate in OOP about encapsulation and specifically information hiding.</p><p>By decoupling I specifically mean how little information your systems need to work. Your motion system doesn&#39;t even need to know about something far more complex like a <code>Particle</code> or <code>Character</code> (the developer of the system doesn&#39;t necessarily even need to know such entity ideas even exist in the system). It just needs to know about the bare minimum data like a position component which could be as simple as a few floats in a struct. It&#39;s even less information and fewer external dependencies than what a pure interface like <code>IMotion</code> tends to carry along with it. It&#39;s primarily due to this minimal knowledge that each system requires to work that makes the ECS often so forgiving to handle very unanticipated design changes in hindsight without facing cascading interface breakages all over the place.</p><p>The &#34;impure&#34; approach you suggest somewhat diminishes that benefit since now your logic isn&#39;t localized strictly to systems where changes don&#39;t cause cascading breakages. The logic would now be centralized to some degree in the components accessed by multiple systems which now have to fulfill interface requirements of all the various systems that could use it, and now it&#39;s like every system then needs to have knowledge of (depend on) more information than it strictly needs to work with that component.</p><p><strong>Dependencies to Data</strong></p><p>One of the things that&#39;s controversial about the ECS is that it tends to replace what might otherwise be dependencies to abstract interfaces with just raw data, and that&#39;s generally considered a less desirable and tighter form of coupling. But in the kinds of domains like games where ECS can be very beneficial, it&#39;s often easier to design the data representation upfront and keep it stable than it is to design what you can do with that data at some central level of the system. That&#39;s something I&#39;ve painfully observed even among seasoned veterans in codebases that utilizes more of a COM-style pure interface approach with things like <code>IMotion</code>.</p><p>The developers kept finding reasons to add, remove, or change functions to this central interface, and each change was ghastly and costly because it would tend to break every single class that implemented <code>IMotion</code> along with every since place in the system that used <code>IMotion</code>. Meanwhile the entire time with so many painful and cascading changes, the objects that implemented <code>IMotion</code> were all just storing a 4x4 matrix of floats and the whole interface was just concerned with how to transform and access those floats; the data representation was stable all the way from the beginning, and a lot of pain could have been avoided if this centralized interface, so prone to change with unanticipated design needs, didn&#39;t even exist in the first place.</p><p>This could all sound almost as disgusting as like global variables but the nature of how the ECS organizes this data into components retrieved explicitly by type through systems makes it so, while compilers can&#39;t enforce anything like information hiding, the places that access and mutate the data are generally very explicit and obvious enough to still effectively maintain invariants and predict what sort of transformations and side effects go on from one system to the next (actually in ways that can arguably be simpler and more predictable than OOP in certain domains given how the system turns into a flat sort of pipeline).</p><p><a href="../../../i.stack.imgur.com/g74hk.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/g74hk.png" alt="enter image description here"/></a></p><blockquote><blockquote><p>Lastly, I want to ask the question of how I would handle animation in a pure ECS. Currently I have defined an animation as a functor that manipulates an entity based on some progress between 0 and 1. The animation component has a list of animators which has a list of animations. In its update function it then applies whatever animations are currently active to the entity.</p></blockquote></blockquote><p>We&#39;re all pragmatists here. Even in gamedev you&#39;ll probably get conflicting ideas/answers. Even the purest ECS is a relatively new phenomena, pioneering territory, for which people haven&#39;t necessarily formulated the strongest opinions on how to skin cats. My gut reaction is an animation system which increments this sort of animation progress in animated components for the rendering system to display, but that&#39;s ignoring so much nuance for the particular application and context.</p><p>With the ECS it&#39;s not a silver bullet and I do still find myself with tendencies to go in and add new systems, remove some, add new components, change an existing system to pick up that new component type, etc. I don&#39;t get things right at all the first time around still. But the difference in my case is that I&#39;m not changing anything central when I fail to anticipate certain design needs upfront. I&#39;m not getting the rippling effect of cascading breakages that require me to go all the over the place and change so much code to handle some new need that crops up, and that&#39;s quite the time saver. I&#39;m also finding it easier on my brain because when I sit down with a particular system, I don&#39;t need to know/remember that much about anything else besides the relevant components (which are just data) to work on it.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../architecture-entity-component-system-architecture-interaction-between-systems/'>Architecture &#8211; Entity-Component-System architecture: interaction between systems</a></li><li class="list-group-item"><a href='../object-oriented-is-the-entity-component-system-architecture-object-oriented-by-definition/'>Object-oriented &#8211; Is the Entity Component System architecture object oriented by definition</a></li><li class="list-group-item"><a href='../design-how-to-allow-for-custom-rules-in-a-entity-component-system-designed-game-engine/'>Design &#8211; How to allow for custom Rules in a Entity Component System designed game engine</a></li><li class="list-group-item"><a href='../c-is-it-a-good-idea-to-experiment-with-design-patterns/'>C++ &#8211; Is it a good idea to experiment with design patterns</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>