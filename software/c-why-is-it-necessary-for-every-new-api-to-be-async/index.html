<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C# &#8211; Why is it necessary for every new api to be async &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1079517 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1079517" class="post-1079517 software type-software status-publish hentry category-software tag-net-core tag-async tag-asynchronous-programming tag-c tag-programming-languages"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C# &#8211; Why is it necessary for every new api to be async</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">.net core</span><span class="mr-2 badge badge-info">async</span><span class="mr-2 badge badge-warning">asynchronous-programming</span><span class="mr-2 badge badge-primary">c</span><span class="mr-2 badge badge-danger">programming-languages</span></p><div class="entry-content"><p>I&#39;m expressing my frustration here somewhat, but why do many new libraries only have asynchronous APIs?  For example I&#39;m creating a small utility to fetch a web page and parse some data from it.  However, making use of HttpClient from the System.Net.Http namespace in .net core requires a lot of async and await boilerplate code, from this <a href="https://dotnetcoretutorials.com/2018/02/27/loading-parsing-web-page-net-core/" rel="noreferrer">web page</a> for example:</p><pre><code>async static Task Main(string[] args)
{
}
</code></pre><p>Then the contents of Main:</p><pre><code>HttpClient client = new HttpClient();
var response = await client.GetAsync(&#34;http://www.nzherald.co.nz/&#34;);
var pageContents = await response.Content.ReadAsStringAsync();
Console.WriteLine(pageContents);
Console.ReadLine();
</code></pre><p>I feel that c# has become a very wordy language and I&#39;m not happy to have to  code in the async style like this.  I have been writing c# programs since .net 1.0, and I find it hard to reason about what is happening behind the scenes of the compiler: is creation of threads for async code going to impact performance?  How can I throttle the rate of calls if I&#39;m calling GetAsync in a loop?</p><p>My Question is: has the c# team gone in the right direction creating this async paradigm in the language?  I feel that go&#39;s approach of creating a thread by just saying <code>go myfunction()</code> is less long-winded, but I know it has it&#39;s performance penalties due to the green-threads used.</p><p>Look at <a href="https://softwareengineering.stackexchange.com/questions/206683/when-is-it-necessary-or-when-should-a-controller-be-async?rq=1">this question</a> for example, it has the same type of concerns about async, and the single answer isn&#39;t very helpful.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>I feel that c# has become a very wordy language and I&#39;m not happy to have to code in the async style like this.</p></blockquote><p>Oh, but that is not wordy at all. You are not writting something like this:</p><pre><code>client.GetAsync(&#34;http://www.nzherald.co.nz/&#34;).Then
(
    response =&gt; response.Content.ReadAsStringAsync().Then
    (
        pageContents =&gt;
        {
            Console.WriteLine(pageContents);
            Console.ReadLine();
        }
    )
);
</code></pre><p><em>And an API like the one above (probably a wrapper around <code>ContinueWith</code>) it won&#39;t handle exceptions properly, you would probably need an <code>Error</code> method with a callback to get the exceptions.</em></p><p>No, C# is not wordy.</p><p><strong>Addendum</strong>: perhaps it is worth mentioning that if an <code>async</code> method returns a <code>Task</code>, it does not means you have to <code>await</code> it. If you want the <code>Task</code> to do something else with it (for example place it an array for <code>Task.WaitAll</code> or <code>Task.WhenAll</code>), you do not put the <code>await</code> keyword. Therefore, the <code>await</code> keyword is not redundant.</p><hr/><blockquote><p>is creation of threads for async code going to impact performance?</p></blockquote><p>No. Although some API do actually need to block on a <code>Thread</code> – and I think that is the case for listening on a socket, at least on Windows – it will use the <code>ThreadPool</code>, thus there won&#39;t be a lot of new <code>Thread</code>s created.</p><p>That it will use the <code>ThreadPool</code> is not true for every API. Most will follow the following pattern:</p><ol><li><p>The library creates a <code>TaskCompletionSource</code>.</p></li><li><p>The library sets a means to receive a notification. Callback, timer, message, whatever...</p></li><li><p>The library sets code to react to the notification that will call <code>SetResult</code>, or <code>SetException</code> on the <code>TaskCompletionSource</code> as appropriate for the notification received.</p></li><li><p>The library does the actual call to the external system.</p></li><li><p>The library returns <code>TaskCompletionSource.Task</code>.</p></li></ol><p>The call from step 4 goes to the external system. The external system responds, the response is received on the notification mechanism from step 2, then it sets the <code>Task</code> completed, and afterwards the continuation of the <code>Task</code> is scheduled (that continuation is what happens after your <code>await</code>).</p><blockquote><p>How can I throttle the rate of calls if I&#39;m calling GetAsync in a loop?</p></blockquote><p>If you are awaiting it, then your code will not continue until it completes. Alternatively, if we are talking about having a limited number of <code>Task</code>s concurrently (not being awaited), I would suggest to use a <code>SemaphoreSlim</code>. I would use it in conjunction with <code>Task.WaitAny</code> or <code>Task.WhenAny</code>.</p><p>Besides that, you probably will find <code>await Task.Delay(milliseconds)</code> useful. It will use the pattern I described above, around a timer, no <code>Thread</code> will be blocked waiting (unlike <code>Thread.Sleep</code>).</p><hr/><blockquote><p>has the c# team gone in the right direction creating this async paradigm in the language?</p></blockquote><p>I believe <code>async/await</code> is generally good. I agree that there is some overhead (creating <code>Task</code> objects, et. al.). However, C# is doing better than most languages.</p><p>I understand the <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" rel="noreferrer">blue-red</a> argument...</p><p>... on that, I would argue that if you want to follow the idea of a pure core and an impure shell, you will find that pure and impure and <code>async</code> and &#34;sync&#34; are similar. The impure shell would deal with external systems. If you call an impure method from your method, your method is impure. Similarly, interacting with external systems is often <code>async</code>, and if you want to <code>await</code> an <code>async</code> method, you have to make your method <code>async</code>.</p><p>So, yeah, <code>async</code> propagating is annoying. The solutions is that the entry point will be impure (and <code>async</code>) it will deal with external systems (impure imperative shell) and call into your not <code>async</code> code (pure functional core), which returns to the shell for more interoperability. That way you do not have to make everything <code>async</code>, and you do not have to make your whole code impure. If you are isolating external systems (for ease of exchanging them and ease of testing), you are probably doing this already.</p><blockquote><p>I feel that go&#39;s approach of creating a thread by just saying go myfunction() is less long-winded, but I know it has it&#39;s performance penalties due to the green-threads used.</p></blockquote><p><em>Is your complain that <code>await</code> is longer to type than <code>go</code>? that explains &#34;wordy&#34;.</em></p><p>Asynchronous does not mean multi-threaded. For instance, we can read for the hard disk without having a <code>Thread</code> waiting. You initialize the buffer where you will read, tell the operating system to tell the driver to tell the hard disk to write to that buffer (via DMA) and trigger an event. Then in the event we do <code>TaskCompletionSource.SetResult</code> and then system can schedule the continuation (your code after <code>await</code>). No <code>Thread</code>, and you didn&#39;t have to worry about it. <em>And yes, that is the same pattern I described above.</em></p><hr/><blockquote><p>I find it hard to reason about what is happening behind the scenes of the compiler</p></blockquote><p>The compiler is rewriting your code as continuations. It is a state machine. This is not the first time the compiler rewrites your code as a state machine, that would have been <strike>co-routines</strike> iterators with <code>yield return</code>.</p><p>For an <code>async</code> method, each <code>await</code> means that the code afterwards will be a continuation the <code>Task</code> being awaited.</p><p>Please note that the <code>Thread</code> calling will not be waiting. Instead, the async method schedules the first <code>Task</code>, sets its continuation, and returns a <code>Task</code> that will completed when all the continuations created for the method completes.</p><p><em>Actually, it is a bit more complicated because there is error handling, and it works with <code>try-catch-finally</code>. The compiler does the rewriting.</em></p><p>That probably means that the calling <code>Thread</code> will eventually be free to do work, if that is the case it could be used to run scheduled <code>Task</code>s. Sometimes the continuation will run on the same <code>Thread</code> that called it, sometimes it will run on a different one. It is up to the <code>TaskScheduler</code>. The default <code>TaskScheduler</code> will use the <code>ThreadPool</code>. <em>And, yes, you can write a custom <code>TaskScheduler</code>.</em></p><hr/><p>Perhaps the interview <a href="https://channel9.msdn.com/Shows/Going+Deep/Mads-Torgersen-Inside-C-Async" rel="noreferrer">Mads Torgersen: Inside C# Async</a> can help you understand further. Strongly recommended.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../async-controllers-in-asp-net-mvc-real-advantages-how-achieved/'>Async Controllers in ASP.NET MVC: Real Advantages / How Achieved</a></li><li class="list-group-item"><a href='../async-why-have-an-async-for-a-login/'>Async &#8211; why have an async for a login</a></li><li class="list-group-item"><a href='../java-is-the-c-async-task-construct-equivalent-to-javas-executor-future/'>Java &#8211; Is the C# async/Task construct equivalent to Java&#8217;s Executor/Future</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>