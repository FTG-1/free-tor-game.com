<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++ &#8211; Intersection of geometric entities &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1082718 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1082718" class="post-1082718 software type-software status-publish hentry category-software tag-c tag-c11 tag-geometry tag-idioms tag-return-type"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++ &#8211; Intersection of geometric entities</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">c++11</span><span class="mr-2 badge badge-warning">geometry</span><span class="mr-2 badge badge-primary">idioms</span><span class="mr-2 badge badge-danger">return-type</span></p><div class="entry-content"><p>I was trying to design a small C++ geometric API for learning purposes, but came across a problem when dealing with intersections of geometric entities. For example, the intersection of a line and a sphere can have three different types: a couple of points, a point or nothing at all. I found several ways to deal with this problem, but I don&#39;t know which of them seems to be the best:</p><h2>CGAL <code>Object</code> return type</h2><p>I first tried to see what was done in other geometric libraries. The most complete I can found was CGAL. In CGAL, intersection functions return an <code>Object</code> which is a generic type that can hold anything (like <code>boost::any</code>). Then, you try to assign the <code>Object</code> to a value of another type, here is an example:</p><pre><code>void foo(CGAL::Segment_2&lt;Kernel&gt; seg, CGAL::Line_2&lt;Kernel&gt; line)
{
    CGAL::Object result;
    CGAL::Point_2&lt;Kernel&gt; ipoint;
    CGAL::Segment_2&lt;Kernel&gt; iseg;

    result = CGAL::intersection(seg, line);
    if (CGAL::assign(ipoint, result)) {

        // handle the point intersection case.

    } else if (CGAL::assign(iseg, result)) {

        // handle the segment intersection case.

    } else {

       // handle the no intersection case.
    }
}
</code></pre><p>By the way, the <code>assign</code> function uses <code>dynamic_cast</code> to check whether the two variables are assignable (everybody loves RTTI).</p><h2>Union return type</h2><p>A union can also be used as a return type, but it means using an <code>id</code> for every geometric type and having some kind of variant type to cover all the problems.</p><pre><code>struct Variant
{
    int id;
    union
    {
        Point point;
        std::pair&lt;Point, Point&gt; pair;
    };
};

int main()
{
    Point point;
    std::pair&lt;Point, Point&gt; pair;

    Variant v = intersection(Line{}, Sphere{});
    if (v.id == ID_POINT)
    {
        point = v.point;
        // Do something with point
    }
    else if (v.id == ID_VARIANT)
    {
        pair = v.pair;
        // Do something with pair
    }
    else
    {
        // No intersection
    }
}
</code></pre><h2>Avoiding the &#34;no intersection&#34; problem</h2><p>In order to split the &#34;no intersection&#34; case from the main problem, some libraries used to require the user to check whether there was an intersection before trying to find what was the intersection return type. It looked like this:</p><pre><code>Line line;
Sphere sphere;

if (intersects(line, sphere))
{
    auto ret = intersection(line, sphere);
    // Do something with ret
}
</code></pre><p>Another way to split the &#34;no intersection&#34; case from the rest of the problem would be to use an <code>optional</code> type:</p><pre><code>std::optional&lt;...&gt; ret = intersection(Line{}, Sphere{});
if (ret)
{
    // Do something with ret
}
</code></pre><h2>Using exceptions to control the &#34;return&#34; type</h2><p><em>I can already see some of you crying.</em></p><p>Yet another way to handle that problem of having different return types would be to <code>throw</code> the results instead of returning them. The &#34;no intersection&#34; return could still use one of the techniques from the previous paragraph:</p><pre><code>try
{
    intersection(Line{}, Sphere{});
}
catch (const Point&amp; point)
{
    // Do something with point
}
catch (const std::pair&lt;Point, Point&gt;&amp; pair)
{
    // Do something with pair
}
// Can still catch errors (or &#34;no intersection&#34; special type?)
</code></pre><h2>Having a &#34;main&#34; return type, throwing the other ones</h2><p>Another way would be to have a &#34;main&#34; return type for the intersection, let&#39;s say <code>std::pair&lt;Point, Point&gt;</code> and considering the other return types as &#34;exceptional&#34;; it gives more meaning to the use of exceptions while this is still not quite an error gestion. On the other hand, it could seem strange to handle a &#34;main&#34; type differently than the others&#8230;</p><pre><code>try
{
    auto pair = intersection(Line{}, Sphere{});
    // Do something with pair
}
catch (const Point&amp; point)
{
    // The chances for a sphere and a line to meet at
    // a single point are so small that the case can
    // already be considered exceptional.
    // ...
}
</code></pre><p>I purposedly left the errors gestion and the &#34;no intersection&#34; case out of this last example since many techniques already described could be used to handle it and I don&#39;t want the number of examples to be exponential. Here is one though:</p><pre><code>try
{
    // res is optional&lt;pair&lt;Point, Point&gt;&gt;
    if (auto res = intersection(Line{}, Sphere{}))
    {
        std::cout &lt;&lt; &#34;intersection: two points&#34; &lt;&lt; &#39;\n&#39;
                  &lt;&lt; std::get&lt;0&gt;(*res).x() &lt;&lt; &#34; &#34;
                  &lt;&lt; std::get&lt;0&gt;(*res).y() &lt;&lt; &#39;\n&#39;
                  &lt;&lt; std::get&lt;1&gt;(*res).x() &lt;&lt; &#34; &#34;
                  &lt;&lt; std::get&lt;1&gt;(*res).y() &lt;&lt; &#39;\n&#39;;
    }
    else
    {
        std::cout &lt;&lt; &#34;no intersection&#34; &lt;&lt; &#39;\n&#39;;
    }
}
catch (const Point&amp; point)
{
    // Exceptional case
    std::cout &lt;&lt; &#34;intersection: one point&#34; &lt;&lt; &#39;\n&#39;
              &lt;&lt; point.x() &lt;&lt; &#34; &#34;
              &lt;&lt; point.y() &lt;&lt; &#39;\n&#39;;
}
</code></pre><p>Since the cases where the result is thrown are exceptional, it should not add any runtime overhead to the program if the underlying system uses zero cost exceptions instead of the old SJLJ exceptions system.</p><h2>The actual question</h2><p>Well, that was a pretty long introduction, so here is the question: is there an idiomatic solution to the problem in these examples? And if not, are there at least some of the examples which could be banned without a second thought (well, <a href="http://www.drmaciver.com/2009/03/exceptions-for-control-flow-considered-perfectly-acceptable-thanks-very-much/" rel="nofollow">you could give a second thought to the exception examples</a> though&#8230;)?</p><p><strong>Note:</strong> something seemed evident to me but apparently is not: the entity returned by intersection between two geometric entities is not limited to a nothing, a point or a set of point. An intersection can pretty much return any geometric entity. Therefore, using a container to hold the values does not sound like a good idea.</p><p><strong>Note 2:</strong> time machine note, it happens. After having given it some thought, I would ban exceptions (as most people would do), not because exceptions are inherently bad or not designed for this, but because it makes the expression <code>intersection(...) == SomeShape</code> throw an exception even when the both operands should be equal, which isn&#39;t elegant. I guess that I would use a bastard child of a variant instead.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Since you are working on a geometric API, I guess you are not only
interested in intersection of lines and spheres, but have also more
exciting projects.</p><p>A natural approach to solve your problem of representing values for
intersection would be to define a type for geometric figures so that
you can represent:</p><ul><li>Points</li><li>Lines</li><li>Spheres</li><li>Intersections that you cannot compute (kind of symbolic intersection)</li><li>Union of figures</li></ul><p>Once you have done that, your intersection algorithm can gobble two
figures and return a figure, computed by using</p><p>(A + B + ...).(C + D + ...) = A.C + A.D + B.C + B.D + ...</p><p>where I denote the union by <code>+</code> and the intersection by <code>.</code> and where
A, B, C, D and the dots can be a point, a sphere, a line or an
intersection you cannot compute.</p><p>To some extent, this approach gives satisfying results and may give
the feeling that it is the right solution to the problem.</p><p>There are however a lot of problems with this approach, that you
should be aware of:</p><ol><li><p>Intersection that you cannot compute tend to absorb everything,
i.e. intersecting anything with an intersection that you cannot can
yield an intersection that you cannot compute.</p></li><li><p>If you intersect two spheres, it yields a circle, that you cannot
compute, not because you cannot find which circle it is, but
because you cannot represent circles.  If you choose to add circles
to your vocabulary, you have to figure out how to compute
intersections with all other figures you may have. So if you have <em>n</em> base figures you should deal with <em>n^2</em> type of
intersections. So, choosing a rich vocabulary of figures without
relying on ``intersections you cannot compute&#39;&#39; is not an option.</p></li><li><p>Even if you restrict yourself to the rassuring realm of algebraic
figures (defined by polynomial equations), computing intersections
is far from trivial.  What you are trying to do is to <em>compute a
minimal set of generators of the reduced ideal</em> defined by your
intersection, so do not expect to be able to do this on more than a
few examples. You should regard anything you are able to compute as
a lucky accident.</p></li></ol></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../which-statically-typed-languages-support-intersection-types-for-function-return-values/'>Which statically typed languages support intersection types for function return values</a></li><li class="list-group-item"><a href='../c-how-to-represent-a-geometric-line-programmatically/'>C++ &#8211; How to represent a geometric line programmatically</a></li><li class="list-group-item"><a href='../c-exception-hierarchy-and-use-of-what-message-for-parsing-strings/'>C++ &#8211; Exception Hierarchy and Use of What Message for Parsing Strings</a></li><li class="list-group-item"><a href='../c-handling-errors-for-non-exceptional-cases-in-modern-c/'>C++ &#8211; Handling errors for non-exceptional cases in modern C++</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>