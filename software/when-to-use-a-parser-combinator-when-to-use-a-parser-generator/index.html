<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>When to use a Parser Combinator? When to use a Parser Generator &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1065608 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1065608" class="post-1065608 software type-software status-publish hentry category-software tag-lexer tag-parser-combinator tag-parsing"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">When to use a Parser Combinator? When to use a Parser Generator</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">lexer</span><span class="mr-2 badge badge-info">parser-combinator</span><span class="mr-2 badge badge-warning">parsing</span></p><div class="entry-content"><p>I&#39;ve taken a deep dive into the world of parsers recently, wanting to create my own programming language.</p><p>However, I found out that there exist two somewhat different approaches of writing parsers: Parser Generators and Parser Combinators.</p><p>Interestingly, I have been unable to find any resource that explained in what cases which approach is better; Rather, many resources (and persons) I queried about the subject did not know of the other approach, only explaining <em>their</em> approach as <strong>the</strong> approach and not mentioning the other at all:</p><ul><li>The <a href="https://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools#Second_edition" rel="nofollow noreferrer">famous Dragon book</a> goes into lexing/scanning and mentions (f)lex, but does not mention Parser Combinators at all.</li><li><a href="https://pragprog.com/book/tpdsl/language-implementation-patterns" rel="nofollow noreferrer">Language Implementation Patterns</a> heavily relies on the ANTLR Parser Generator built in Java, and does not mention Parser Combinators at all.</li><li><a href="http://jakewheat.github.io/intro_to_parsing/#getting-started" rel="nofollow noreferrer">The Introduction to Parsec</a> tutorial on Parsec, which is a Parser Combinator in Haskell, does not mention Parser Generators at all.</li><li><a href="http://boost-spirit.com/home/" rel="nofollow noreferrer">Boost::spirit</a>, the best-known C++ Parser Combinator, does not mention Parser Generators at all.</li><li>The great explanatory blog post <a href="http://theorangeduck.com/page/you-could-have-invented-parser-combinators" rel="nofollow noreferrer">You Could Have Invented Parser Combinators</a> does not mention Parser Generators at all.</li></ul><h2>Simple Overview:</h2><h3>Parser Generator</h3><p>A Parser Generator takes a file written in a <a href="https://stackoverflow.com/questions/809574">DSL</a> that is some dialect of <a href="https://en.wikipedia.org/wiki/Extended_Backusâ€“Naur_form" rel="nofollow noreferrer">Extended Backus-Naur form</a>, and turns it into source code that can then (when compiled) become a parser for the input language that was described in this DSL.</p><p>This means that the compilation process is done in two separate steps.<br /> Interestingly, Parser Generators themselves are also compilers (and many of them are indeed <a href="https://en.wikipedia.org/wiki/Self-hosting" rel="nofollow noreferrer">self-hosting</a>).</p><h3>Parser Combinator</h3><p>A Parser Combinator describes simple functions called <em>parsers</em> that all take an input as parameter, and try to pluck off the first character(s) of this input if they match. They return a tuple <code>(result, rest_of_input)</code>, where <code>result</code> might be empty (e.g. <code>nil</code> or <code>Nothing</code>) if the parser was unable to parse anything from this input. An example would be an <code>digit</code> parser.<br /> Other parsers can of course take parsers as first arguments (the final argument still remaining the input string) to <em>combine</em> them: e.g. <code>many1</code> attempts to match another parser as many times as possible (but at least once, or it itself fails).</p><p>You can now of course combine (compose) <code>digit</code> and <code>many1</code>, to create a new parser, say <code>integer</code>.</p><p>Also, a higher-level <code>choice</code> parser can be written that takes a list of parsers, trying each of them in turn.</p><p>In this way, very complex lexers/parsers can be built. In languages supporting operator overloading, this also looks very much like EBNF, even though it is still written directly in the target language (and you can use all features of the target language you desire).</p><h2>Simple Differences</h2><p>Language:</p><ul><li>Parser Generators are written in a combination of the EBNF-ish DSL and the code that these statements should generate to when they match.</li><li>Parser Combinators are written in the target language directly.</li></ul><p>Lexing/Parsing:</p><ul><li>Parser Generators have a very distinct difference between the &#39;lexer&#39; (which splits a string into tokens that might be tagged to show what kind of value we are dealing with) and the &#39;parser&#39; (which takes the output list of tokens from the lexer and attempts to combine them, forming an Abstract Syntax Tree).</li><li>Parser Combinators do not have/need this distinction; usually, simple parsers perform the work of the &#39;lexer&#39; and the more high-level parsers call these simpler ones to decide which kind of AST-node to create.</li></ul><h2>Question</h2><p>However, even given these differences (and this list of differences is probably far from complete!), I cannot make an educated choice on <em>when</em> to use which one. I fail to see what the implications/consequences are of these differences.</p><p>What problem properties would indicate that a problem would better be solved using a Parser Generator?<br /> What problem properties would indicate that a problem would better be solved using a Parser Combinator?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>I have done a lot of research these past few days, to understand better why these
separate technologies exist, and what their strengths and weaknesses are.</p><p>Some of the already-existing answers hinted at some of their differences,
but they did not give the complete picture, and seemed to be somewhat opinionated, which is why this answer was written.</p><p>This exposition is long, but important. <em>bear with me</em> (Or if you&#39;re impatient, scroll to the end to see a flowchart).</p><hr/><p>To understand the differences between Parser Combinators and Parser Generators,
one first needs to understand the difference between the various kinds of parsing
that exist.</p><h2>Parsing</h2><p>Parsing is the process of analyzing of a string of symbols according to a formal grammar.
(In Computing Science,) parsing is used to be able to let a computer understand text written in a language,
usually creating a <em>parse tree</em> that represents the written text, storing the meaning of the different written parts
in each node of the tree. This parse tree can then be used for a variety of different purposes, such as
translating it to another language (used in many compilers), 
interpreting the written instructions directly in some way (SQL, HTML), allowing tools like <a href="https://en.wikipedia.org/wiki/Lint_(software)" rel="noreferrer">Linters</a> to do their work, etc. Sometimes, a parse tree is not <em>explicitly</em> generated, but rather the action
that should be performed at each type of node in the tree is executed directly. This increases efficiency,
but underwater still an implicit parse tree exists.</p><p>Parsing is a problem that is computationally difficult. There has been over fifty years of research on this subject,
but there is still much to learn.</p><p>Roughly speaking, there are four general algorithms to let a computer parse input:</p><ul><li>LL parsing. (Context-free, top-down parsing.)</li><li>LR parsing. (Context-free, bottom-up parsing.)</li><li>PEG + Packrat parsing.</li><li>Earley Parsing.</li></ul><p>Note that these types of parsing are very general, theoretical descriptions. There are multiple ways
to implement each of these algorithms on physical machines, with different tradeoffs.</p><p>LL and LR can only look at Context-Free grammars (that is; the context around the tokens that are written is not
important to understand how they are used).</p><p>PEG/Packrat parsing and <a href="https://en.wikipedia.org/wiki/Earley_parser" rel="noreferrer">Earley parsing</a> are used a lot less: Earley-parsing is nice in that it can handle a whole lot 
more grammars (including those that are not necessarily Context-Free) but it is less efficient (as claimed by the dragon book (section 4.1.1); I am not sure if these claims are still accurate). <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar" rel="noreferrer">Parsing Expression Grammar + Packrat-parsing</a> is a method that is relatively efficient and can also handle more grammars than both LL and LR, but hides ambiguities, as will quickly be touched on below.</p><h3>LL (Left-to-right, Leftmost derivation)</h3><p>This is possibly the most natural way to think about parsing.
The idea is to look at the next token in the input string and then decide which one of maybe multiple possible recursive calls should be taken
to generate a tree structure.</p><p>This tree is built &#39;top-down&#39;, meaning that we start at the root of the tree, and travel the grammar rules in the same way as
 we travel through the input string. It can also be seen as constructing a &#39;postfix&#39; equivalent for the &#39;infix&#39; token stream that is being read.</p><p>Parsers performing LL-style parsing can be written to look very much like the original grammar that was specified.
This makes it relatively easy to understand, debug and enhance them. Classical Parser Combinators are nothing more
than &#39;lego pieces&#39; that can be put together to build an LL-style parser.</p><h3>LR (Left-to-right, Rightmost derivation)</h3><p>LR parsing travels the other way, bottom-up: 
At each step, the top element(s) on the stack are compared to the list of grammar, to see if they could be <em>reduced</em> to a higher-level rule in the grammar. If not, the next token from the input stream is <em>shift</em> ed and placed on top
of the stack.</p><p>A program is correct if at the end we end up with a single node on the stack which represents the starting rule from
our grammar.</p><h3>Lookahead</h3><p>In either of these two systems, it sometimes is necessary to peek at more tokens from the input
before being able to decide which choice to make. This is the <code>(0)</code>, <code>(1)</code>, <code>(k)</code> or <code>(*)</code>-syntax you see after
the names of these two general algorithms, such as <code>LR(1)</code> or <code>LL(k)</code>. <code>k</code> usually stands for &#39;as much as your grammar needs&#39;,
while <code>*</code> usually stands for &#39;this parser performs backtracking&#39;, which is more powerful/easy to implement, but has
a much higher memory and time usage than a parser that can just keep on parsing linearly.</p><p>Note that LR-style parsers already have many tokens on the stack when they might decide to &#39;look ahead&#39;, so they already have more information
to dispatch on. This means that they often need less &#39;lookahead&#39; than an LL-style parser for the same grammar.</p><h2>LL vs. LR: Ambiguity</h2><p>When reading the two descriptions above, one might wonder why LR-style parsing exists,
as LL-style parsing seems a lot more natural.</p><p>However, LL-style parsing has a problem: <strong>Left Recursion</strong>.</p><p>It is very natural to write a grammar like:</p><pre><code>expr ::= expr &#39;+&#39; expr | term
term ::= integer | float
</code></pre><p>But, a LL-style parser will get stuck in an infinite recursive loop
when parsing this grammar: When trying out the left-most possibility of the <code>expr</code> rule, it 
recurses to this rule again without consuming any input.</p><p>There are ways to resolve this problem. The simplest is to rewrite your grammar so that this
kind of recursion does not happen any more:</p><pre><code>expr ::= term expr_rest
expr_rest ::= &#39;+&#39; expr | Ïµ
term ::= integer | float
</code></pre><p>(Here, <em>Ïµ</em> stands for the &#39;empty string&#39;)</p><p>This grammar now is right recursive. Note that it immediately is a lot more difficult to read.</p><p>In practice, left-recursion might happen <em>indirectly</em> with many other steps in-between.
This makes it a hard problem to look out for.
But trying to solve it makes your grammar harder to read.</p><p>As Section 2.5 of the Dragon Book states:</p><blockquote><p>We appear to have a conflict: on the one hand we need a grammar that
 facilitates translation, on the other hand we need a significantly different grammar that facilitates parsing.
 The solution is to begin with the grammar for easy translation and carefully transform it to facilitate parsing. By eliminating the left recursion 
 we can obtain a grammar suitable for use in a predictive recursive-descent translator.</p></blockquote><p>LR-style parsers do not have the problem of this left-recursion, as they build the tree from the bottom-up. <em>However</em>, the mental translation of a grammar like above to an LR-style parser (which is often implemented as a <a href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noreferrer">Finite-State Automaton</a>)<br/> is very hard (and error-prone) to do, as often there are hundreds or thousands of states + state transitions to consider.
This is why LR-style parsers are usually <em>generated</em> by a Parser Generator, which is also known as a &#39;compiler compiler&#39;.</p><h2>How to resolve Ambiguities</h2><p>We saw two methods to resolve Left-recursion ambiguities above:
1) rewrite the syntax
2) use an LR-parser.</p><p>But there are other kinds of ambiguities which are harder to solve: 
What if two different rules are equally applicable at the same time?</p><p>Some common examples are:</p><ul><li>arithmetic expressions.</li><li><a href="https://en.wikipedia.org/wiki/Dangling_else" rel="noreferrer">the Dangling Else</a></li></ul><p>Both LL-style and LR-style parsers have problems with these. Problems with parsing
arithmetic expressions can be solved by introducing operator precedence.
In a similar way, other problems like the Dangling Else can be solved, by picking one precedence behaviour
and sticking with it. (In C/C++, for instance, the dangling else always belongs to the closest &#39;if&#39;).</p><p>Another &#39;solution&#39; to this is to use Parser Expression Grammar (PEG): This is similar to the 
BNF-grammar used above, but in the case of an ambiguity,
always &#39;pick the first&#39;. Of course, this does not really &#39;solve&#39; the problem,
but rather hide that an ambiguity actually exists: The end users might not know
which choice the parser makes, and this might lead to unexpected results.</p><p>More information that is a whole lot more in-depth than this post, including why it is impossible
in general to know if your grammar does not have any ambiguities and the implications of this is
the wonderful blog article <a href="http://blog.reverberate.org/2013/09/ll-and-lr-in-context-why-parsing-tools.html" rel="noreferrer">LL and LR in context: Why parsing tools are hard</a>.
I can highly recommend it; it helped me a lot to understand all the things I am talking about right now.</p><h2>50 years of research</h2><p>But life goes on. It turned out that &#39;normal&#39; LR-style parsers implemented as finite state automatons often needed thousands of
states + transitions, which was a problem in program size. So, variants such as <em>Simple LR</em> (SLR) and <em>LALR</em> (Look-ahead LR) were written
that combine other techniques to make the automaton smaller, reducing the disk and memory footprint of the parser programs.</p><p>Also, another way to resolve the ambiguities listed above is to use <em>generalized</em> techniques in which, in the case of an ambiguity, both
possibilities are kept and parsed: Either one might fail to parse down the line (in which case the other possibility is the &#39;correct&#39; one),
as well as returning both (and in this way showing that an ambiguity exists) in the case they both are correct.</p><p>Interestingly, after the <a href="https://en.wikipedia.org/wiki/GLR_parser" rel="noreferrer"><em>Generalized LR</em> algorithm</a> was described,
it turned out that a similar approach could be used to implement <a href="http://dotat.at/tmp/gll.pdf" rel="noreferrer">Generalized LL parsers</a>,
which is similarly fast ( $O(n^3)$ time complexity for ambiguous grammars, $ O(n) $ for completely unambiguous grammars, albeit with more
bookkeeping than a simple (LA)LR parser, which means a higher constant-factor)
but again allow a parser to be written in recursive descent (top-down) style that is a lot more natural to write and debug.</p><h2>Parser Combinators, Parser Generators</h2><p>So, with this long exposition, we are now arriving at the core of the question:</p><p><strong>What is the difference of Parser Combinators and Parser Generators, and when should one be used over the other?</strong></p><p>They are really different kinds of beasts:</p><p><strong>Parser Combinators</strong> were created because people were writing top-down parsers and realized
that many of these <a href="http://theorangeduck.com/page/you-could-have-invented-parser-combinators" rel="noreferrer">had a lot in common</a>.</p><p><strong>Parser Generators</strong> were created because people were looking to build parsers that did not have the problems that 
LL-style parsers had (i.e. LR-style parsers), which proved very hard to do by hand. Common ones include Yacc/Bison, that implement (LA)LR).</p><p>Interestingly, nowadays the landscape is muddled somewhat:</p><ul><li><p>It is possible to write <a href="http://www.cs.uwm.edu/~dspiewak/papers/generalized-parser-combinators.pdf" rel="noreferrer">Parser Combinators that work with the <em>GLL</em> algorithm</a>, resolving the ambiguity-issues that classical LL-style parsers had, while being just as readable/understandable as all kinds of top-down parsing.</p></li><li><p>Parser Generators can also be written for LL-style parsers. <a href="http://www.antlr.org/" rel="noreferrer">ANTLR</a> does exactly that, and uses other heuristics (Adaptive LL(*)) to resolve the ambiguities
that classical LL-style parsers had.</p></li></ul><p>In general, creating an LR parser generator and and debugging the output of an (LA)LR-style parser generator running on your grammar
is difficult, because of the translation of your original grammar to the &#39;inside-out&#39; LR form.
On the other hand, tools like Yacc/Bison have had many years of optimisations, and seen a lot of use in the wild, which means
that many people now consider it as <em>the</em> way to do parsing and are sceptical towards new approaches.</p><p>Which one you should use, depends on how hard your grammar is, and how fast the parser needs to be.
Depending on the grammar, one of these techniques (/implementations of the different techniques) might be faster, have a smaller memory footprint, have a smaller disk footprint,
or be more extensible or easier to debug than the others. <strong>Your Mileage May Vary</strong>.</p><h2>Side note: On the subject of Lexical Analysis.</h2><p>Lexical Analysis can be used both for Parser Combinators and Parser Generators.
The idea is to have a &#39;dumb&#39; parser that is very easy to implement (and therefore fast) that performs a first pass over your source code,
removing for instance repeating white spaces, comments, etc, and possibly &#39;tokenizing&#39; in a very coarse way the different elements that make 
up your language.</p><p>The main advantage is that this first step makes the <em>real</em> parser a lot simpler (and because of that possibly faster).
The main disadvantage is that you have a separate translation step, and e.g. error reporting with line- and column numbers becomes harder because of
the removal of white-space.</p><p>A lexer in the end is &#39;just&#39; another parser and can be implemented using any of the techniques above. Because of its simplicity, often other techniques are used
than for the main parser, and for instance extra &#39;lexer generators&#39; exist.</p><hr/><p><strong>Tl;Dr:</strong></p><p>Here is a flowchart that is applicable to most cases: <a href="../../../i.stack.imgur.com/u6NgL.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/u6NgL.png" alt="enter image description here"/></a></p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../are-separate-parsing-and-lexing-passes-good-practice-with-parser-combinators/'>Are separate parsing and lexing passes good practice with parser combinators</a></li><li class="list-group-item"><a href='../how-to-add-precedence-to-lalr-parser-like-in-yacc/'>How to add precedence to LALR parser like in YACC</a></li><li class="list-group-item"><a href='../chosing-a-parser-for-a-code-beautifier/'>Chosing a parser for a code beautifier</a></li><li class="list-group-item"><a href='../java-do-modern-languages-still-use-parser-generators/'>Java &#8211; Do modern languages still use parser generators</a></li><li class="list-group-item"><a href='../java-when-to-use-antlr-and-when-to-use-a-parsing-library/'>Java &#8211; When to use ANTLR and when to use a parsing library</a></li><li class="list-group-item"><a href='../design-the-procedure-that-is-followed-when-writing-a-lexer-based-upon-a-grammar/'>Design &#8211;  the procedure that is followed when writing a lexer based upon a grammar</a></li><li class="list-group-item"><a href='../should-the-lexer-allow-what-is-obviously-a-syntax-error/'>Should the lexer allow what is obviously a syntax error</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>