<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>API Authentication, One time token VS Dynamic tokens &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1065204 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1065204" class="post-1065204 software type-software status-publish hentry category-software tag-api tag-security"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">API Authentication, One time token VS Dynamic tokens</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">api</span><span class="mr-2 badge badge-info">Security</span></p><div class="entry-content"><p>We are working on a new project, we are two lead developers and got on a crossroad on how to use a token to secure the communication between the server and the client.</p><h1>First Suggestion: (The one time token AKA Static Token)</h1><ol><li><p>the client requests a primary token, by sending the username and password and the current_time (this variable will be saved in the server&#39;s database and the client side too) to the api, the server interprets the input, and renders a hashed token (e.g. : 58f52c075aca5d3e07869598c4d66648) saves it in the database and returns it to the client.</p></li><li><p>The client now saves the primary token, and creates new hashed token using the primary token + the current_time variable sent in the authentication request (lets call this new token, main_token) also the server does the same and create the same token using the same algorithm.</p></li><li><p>Each time the client queries the server API, it sends the main_token to the server, now the server compares the token generated in it, with the main_token sent by the client, if it matches, it means the user is real</p></li></ol><h1>Second Suggestion: (Dynamic Token)</h1><ol><li><p>The client generates two random keys ($key1 = rand(10000,90000); $key2 = rand(10000,90000);) On each request on the API, the client creates a hash using the query type, and the two keys with a complex algorithm, and sends these two keys + the hash to the server</p></li><li><p>The server, using the same Algorithm used in the client, creates a hash, and compares is to the one sent by the client, if it matches, the server proceeds to deal with the query</p></li></ol><hr/><p>Now, the question is, Which one is the most logical, and secure way to use for securing the API requests?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>I really like the first approach in general.</p><ul><li>it&#39;s simple to understand and implement</li><li>it&#39;s secure (to my knowledge)</li><li>it&#39;s a not uncommon approach which I&#39;ve seen used in the past</li></ul><p>One thing I don&#39;t see mentioned about the first that you should keep in mind, the timestamp used to hash the token needs to have a TTL expiry that&#39;s exceedingly short (like 1 second) so you verify the message wasn&#39;t sent with the same timestamp and token from a message 12 hours earlier; obviously it would calculate as legit but is not in this case.</p><p>If these are the only two options you&#39;re considering though I&#39;d just like to make sure you&#39;ve looked at other approaches too, as there are many. More than I&#39;m going to list in fact. These are some common auth approaches which are worth studying just to see if they might fit your purpose better, and if nothing else understanding them may give you some ideas to help tighten up whichever approach you do go with.</p><p>Do note, I am <em>not</em> a security expert.</p><hr/><h2>OAuth/Federated</h2><p>In this approach you have a 3rd party guarantor where the consuming code requests the token/cert/what have you from them and passes that to you, at this point all you need to do is ask the 3rd party if the key you were given is legit.</p><p>Pro:</p><ul><li>Standards based</li><li>Issues will be found by others on other people&#39;s systems so you will find out if insecurity happens</li><li>Much less auth work will be needed by you</li></ul><p>Con:</p><ul><li>You have to deal with a 3rd party servicer and their API, or create and host your own &#34;3rd party&#34; to segregate the auth out of your main service.</li><li>For many services overkill, but conceptually worth considering</li></ul><h2>Asynchronous Certificates</h2><p>Here you would have your clients encrypt their communications with a public cert you have shared with them when they created a user. On your side you would decrypt using the private key associated with there user. Generally you would initiate the communication with a challenge-response to show they can encrypt/decrypt as you expect identifying them as who they claim to be. Though &#34;synchronous&#34; approaches are possible which don&#39;t use the challenge-response, they have slightly less security and some time synchronization issues which can make them trickier.</p><p>from <a href="http://www.novell.com/documentation/nmas23/?page=/documentation/nmas23/radius/data/hrgxltm4.html">Novell</a> (yeah I know, novell? really?)</p><blockquote><p>Tokens use a variable as the basis to generate the one-time password.
 This variable is called the challenge. The two main methods for
 determining the variable used to generate the password are
 asynchronous or synchronous.</p><p>With the asynchronous or challenge-response method, the server
 software sends the token an external challenge---a randomly generated
 variable--- for the token device to encrypt. The token uses this
 challenge variable, the encryption algorithm, and the shared secret to
 generate the response---the correctly encrypted password.</p><p>With the synchronous method, the challenge variable used to generate
 the password is determined internally by the token and the server. A
 time counter, event counter, or time and event counter combination
 within each device is used as the basis for the challenge variable.
 Because the token and the server each separately and internally
 determine the challenge variable from their own counters, it is very
 important for their time counters and the event counters to stay
 synchronized. Because it is so easy for the server and the token to
 get out of sync, most implementations allow for a certain amount of
 drift between the counters. Usually, a small range or window of these
 counter values is used to compute the password. However, if the token
 and server get out of sync beyond this window, a special procedure is
 necessary to synchronize them.</p></blockquote><p>Pro:</p><ul><li>Certificates have CA roots which make them trustworthy and difficult to forge</li><li>There are standard facilities in operating systems for managing and maintaining cert stores easily</li><li>Well-studied approach, lots of information available on it</li><li>Expiry along with a variety of other things are in-built facilities of standard certificates, they are generally robust</li></ul><p>Con:</p><ul><li>Certificates can be tricky to work with programmatically</li><li>Depending on if you require an external CA, may not be free</li><li>May need to maintain cert stores manually to ensure expected root trusts are configured</li></ul><h2>NTLM</h2><p>Don&#39;t laugh, if this is a smaller or internal only service and you&#39;re in a windows environment, there is nothing wrong with using standard NTLM authentication to guarantee access. Especially if you&#39;re working with IIS this is hands down the simplest approach. Easy to maintain and configure as well in a web.config.</p><p>Pro:</p><ul><li>Extremely easy to configure, implement, and maintain</li></ul><p>Con:</p><ul><li>Minimal interoperability</li><li>Not sufficient for public facing authentication</li></ul><h2>Nonces</h2><p>When working with nonces in your authentication approach, you supply a method to get a nonce on the service. This method returns a unique arbitrary string or piece of data (&#34;a nonce&#34;) on each request. Every request to other methods now require a nonce to be retrieved, and used in the crypto algorithm for the request. The value here is that the server keeps track of the nonces used, and never allows reuse of a nonce, this completely prevents replay attacks because once a request with one nonce is made, a request with that nonce can never be made again. As nonces are requested they&#39;re added to a list of available nonces, as they&#39;re used they&#39;re moved from the available list to the used list. When generating a nonce you ensure what you generate is not on the used list and the available list will never again have one of the old ones and therefore no repeats can be made.</p><p>Pro:</p><ul><li>Thwarts replay attacks quite well</li><li>Not altogether difficult to implement or understand</li></ul><p>Con:</p><ul><li>Requires clients make two requests for each one request (though may be lessened by requiring nonces for only <em>certain</em> requests)</li><li>Requires management of nonces, which should be transactional</li><li>Negatively affects performance by requiring the extra requests for nonces (transactionality further increases resource cost of working with nonces)</li></ul></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../generating-csrf-tokens-without-using-sessions-cookies/'>Generating CSRF tokens without using sessions &#038; cookies</a></li><li class="list-group-item"><a href='../what-are-the-best-practices-to-secure-a-web-api/'>What are the best practices to secure a web API</a></li><li class="list-group-item"><a href='../approach-to-authenticate-clients-to-tcp-server/'>Approach to Authenticate Clients to TCP Server</a></li><li class="list-group-item"><a href='../rest-api-security-hmac-key-hashing-vs-jwt/'>REST API security: HMAC/key hashing vs JWT</a></li><li class="list-group-item"><a href='../rest-api-security-stored-token-vs-jwt-vs-oauth/'>REST API security Stored token vs JWT vs OAuth</a></li><li class="list-group-item"><a href='../rest-token-based-authentication-using-access-and-refresh-tokens/'>Rest &#8211; Token-based authentication using access and refresh tokens</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>