<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="https://free-tor-game.com/wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Distributed long-running jobs &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js?ver=11.2.0' id='highlight-js'></script>     <script>( function( w, d, s, l, i ) {
				w[l] = w[l] || [];
				w[l].push( {'gtm.start': new Date().getTime(), event: 'gtm.js'} );
				var f = d.getElementsByTagName( s )[0],
					j = d.createElement( s ), dl = l != 'dataLayer' ? '&l=' + l : '';
				j.async = true;
				j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
				f.parentNode.insertBefore( j, f );
			} )( window, document, 'script', 'dataLayer', ' ' );</script>      <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1078957 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="https://free-tor-game.com/3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="https://free-tor-game.com/contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1078957" class="post-1078957 software type-software status-publish hentry category-software tag-distributed-computing tag-net"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Distributed long-running jobs</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">distributed computing</span><span class="mr-2 badge badge-info">net</span></p><div class="entry-content"><h1>Scenario</h1><p>Various types of files containing customer&#39;s data are being uploaded via FTP, and a POST is being made to a REST API to update a database table, which tells the system (a web app) which of those files are new.</p><p>Users of the web app are notified of those new files, and can choose to import them into the app&#39;s db at any time. They can only import them from the oldest to the newest, but can freely choose to import only a subset of them (don&#39;t ask me why, this is a requirement and it also happens to be a key aspect of the issue I&#39;m facing).<br /> When the user chooses which files to import, said table gets updated with a timestamp which signals to the system that the file has to be imported.</p><p>A Windows service queries the table every X seconds and, if it finds files flagged with the timestamp, retrieves all the enabled files for the customer with the oldest one, sorts them by creation date (which is embedded in the name of the file) for good measure, and imports them. Then the process repeats for the next customer with enabled files, and so on and so forth.</p><h1>Problem</h1><p>Now, importing those files can take a rather long time, with the net result that import requests queue up but, being processed serially, can take hours to be fulfilled. Since it&#39;s accounting and payroll data we&#39;re talking about, customers aren&#39;t willing to wait that much.</p><p>We definitely need to speed things up.</p><h1>What can&#39;t be done</h1><p>The low-hanging fruit would appear to be attempting to parallelize the import of <em>individual</em> files belonging to the <em>same</em> customer, but that can&#39;t be done, because <em>a file contains data about a specific month</em> and, in many cases, e.g. July&#39;s file <strong>has</strong> to be imported before August&#39;s. In other words, most the file types we&#39;re dealing with have a temporal dependency on one another (and if they don&#39;t now, they might in the future).</p><h1>What <em>could</em> be done</h1><p>Another idea is to keep a queue of the import requests, have some workers available, and parallelize the import <em>by customer</em>.</p><p>But here comes into play the requirement I wrote about before: the customer, while constrained to make individual import requests in chronological order, can choose to only import a subset of them.</p><p>Say Alice sees there are 6 new files to import, and decides to import 3 of them. Ok, the background job gets queued, worker X is available and grabs the task and executes it. But let&#39;s say that Alice decides to import the other 3 files while worker X is still busy. The request gets queued and worker Y, who happens to be available, starts to work on those 3 files.</p><p>What would happen is that data could be imported in the wrong order, leading to all sorts of problems.</p><p>What I need, I guess, is a way to somehow say</p><blockquote><p><strong>If job A is currently being executed for customer X, a new one B for the same customer X needs to be kept in the queue until A is done. If, however, customer Y creates a new job C, it can be picked up as soon as a worker frees up</strong>&#34;.</p></blockquote><h2>But why don&#39;t you make the import faster?</h2><p>It&#39;s a huge and complex piece of software and, while I&#39;ve been able to make it faster, it has to execute a lot of IronPython scripts, which implies a great overhead. It could for sure be made faster, but from the profiling I did, script execution is the chief bottleneck, and we simply can&#39;t afford to move all that logic to C# (even because it&#39;s heavily customized for each customer).</p><h2>Then why don&#39;t you make the import itself parallel?</h2><p>While it&#39;s true that the import process is typically composed of many multiple steps, some of those steps again have a temporal dependency, meaning that some of them need to be executed first (e.g. I can&#39;t import data about payrolls if new hires haven&#39;t been imported first).<br /> I went through the trouble of making it transactional, so interrupting any of those steps won&#39;t actually do much harm, but that was very little fun. Making it parallel would require extensive changes to the code, and I would prefer to leave it untouched, as it&#39;s pretty hairy and without tests whatsoever.</p><h2>Why don&#39;t you just use Hangfire?</h2><p>Because Hangfire can&#39;t handle dependencies between tasks. In the future I will have to enqueue tasks that don&#39;t have absolutely anything to do with one another, and in that case I will be able to use Hangfire.</p><h1>Ok then&#8230;</h1><p>It&#39;s clear that things <em>could</em>, in theory, be parallelized at one or more of these three levels:</p><ol><li><strong>customer</strong>, which owns</li><li><strong>files</strong>, each of which takes many simpler</li><li><strong>steps</strong> to be imported</li></ol><p>All of those three levels have the same problem: temporal coupling. If they didn&#39;t, things would be that much easier.<br /> The third would imply changes to the import code, which I would rather not do. It takes a list of files to import, so I would much rather parallelize at the first two levels, the easiest being the customer.</p><p>My questions</p><p>Assume I&#39;m going to use ZeroMQ/RabbitMQ or something of that sort. I could store the IDs of the files to import and enqueue them.</p><p>But:</p><ul><li><p>how do you build one of those <em>workers</em>, anyway? Is it going to be a thread spawned by my already-existing Windows service which sits there idle polling the queue until there&#39;s a task to execute?</p></li><li><p>could such a design scale across machines, should the need arise to throw more hardware at it?</p></li><li><p>if that&#39;s the case, I guess I should deploy a new instance of my service on the other machines, right?</p></li><li><p>how do you establish dependencies between jobs?</p></li><li><p>how can I see if a job for customer X is already executing and, in that case, leave any other job for the same customer in the queue? Sounds like writing a flag to a database table would lead to race conditions.</p></li><li><p>I guess I should take measures to somehow take and persist a snapshot of the queue every X minutes, in case the server goes down or needs to be rebooted.</p></li></ul><p>Bear with me, I never had the chance to do any distributed programming, and reading here and there I only found vague explanations.</p><p>Sorry about the length of this question, but I wanted to narrow down the specific scenario.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>how do you build one of those workers, anyway? Is it going to be a thread spawned by my already-existing Windows service which sits there idle polling the queue until there&#39;s a task to execute?</p><p>how can I see if a job for customer X is already executing and, in that case, leave any other job for the same customer in the queue? Sounds like writing a flag to a database table would lead to race conditions.</p></blockquote><p>With a per-customer worker, the worker itself is pretty straightforward since it just contains a running job and a FIFO queue of items to process. On the .NET platform, the worker could be represented by:</p><ul><li><a href="https://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx" rel="nofollow noreferrer">ActionBlock</a> from the <a href="https://msdn.microsoft.com/en-us/library/hh228603(v=vs.110).aspx" rel="nofollow noreferrer">TPL DataFlow</a> library</li><li><a href="https://msdn.microsoft.com/en-us/library/ee370357.aspx" rel="nofollow noreferrer">MailboxProcessor</a> from F#</li><li><code>Task</code> + <code>Queue&lt;T&gt;</code> + locking (on enqueue, dequeue, and task complete)<ul><li>Note that there does exist <code>ConcurrentQueue&lt;T&gt;</code>, but in this type of code, the benefits are negligible in my experience. It&#39;s concurrent for the queue, but you still have to lock to update your own statistics variables and then the usage pattern gets uncomfortable.</li></ul></li><li>A number of other more basic components like threads, wait handles, etc. (not recommended).</li></ul><p>The first 2 components are pre-built to take care of only executing one job at a time while queuing up the others.</p><p>You can then use a <code>Dictionary&lt;CustomerId, Worker&gt;</code> to represent what&#39;s happening overall.</p><p>I actually <a href="https://codereview.stackexchange.com/questions/83696/command-dispatcher-for-messaging-using-mailboxprocessor">built this</a> in F# using MailboxProcessors. It takes care of keeping an agent per whatever criteria you can pull from the message like CustomerId. It cleans up idle agents automatically.</p><blockquote><p>could such a design scale across machines, should the need arise to throw more hardware at it?</p></blockquote><p>Scaling across machines can be done in various ways. Likely what you will want is partitioning. The easiest way is by hashing on some request value to decide which server to send to. For instance, if your customer ID is an integer (or can be consistently reduced to one... e.g. with GetHashCode) and you have 3 machines processing tasks, you can use a simple modulus to decide which customer should go to which machine. <code>machineNumber = customerId % 3</code>. CustomerId 1,4,7, etc will always go to machine 1. However, if Machine 1 goes down, 1/3 of the customer requests will not get processed until it comes back up. Since these are long running imports anyway, that&#39;s likely not a big deal. The load will also not be distributed evenly, since there are usually some customers who are heavier users. Again, probably not a huge deal. Measure to make sure.</p><p>Another way that is resilient to failure is to use a distributed directory. It  keeps track of which node currently owns which customer. <a href="http://research.microsoft.com/en-us/projects/orleans/" rel="nofollow noreferrer">Project Orleans</a> uses a mechanism like this. It allows for nodes to fail and customers to be transitioned to another node. Before allocating a new customer on a node, you can also query the node to see which is the least loaded. However, I&#39;m not aware of a pre-built component for this purpose, and building it yourself is perilous to your time.</p><blockquote><p>if that&#39;s the case, I guess I should deploy a new instance of my service on the other machines, right?</p></blockquote><p>Correct. Having partitioning be separate from the worker, the same worker service code could be running on all servers. The worker service is ignorant of how it is partitioned.</p><blockquote><p>how do you establish dependencies between jobs?</p></blockquote><p>The dependency you&#39;ve described so far is only temporal, and your application prevents the user from submitting files out of order. So I am not understanding your need here. The worker components described above process jobs one at a time in order. So long as you submit them in temporal order, you&#39;re good.</p><p>When I have done dependencies in the past (example: if FileTypeB and FileTypeA are both in queue, then FileTypeA must be processed first), I was doing a custom worker where I kept multiple data structures to represent the queue of work. For example, a <code>Dictionary&lt;CustomerId, Tuple&lt;Worker, List&lt;FileRequest&gt;&gt;&gt;</code> (not that I would actually use tuple here). Basically, each customer had a worker and a list of outstanding requests. When the worker came available, I would scan the outstanding requests, determine dependencies, and pick one with the highest priority (the most depended on) -- all under <code>lock</code>. Then the chosen file was processed.</p><p>For the F# MailboxProcessor, there also exist the <a href="https://msdn.microsoft.com/en-us/library/ee370554.aspx" rel="nofollow noreferrer">Scan method</a> which can be used to scan the submitted messages until a desirable one is chosen. However, this probably wouldn&#39;t work as well for an exhaustive search like a finding the lowest date.</p><p>As far as how to represent dependencies, a tree structure is common.</p><pre><code>FileTypeC -&gt; FileTypeB -&gt; FileTypeA
</code></pre><blockquote><p>I guess I should take measures to somehow take and persist a snapshot of the queue every X minutes, in case the server goes down or needs to be rebooted.</p></blockquote><p>Instead of periodically persisting the queue, just save each request as it comes in and update it as changes phases... example: queued/complete. On restart, you can query the database for incomplete jobs and try to resubmit them to workers. I might add some guards into the worker (especially if it is on a separate server) so that when a job is submitted, it will check its internal state for the same job (e.g. by job id) and respond with a &#34;No, this job is already queued/running/complete.&#34; as necessary.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='https://free-tor-game.com/software/building-a-redundant-distributed-application/'>Building a Redundant / Distributed Application</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/c-sql-query-or-c-net-code-for-csv-files-import/'>C# &#8211; SQL query or C# .net code for csv files import</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='http://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="https://free-tor-game.com/wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>