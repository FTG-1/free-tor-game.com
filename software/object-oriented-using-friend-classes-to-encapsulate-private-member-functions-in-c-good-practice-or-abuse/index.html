<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Using friend classes to encapsulate private member functions in C++ &#8211; good practice or abuse &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1076293 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1076293" class="post-1076293 software type-software status-publish hentry category-software tag-c tag-design-patterns tag-encapsulation tag-object-oriented"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Using friend classes to encapsulate private member functions in C++ &#8211; good practice or abuse</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">design-patterns</span><span class="mr-2 badge badge-warning">encapsulation</span><span class="mr-2 badge badge-primary">object-oriented</span></p><div class="entry-content"><p>So I noticed it&#39;s possible to avoid putting private functions in headers by doing something like this:</p><pre><code>// In file pred_list.h:
    class PredicateList
    {
        int somePrivateField;
        friend class PredicateList_HelperFunctions;
    public:
        bool match();
    } 

// In file pred_list.cpp:
    class PredicateList_HelperFunctions
    {
        static bool fullMatch(PredicateList&amp; p)
        {
            return p.somePrivateField == 5; // or whatever
        }
    }

    bool PredicateList::match()
    {
        return PredicateList_HelperFunctions::fullMatch(*this);
    }
</code></pre><p>The private function is never declared in the header, and consumers of the class which import the header don&#39;t ever need to know it exists. This is required if the helper function is a template (the alternative is putting the full code in the header), which is how I &#34;discovered&#34; this. Another nice upside of not needing to recompile every file that includes the header if you add/remove/modify a private member function. All the private functions are in the .cpp file.</p><p>So&#8230;</p><ol><li>Is this a well-known design pattern that there&#39;s a name for?</li><li>To me (coming from a Java/C# background and learning C++ on my own time), this seems like a very good thing, since the header is defining an interface, while the .cpp is defining an implementation (and the improved compile time is a nice bonus). However, it also smells like it&#39;s abusing a language feature not intended to be be used that way. So, which is it? Is this something you would frown on seeing in a professional C++ project?</li><li>Any pitfalls I&#39;m not thinking of?</li></ol><p>I&#39;m aware of Pimpl, which is a much more robust way of hiding the implementation at the library edge. This is more for use with internal classes, where Pimpl would cause performance issues, or not work because the class needs to be treated as a value.</p><hr/><p>EDIT 2: Dragon Energy&#39;s excellent answer below suggested the following solution, which doesn&#39;t use the <code>friend</code> keyword at all:</p><pre><code>// In file pred_list.h:
    class PredicateList
    {
        int somePrivateField;
        class Private;
    public:
        bool match();
    } 

// In file pred_list.cpp:
    class PredicateList::Private
    {
    public:
        static bool fullMatch(PredicateList&amp; p)
        {
            return p.somePrivateField == 5; // or whatever
        }
    }

    bool PredicateList::match()
    {
        return PredicateList::Private::fullMatch(*this);
    }
</code></pre><p>This avoids the shock factor of <code>friend</code> (which seems to have been demonized like <code>goto</code>) while still maintaining the same principle of separation.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>It&#39;s a bit esoteric to say the least as you already recognized which might have me scratching my head for a moment when I first start encountering your code wondering what you&#39;re doing and where these helper classes are implemented until I start to pick up your style/habits (at which point I might get totally used to it).</p><p>I do like that you&#39;re reducing the amount of information in the headers. Especially in very large codebases, that can have practical effects to reduce compile-time dependencies and ultimately build times.</p><p>My gut reaction though is that if you feel a need to hide implementation details this way, to favor parameter passing to free-standing functions with internal linkage in the source file. Usually you can implement utility functions (or whole classes) useful for implementing a particular class without having access to all the internals of the class and instead just pass in the relevant ones from the implementation of a method to the function (or constructor). And naturally that has the bonus of reducing coupling between your class and the &#34;helpers&#34;. It also has a tendency to generalize what might have otherwise been &#34;helpers&#34; further if you find that they&#39;re starting to serve a more generalized purpose applicable to more than one class implementation.</p><blockquote><blockquote><p>I also sometimes cringe a bit when I see lots of &#34;helpers&#34; in code. It&#39;s not always true but sometimes they can be symptomatic of a developer who is just decomposing functions willy-nilly to eliminate code duplication with huge blobs of data being passed around to functions with barely comprehensible names/purposes beyond the fact that they reduce the amount of code required to implement some other functions. Just a little teeny bit more thought upfront can sometimes lead to much greater clarity in terms of how the implementation of a class is decomposed into further functions, and favoring passing specific parameters to passing whole instances of your object around with full access to internals can help promote that style of design thought. I&#39;m not suggesting you&#39;re doing that, of course (I have no idea), but maybe to watch out for that tendency when we get too happy with the &#34;helpers&#34;.</p></blockquote></blockquote><p>If that becomes unwieldy, I&#39;d consider a second, more idiomatic solution which is the pimpl (I realize you mentioned issues with it but I think you can generalize a solution to avoid those with minimal effort). That can move a whole lot of information your class needs to be implemented including its private data away from the header wholesale. The performance issues of the pimpl can largely be mitigated with a dirt-cheap constant-time allocator* like a free list while preserving value semantics without having to implement full-blown user-defined copy ctor.</p><blockquote><blockquote><ul><li>For the performance aspect the pimpl does introduce a pointer overhead at the very least, but I think the cases have to be pretty serious where the poses a practical concern. If the spatial locality isn&#39;t degraded significantly through the allocator, then your tight loops iterating over the object (which should generally be homogeneous if performance is that much of a concern) will still tend to minimize cache misses in practice provided you use something like a free list to allocate the pimpl, putting the fields of the class into largely contiguous memory blocks.</li></ul></blockquote></blockquote><p>Personally only after exhausting those possibilities would I consider something like this. I do think it&#39;s a decent idea if the alternative is like more private methods exposed to the header with perhaps only the esoteric nature of it being the practical concern.</p><p><strong>An Alternative</strong></p><p>One alternative that popped into my head just now that largely accomplishes your same purposes absent friends is like this:</p><pre><code>struct PredicateListData
{
     int somePrivateField;
};

class PredicateList
{
    PredicateListData data;
public:
    bool match() const;
};

// In source file:
static bool fullMatch(const PredicateListData&amp; p)
{
     // Can access p.somePrivateField here.
}

bool PredicateList::match() const
{
     return fullMatch(data);
}
</code></pre><p>Now that might seem like a very moot difference and I&#39;d still call it a &#34;helper&#34; (in a possibly derogatory sense since we&#39;re still passing the entire internal state of the class to the function whether it needs it all or not) except it does avoid the &#34;shock&#34; factor of encountering <code>friend</code>. In general <code>friend</code> looks a bit scary to see frequently absent further inspection, since it says that your class internals are accessible elsewhere (which carries the implication that it might be incapable of maintaining its own invariants). With the way you are using <code>friend</code> it becomes rather moot if people are aware of the practice since the <code>friend</code> is just residing in the same source file helping to implement the private functionality of the class, but the above accomplishes much the same effect at least with the one possibly arguable benefit that it doesn&#39;t involve any friends which avoids that whole kind (&#34;Oh shoot, this class has a friend. Where else does its privates get accessed/mutated?&#34;). Whereas the immediately above version immediately communicates that there&#39;s no way for the privates to be accessed/mutated outside of anything done in the implementation of <code>PredicateList</code>.</p><p>That is perhaps moving towards somewhat dogmatic territories with this level of nuance since anyone can quickly figure out if you uniformly name things <code>*Helper*</code> and put them all in the same source file that it&#39;s all kind of bundled together as part of the private implementation of a class. But if we get nit-picky then maybe the immediately above style won&#39;t cause as much of a knee-jerk reaction at a glance absent the <code>friend</code> keyword which tends to look a little bit scary.</p><p>For the other questions:</p><blockquote><blockquote><p>A consumer could define their own class PredicateList_HelperFunctions, and let them access the private fields. While I don&#39;t see this as a huge issue (if you really wanted at those private fields you could do some casting), maybe it would encourage consumers to use it that way?</p></blockquote></blockquote><p>That might be a possibility across API boundaries where the client could define a second class with the same name and gain access to the internals that way without linkage errors. Then again I&#39;m largely a C coder working in graphics where safety concerns at this level of &#34;what if&#34; are very low on the priority list, so concerns like these are just ones I tend to wave my hands at and do a dance and try to pretend like they don&#39;t exist. :-D If you&#39;re working in a domain where concerns like these are rather serious though, I think that&#39;s a decent consideration to make.</p><p>The above alternative proposal also avoids suffering this issue. If you still want to stick to using <code>friend</code> though, you can also avoid that issue by making the helper a private nested class.</p><pre><code>class PredicateList
{
    ...

    // Declare nested class.
    class Helper;

    // Make it a friend.
    friend class Helper;

public:
    ...
};

// In source file:
class PredicateList::Helper
{
    ...
};
</code></pre><blockquote><blockquote><p>Is this a well-known design pattern that there&#39;s a name for?</p></blockquote></blockquote><p>None to my knowledge. I kind of doubt there would be one since it&#39;s really getting into the minutia of implementation details and style.</p><p><strong>&#34;Helper Hell&#34;</strong></p><p>I got a request for further clarification on the point about how I sometimes cringe when I see implementations with lots of &#34;helper&#34; code, and that might be slightly controversial with some but it is actually factual as I really did cringe when I was debugging some of my colleagues&#39; implementation of a class only to find loads of &#34;helpers&#34;. :-D And I wasn&#39;t the only on the team scratching my head trying to figure out what all these helpers are supposed to do exactly. I also don&#39;t want to come off dogmatic like <em>&#34;Thou shalt not use helpers,&#34;</em> but I would make a tiny suggestion that it might help to think about how to implement things absent of them when practical.</p><blockquote><blockquote><p>Aren&#39;t all private member functions helper functions by definition?</p></blockquote></blockquote><p>And yes, I am including private methods. If I see a class with like a straightforward public interface but like an endless set of private methods which are somewhat ill-defined in purpose like <code>find_impl</code> or <code>find_detail</code> or <code>find_helper</code>, then I also cringe in a similar way.</p><p>What I&#39;m suggesting as an alternative is nonmember nonfriend functions with internal linkage (declared <code>static</code> or inside an anonymous namespace) to help implement your class with at least a more generalized purpose than &#34;a function which helps implement others&#34;. And I can cite Herb Sutter from C++ &#39;Coding Standards&#39; here for why that can be preferable from a general SE standpoint:</p><blockquote><blockquote><p>Avoid membership fees: Where possible, prefer making functions nonmember nonfriends. [...] Nonmember nonfriend functions improve encapsulation by minimizing dependencies: The body of the function cannot come to depend on the nonpublic members of the class (see Item 11). They also break apart monolithic classes to liberate separable functionality, further reducing coupling (see Item 33).</p></blockquote></blockquote><p>You can also understand the &#34;membership fees&#34; he talks about to some degree in terms of the basic principle of narrowing variable scope. If you imagine, as the most extreme example, a God object which has all the code required for your entire program to run, then favoring &#34;helpers&#34; of this sort (functions, whether member functions or friends) which can access all the internals (privates) of a class basically render those variables no less problematic than global variables. You have all the difficulties of managing state correctly and thread safety and maintaining invariants that you would get with global variables in this most extreme example. And of course most real examples are hopefully not anywhere close to this extreme, but information hiding is only as useful as it is limiting the scope of the information being accessed.</p><p>Now Sutter already gives a nice explanation here but I&#39;d also add further that the decoupling tends to promote like a psychological improvement (at least if your brain works like mine) in terms of how you design functions. When you start designing functions that can&#39;t access everything in the class except only the relevant parameters you pass it or, if you pass the instance of the class as a parameter, only its public members, it tends to promote a design mindset that favors functions which have a clearer purpose, on top of the decoupling and promoting improved encapsulation, than what you might otherwise be tempted to design if you could just access everything.</p><p>If we go back to the extremities then a codebase riddled with global variables doesn&#39;t exactly tempt developers to design functions in a way that&#39;s clear and generalized in purpose. Very quickly the more information you can access in a function, the more many of us mortals face the temptation to degeneralize it and reduce its clarity in favor of accessing all this extra information that we have instead of accepting more specific and relevant parameters to that function to narrow its access to state and widen its applicability and improve its clarity of intentions. That applies (although generally to some lesser degree) with member functions or friends.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-the-exact-syntax-of-inline/'>C++ &#8211;  the exact syntax of inline</a></li><li class="list-group-item"><a href='../c-unit-test-private-method-in-c-using-a-friend-class/'>C++ &#8211; Unit test private method in c++ using a friend class</a></li><li class="list-group-item"><a href='../c-force-derived-class-to-implement-static-method-c/'>C# &#8211; Force Derived Class to Implement Static Method C#</a></li><li class="list-group-item"><a href='../can-a-pimpl-variation-be-implemented-without-any-performance-penalty/'>Can a pimpl variation be implemented without any performance penalty</a></li><li class="list-group-item"><a href='../c-header-files-design-just-like-defining-an-api/'>C++ Header files design : just like defining an API</a></li><li class="list-group-item"><a href='../c-are-header-only-libraries-more-efficient/'>C++ &#8211; Are header-only libraries more efficient</a></li><li class="list-group-item"><a href='../c-how-to-separate-public-and-mostly-private-code-in-c-friend-classes-pimpl-pattern-etc/'>C# &#8211; How to separate public and &#8220;mostly private&#8221; code in C#? (Friend classes, PIMPL pattern, etc.)</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>