<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Understanding the differences: traditional interpreter, JIT compiler, JIT interpreter and AOT compiler &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1063410 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1063410" class="post-1063410 software type-software status-publish hentry category-software tag-compilation tag-interpreters tag-jit"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Understanding the differences: traditional interpreter, JIT compiler, JIT interpreter and AOT compiler</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">compilation</span><span class="mr-2 badge badge-info">interpreters</span><span class="mr-2 badge badge-warning">jit</span></p><div class="entry-content"><p>I&#39;m trying to understand the differences between a traditional interpreter, a JIT compiler, a JIT interpreter and an AOT compiler.</p><p>An interpreter is just a machine (virtual or physical) that executes instructions in some computer language. In that sense, the JVM is an interpreter and physical CPUs are interpreters.</p><p>Ahead-of-Time compilation simply means compiling the code to some language before executing (interpreting) it.</p><p>However I&#39;m not sure about the exact definitions of a JIT compiler and a JIT interpreter.</p><p>According to a definition I read, JIT compilation is simply compiling the code <em>just</em> before interpreting it.</p><p>So basically, JIT compilation is AOT compilation, done right before execution (interpretation)?</p><p>And a JIT interpreter, is a program that contains both a JIT compiler and an interpreter, and compiles code (JITs it) just before it interprets it?</p><p>Please clarify the differences.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><h1>Overview</h1><p>An <em>interpreter</em> for language <strong>X</strong> is a program (or a machine, or just some kind of mechanism in general) that executes any program <strong>p</strong> written in language <strong>X</strong> such that it performs the effects and evaluates the results as prescribed by the specification of <strong>X</strong>. CPUs are usually interpreters for their respective instructions sets, although modern high-performance workstation CPUs are actually more complex than that; they may actually have an underlying proprietary private instruction set and either translate (compile) or interpret the externally visible public instruction set.</p><p>A <em>compiler</em> from <strong>X</strong> to <strong>Y</strong> is a program (or a machine, or just some kind of mechanism in general) that translates any program <strong>p</strong> from some language <strong>X</strong> into a semantically equivalent program <strong>p′</strong> in some language <strong>Y</strong> in such a way that the semantics of the program are preserved, i.e. that interpreting <strong>p′</strong> with an interpreter for <strong>Y</strong> will yield the same results and have the same effects as interpreting <strong>p</strong> with an interpreter for <strong>X</strong>. (Note that <strong>X</strong> and <strong>Y</strong> may be the same language.)</p><p>The terms <em>Ahead-of-Time (AOT)</em> and <em>Just-in-Time (JIT)</em> refer to <em>when</em> compilation takes place: the &#34;time&#34; referred to in those terms is &#34;runtime&#34;, i.e. a JIT compiler compiles the program <em>as it is running</em>, an AOT compiler compiles the program <em>before it is running</em>. Note that this requires that a JIT compiler from language <strong>X</strong> to language <strong>Y</strong> must somehow work together with an interpreter for language <strong>Y</strong>, otherwise there wouldn&#39;t be any way to run the program. (So, for example, a JIT compiler which compiles JavaScript to x86 machine code doesn&#39;t make sense without an x86 CPU; it compiles the program while it is running, but without the x86 CPU the program wouldn&#39;t be running.)</p><p>Note that this distinction doesn&#39;t make sense for interpreters: an interpreter runs the program. The idea of an AOT interpreter that runs a program before it runs or a JIT interpreter that runs a program while it is running is nonsensical.</p><p>So, we have:</p><ul><li>AOT compiler: compiles before running</li><li>JIT compiler: compiles while running</li><li>interpreter: runs</li></ul><h1>JIT Compilers</h1><p>Within the family of JIT compilers, there are still many differences as to <em>when exactly</em> they compile, <em>how often</em>, and at what granularity.</p><p>For example, some JIT compilers compile code as soon as it is loaded for the first time. Some JIT compilers wait until the code needs to be executed. Some JIT compilers compile code only once. Some may choose to recompile code later. Some compile whole modules or classes, some whole methods, some only smaller blocks.</p><p>Some compilers may gather information while the program is running and recompile code several times as new information becomes available that allows them to better optimize it. Some JIT compilers are even capable of <em>de-optimizing</em> code. Now, you might ask yourself why one would ever want to do that? De-optimizing allows you to perform very aggressive optimizations that might actually be unsafe: if it turns out you were <em>too</em> aggressive you can just back out again, whereas, with a JIT compiler that cannot de-optimize, the program would crash or return a wrong result; in other words, you simply can&#39;t allow yourself to perform the aggressive optimizations in the first place.</p><p>JIT compilers may either compile some static unit of code in one go (one module, one class, one function, one method, …; these are typically called <em>method-at-a-time</em> JIT, for example) or they may <em>trace</em> the dynamic execution of code to find dynamic <em>traces</em> (typically loops) that they will then compile (these are called <em>tracing</em> JITs).</p><h1>Combining Interpreters and Compilers</h1><p>Interpreters and compilers may be combined into a single language execution engine. There are two typical scenarios where this is done.</p><p>Combining an AOT compiler from <strong>X</strong> to <strong>Y</strong> with an interpreter for <strong>Y</strong>. Here, typically <strong>X</strong> is some higher-level language optimized for readability by humans, whereas <strong>Y</strong> is a compact language (often some kind of bytecode) optimized for interpretability by machines. For example, the CPython Python execution engine has an AOT compiler that compiles Python sourcecode to CPython bytecode and an interpreter that interprets CPython bytecode. Likewise, the (original) YARV Ruby execution engine has an AOT compiler that compiles Ruby sourcecode to YARV bytecode and an interpreter that interprets YARV bytecode. (Note: more recent versions of YARV also have a JIT compiler.) Why would you want to do that? Ruby and Python are both very high-level and somewhat complex languages, so we first compile them into a language that is easier to parse and easier to interpret, and then interpret <em>that</em> language.</p><p>The other way to combine an interpreter and a compiler is a <em>mixed-mode</em> execution engine. Here, we &#34;mix&#34; two &#34;modes&#34; of implementing the <em>same</em> language together, i.e. an interpreter for <strong>X</strong> and a JIT compiler from <strong>X</strong> to <strong>Y</strong>. (So, the difference here is that in the above case, we had multiple &#34;stages&#34; with the compiler compiling the program and then feeding the result into the interpreter, here we have the two working <em>side-by-side</em> on the same language.) Code that has been compiled by a compiler tends to run faster than code that is executed by an interpreter, but actually compiling the code first takes time (and particularly, if you want to heavily optimize the code to run <em>really</em> fast, it takes a <em>lot</em> of time). So, to bridge this time where the JIT compiler is busy compiling the code, the interpreter can already start running the code, and once the JIT is finished compiling, we can switch execution over to the compiled code. This means that we get both the best possible performance of the compiled code, but we don&#39;t have to wait for the compilation to finish, and our application starts running straight away (although not as fast as could be).</p><p>This is actually just the simplest possible application of a mixed-mode execution engine. More interesting possibilities are, for example, to not start compiling right away, but let the interpreter run for a bit, and collect statistics, profiling information, type information, information about the likelihood of which specific conditional branches are taken, which methods are called most often etc. and then feed this dynamic information to the compiler so that it can generate more optimized code. This is also a way to implement the de-optimization I talked about above: if it turns out that you were too aggressive in optimizing, you can throw away (a part of) the code and revert back to interpreting. The HotSpot JVM does this, for example. It contains both an interpreter for JVM bytecode as well as a compiler for JVM bytecode. (In fact, it actually contains <em>two</em> compilers!)</p><p>It is also possible and in fact common to combine those two approaches: two phases with the first being an AOT compiler that compiles <strong>X</strong> to <strong>Y</strong> and the second phase being a mixed-mode engine that both interprets <strong>Y</strong> and compiles <strong>Y</strong> to <strong>Z</strong>. The Rubinius Ruby execution engine works this way, for example: it has an AOT compiler that compiles Ruby sourcecode to Rubinius bytecode and a mixed-mode engine that first interprets Rubinius bytecode and once it has gathered some information compiles the most often called methods into native machine code. The same applies to current versions of YARV.</p><p>Note that the role that the interpreter plays in the case of a mixed-mode execution engine, namely providing fast startup, and also potentially collecting information and providing fallback capability may alternatively also be played by a second JIT compiler.</p><p>This is how the second generation of Google&#39;s V8 ECMAScript engine worked, for example. This generation of V8 never interprets, it always compiles. The first compiler is a very fast, very slim compiler that starts up very quick. The code it produces isn&#39;t very fast, though. This compiler also injects profiling code into the code it generates. The other compiler is slower and uses more memory, but produces much faster code, and it can use the profiling information collected by running the code compiled by the first compiler. (Note: V8 has significantly changed in the meantime. It now also has an interpreter, for example.)</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-c-when-should-aot-be-considered-if-reverse-engineering-is-a-concern/'>Java/C# &#8211; When should AOT be considered if reverse engineering is a concern</a></li><li class="list-group-item"><a href='../java-the-industry-definition-of-an-interpreter-as-opposed-to-a-compiler/'>Java &#8211;  the industry definition of an interpreter (as opposed to a compiler)</a></li><li class="list-group-item"><a href='../when-an-interpreter-executes-code-is-there-a-chain-of-interpretations-down-to-the-lowest-level/'>When an interpreter executes code: Is there a &#8220;chain of interpretations&#8221; down to the lowest level</a></li><li class="list-group-item"><a href='../object-oriented-is-prototypal-inheritance-inherently-slower/'>Object-oriented &#8211; Is prototypal inheritance inherently slower</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>