<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Why F#, Rust and others use Option type instead of nullable types like C# 8 or TypeScript &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1065683 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1065683" class="post-1065683 software type-software status-publish hentry category-software tag-language-design tag-null"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Why F#, Rust and others use Option type instead of nullable types like C# 8 or TypeScript</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">language-design</span><span class="mr-2 badge badge-info">null</span></p><div class="entry-content"><p>AFAIK, <code>Option</code> type will have runtime overhead, while nullable types won&#39;t, because <code>Option</code> time is an enum (consuming memory).</p><p>Why not just mark optional references as optional, then the compiler can follow code execution and find whenever it can&#39;t more be <code>null</code>?</p><p><strong>Edit</strong>: I see I was misunderstood. I understand and agree with the advantages of avoiding null pointers. I&#39;m not talking about arbitrary pointers that accept <code>null</code>. I&#39;m only asking why not use compile-time metadata, like C# 8&#39;s nullable reference types and TypeScript with strict null checks, where default pointers can&#39;t be null and there&#39;s a special syntax (mostly <code>?</code>) to indicate a pointer that can accept null.</p><p><strong>Edit 2</strong>:</p><p>Also, <code>Some</code> is strange, in my opinion. Implicit conversion would be better. But that a language feature and not relevant.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>The purpose of <em>Null Tracking</em> in general (of which Nullable Types are only one of many different forms), is to somehow regain a modicum of safety (and sanity) in languages that have null references.</p><p><em>If</em> you have the chance to eliminate null references altogether, that is a <em>much better solution</em> since the problems that null references cause <em>simply will not exist</em> in the first place. Sir Tony Hoare has famously said that he considers inventing the Null Reference his &#34;Billion Dollar Mistake&#34;, which is actually a quite conservative estimate on the total costs that null references have caused until today. If even the person who invented them considers them a mistake, why would you willingly put them in a language?</p><p>C# has them because, well, they probably didn&#39;t know any better, and now they can&#39;t get rid of them because of backwards-compatibility. TypeScript has them because its semantics are based on ECMAScript&#39;s, which has them.</p><p>The <em>real</em> beauty of an <code>Option</code> type, though, is that it is isomorphic to a collection that can only hold from zero to one elements. Dealing with collections is one of the most important parts of programming, and thus every language in the world has powerful collections libraries. And you can apply all of the work that has gone into collections also to <code>Option</code> types.</p><p>For example, if you want to execute an action with an option, you <em>don&#39;t</em> need to check whether it is defined! Every collection library on the planet has a way of iterating over a collection and executing an action for each element. Now, what does &#34;executing an action for each element&#34; mean for an <code>Option</code>? Well, if there is no element, then no action is executed. And if there is one element, then the action is executed once with that element.</p><p>In other words, <code>foreach</code> acts <em>exactly</em> like a <code>NULL</code> check! You can just blindly do</p><pre class="lang-scala prettyprint-override"><code>mightExistOrMightNot.foreach(println)
</code></pre><p>and it will print out the value contained in the <code>Option</code> if it exists and do nothing if it doesn&#39;t exist. The same applies when you want to perform a computation with the value. Every collections library on the planet has a way of iteration over a collection and transforming each element. Again, for an <code>Option</code> &#34;transforming each element&#34; translates to &#34;transform the value or do nothing&#34;. So you can just do</p><pre class="lang-scala prettyprint-override"><code>val squared: Option[Int] = mightExistOrMightNot.map(_ ** 2)
</code></pre><p>Also, collections libraries have ways to flatten nested collections. Imagine you have a long chain of references, each of which could be <code>NULL</code>, and you wanted to access the last reference in that chain. With nested <code>Option</code>s, you just write</p><pre class="lang-scala prettyprint-override"><code>longListOfReferences.flatten
</code></pre><p>And if you want to get a value out of an <code>Option</code>, then you can simply write</p><pre class="lang-scala prettyprint-override"><code>mightExistOrMightNot.getOrElse(42)
</code></pre><p>and you will either get the value inside the option if it exists, or a default value of your choosing if it doesn&#39;t.</p><p>The <em>only</em> reason, really, for you to explicitly check for the existence of an <code>Option</code> is if you want to do something <em>completely different</em> in case the value is missing.</p><p>It turns out that <code>Option</code> is actually even more than &#34;just&#34; a collection. It is a <em>monad</em>. Languages like C#, Scala, and Haskell have built in syntax sugar for working with monads, and they have powerful libraries for working with monads. I will not go into details about what it means to be a monad, but e.g. one of the advantages is that there are some specific mathematical laws and properties associated with monads, and one can exploit those properties.</p><p>The fact that Java&#39;s <code>Optional</code> is not implemented as a monad, not even as a collection, is a significant design flaw, and I think is partially to blame for people not understanding the advantages of <code>Option</code>s, simply because some of those advantages cannot be realized with Java&#39;s <code>Optional</code>.</p><p>There is also a more philosophical reason for choosing an <code>Option</code> type over <code>NULL</code> references. We can call this &#34;language democracy&#34;. There is a major difference between those two: <code>NULL</code> references are a <em>language feature</em> whereas <code>Option</code> is a <em>library type</em>.</p><p><em>Everybody</em> can write a library type, but only the language designer can write a language feature. That means that if for my code, I need to handle the absence of values in a slightly different manner, I can write a <code>MyOption</code>. But I cannot write a <code>MYNULL</code> reference without changing the language semantics and thus the compiler (or, for a language like C, C++, Java, Go, ECMAScript, Python, Ruby, PHP with multiple implementations, <em>every single compiler and interpreter that exists, has existed, and will ever exist</em>).</p><p>The more the language designer moves out of the language into libraries, the more the programmers can tailor the language (really, the library) to their needs.</p><p>Also, the more the language designer moves out of the language into libraries, the more the compiler writers are forced to make library code fast. If a compiler writer figures out some clever trick to make <code>NULL</code> references fast, that doesn&#39;t help our hypothetical programmer who has written their own abstraction. But if a compiler writer figures out some clever trick to make <code>Option</code> fast, it is highly likely the same trick will also apply to <code>MyOption</code> (and <code>Try</code>, <code>Either</code>, <code>Result</code>, and possibly even every collection).</p><p>Take Scala, for example. Unfortunately, because it is designed to interoperate and integrate deeply with the host environment (the Java platform, the ECMAScript platform, there is also an abandoned CLI implementation), it has <code>null</code> references and exceptions. But, it also has the <code>Option</code> type which replaces the former and <code>Try</code> which replaces the latter. And <code>Try</code> first appeared in a library of helpers released by Twitter. It was only later added to the standard library. Such innovation is much harder to do with language features.</p><p>I can write my own Scala <code>Option</code> type, and I don&#39;t need to change the compiler for it:</p><pre class="lang-scala prettyprint-override"><code>sealed trait Option[+A] extends IterableOnce[A]:
  override def iterator: Iterator[A]
  override def knownSize: Int

  def isEmpty: Boolean
  def getOrElse[B &gt;: A](default: =&gt; B): B
  def foreach[U](f: A =&gt; U): Unit
  def map[B](f: A =&gt; B): Option[B]
  // … and so on

final case class Some[+A](value: A) extends Option[A]:
  override def iterator = collection.Iterator.single(value)
  override val isEmpty = false
  
  override val knownSize = 1
  override def getOrElse[B &gt;: A](default: =&gt; B) = value
  override def foreach[U](f: A =&gt; U) = f(value)
  override def map[B](f: A =&gt; B) = Some(f(value))
  // … and so on

case object None extends Option[Nothing]:
  override def iterator = collection.Iterator.empty
  override val isEmpty = true

  override val knownSize = 0
  override def getOrElse[B](default: =&gt; B) = default
  override def foreach[U](f: Nothing =&gt; U) = ()
  override def map[B](f: Nothing =&gt; B) = None
  // … and so on

@main def test = Some(23).foreach(println)
</code></pre><p><a href="https://scastie.scala-lang.org/JoergWMittag/legxp04eRCembpW6xzbfhQ/4" rel="nofollow noreferrer">Try it out here</a>.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-alternatives-to-null-values-and-option-like-types/'>Java &#8211; Alternatives to null values and option-like types</a></li><li class="list-group-item"><a href='../java-why-do-checked-exceptions-i-e-value-or-error-return-values-work-well-in-rust-and-go-but-not-in-java/'>Java &#8211; Why do &#8220;checked exceptions&#8221;, i.e., &#8220;value-or-error return values&#8221;, work well in Rust and Go but not in Java</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>