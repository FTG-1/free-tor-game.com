<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Why are interfaces more helpful than superclasses in achieving loose coupling &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1070972 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1070972" class="post-1070972 software type-software status-publish hentry category-software tag-design tag-interfaces tag-object-oriented"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Why are interfaces more helpful than superclasses in achieving loose coupling</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">design</span><span class="mr-2 badge badge-info">interfaces</span><span class="mr-2 badge badge-warning">object-oriented</span></p><div class="entry-content"><p>(<em>For the purpose of this question, when I say &#39;interface&#39; <strong>I mean the language construct <code>interface</code></strong>, and not an &#39;interface&#39; in the other sense of the word, i.e. the public methods a class offers the outside world in order to communicate with and manipulate it.</em>)</p><p>Loose coupling can be achieved by having an object depend on an abstraction instead of a concrete type.</p><p>This allows for loose coupling for two main reasons: <strong>1-</strong> abstractions are less likely to change than concrete types, which means the dependent code is less likely to break. <strong>2-</strong> different concrete types can be used at runtime, because they all fit the abstraction. New concrete types can also be added later with no need to alter the existing dependent code.</p><p>For example, consider a class <code>Car</code> and two subclasses <code>Volvo</code> and <code>Mazda</code>.</p><p>If your code depends on a <code>Car</code>, it can use either a <code>Volvo</code> or a <code>Mazda</code> during runtime. Also later on additional subclasses could be added with no need to change the dependent code.</p><p>Also, <code>Car</code> &#8211; which is an abstraction &#8211; is less likely to change than <code>Volvo</code> or <code>Mazda</code>. Cars have been generally the same for quite some time, but Volvos and Mazdas are far more likely to change. I.e. abstractions are more stable than concrete types.</p><p>All of this was to show that I understand what loose coupling is and how it is achieved by depending on abstractions and not on concretions. (If I wrote something inaccurate please say so).</p><p><strong>What I don&#39;t understand is this:</strong></p><p><strong>Abstractions can be superclasses or interfaces.</strong></p><p><strong>If so, why are interfaces specifically praised for their ability to allow loose coupling? I don&#39;t see how it&#39;s different than using a superclass.</strong></p><p>The only differences I see are: 1- Interfaces aren&#39;t limited by single inheritance, but that doesn&#39;t have much to do with the topic of loose coupling. 2- Interfaces are more &#39;abstract&#39; since they have no implementation logic at all. But still, I don&#39;t see why that makes such a big difference.</p><p><strong>Please explain to me why interfaces are said to be great in allowing loose coupling, while simple superclasses are not.</strong></p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Terminology: I&#39;ll refer to the language construct <code>interface</code> as <em>interface</em>, and to the interface of a type or object as <em>surface</em> (for a lack of a better term).</p><blockquote><p>Loose coupling can be achieved by having an object depend on an abstraction instead of a concrete type.</p></blockquote><p>Correct.</p><blockquote><p>This allows for loose coupling for two main reasons: <strong>1</strong>- abstractions are less likely to change than concrete types, which means the dependent code is less likely to break. <strong>2</strong>- different concrete types can be used at runtime, because they all fit the abstraction. New concrete types can also be added later with no need to alter the existing dependent code.</p></blockquote><p>Not quite correct. Current languages do not generally anticipate that an abstraction will change (although there are some design patterns to handle that). Separating specifics from general things <em>is</em> abstraction. This is usually done by some <em>layer of abstraction</em>. This layer can be changed to some other specifics without breaking code that builds upon this abstraction – loose coupling is achieved. Non-OOP example: A <code>sort</code> routine might be changed from Quicksort in version 1 to Tim Sort in version 2. Code that only depends on the result being sorted (i.e. builds upon the <code>sort</code> abstraction) is therefore decoupled from the actual sorting implementation.</p><p>What I termed <em>surface</em> above is the <em>general part</em> of an abstraction. It now happens in OOP that one object must sometimes support multiple abstractions. A not-quite optimal example: Java&#39;s <code>java.util.LinkedList</code> supports both the <code>List</code> interface which is about the “ordered, indexable collection” abstraction, and supports the <code>Queue</code> interface which (in rough terms) is about the “FIFO” abstraction.</p><p>How can an object support multiple abstractions?</p><p>C++ doesn&#39;t have interfaces, but it has multiple inheritance, virtual methods, and abstract classes. An abstraction can then be defined as an abstract class (i.e. a class that cannot be immediately instantiated) that declares, but not defines virtual methods. Classes that implement the specifics of an abstraction can then inherit from that abstract class and implement the required virtual methods.</p><p>The problem here is that multiple inheritance can lead to the <em>diamond problem</em>, where the order in which classes are searched for a method implementation (MRO: method resolution order) can lead to “contradictions”. There are two responses to this:</p><ol><li><p>Define a sane order and reject those orders that can&#39;t be sensibly linearized. The <a href="https://en.wikipedia.org/wiki/C3_linearization">C3 MRO</a> is fairly sensible and works well. It was published 1996.</p></li><li><p>Take the easy route and reject multiple inheritance throughout.</p></li></ol><p>Java took the latter option and chose single behavioral inheritance. However, we still need the ability of an object to support multiple abstractions. Therefore, interfaces have to be used which do not support method definitions, only declarations.</p><p>The result is that the MRO is obvious (just look at each superclass in order), and that our object can have multiple surfaces for any number of abstractions.</p><p>This turns out to be rather unsatisfactory, because quite often a bit of behavior is part of the surface. Consider an <code>Comparable</code> interface:</p><pre class="lang-java prettyprint-override"><code>interface Comparable&lt;T&gt; {
    public int cmp(T that);
    public boolean lt(T that);  // less than
    public boolean le(T that);  // less than or equal
    public boolean eq(T that);  // equal
    public boolean ne(T that);  // not equal
    public boolean ge(T that);  // greater than or equal
    public boolean gt(T that);  // greater than
}
</code></pre><p>This is very user-friendly (a nice API with many convenient methods), but tedious to implement. We would like the interface to only include <code>cmp</code>, and implement the other methods automatically in terms of that one required method. <a href="https://en.wikipedia.org/wiki/Mixin">Mixins</a>, but more importantly Traits [<a href="https://en.wikipedia.org/wiki/Trait_(computer_programming)">1</a>],[ <a href="http://c2.com/cgi/wiki?TraitsPaper">2</a>] solve this problem without falling into the traps of multiple inheritance.</p><p>This is done by defining a trait composition so that the traits don&#39;t actually end up taking part in the MRO – instead the defined methods are composed into the implementing class.</p><p>The <code>Comparable</code> interface could be expressed in Scala as</p><pre class="lang-scala prettyprint-override"><code>trait Comparable[T] {
    def cmp(that: T): Int
    def lt(that: T): Boolean = this.cmp(that) &lt;  0
    def le(that: T): Boolean = this.cmp(that) &lt;= 0
    ...
}
</code></pre><p>When a class then uses that trait, the other methods get added to the class definition:</p><pre class="lang-scala prettyprint-override"><code>// &#34;extends&#34; isn&#39;t different from Java&#39;s &#34;implements&#34; in this case
case class Inty(val x: Int) extends Comparable[Inty] {
    override def cmp(that: Inty) = this.x - that.x
    // lt etc. get added automatically
}
</code></pre><p>So <code>Inty(4) cmp Inty(6)</code> would be <code>-2</code> and <code>Inty(4) lt Inty(6)</code> would be <code>true</code>.</p><p>Many languages have some support for traits, and any language that has a “Metaobject Protocol (MOP)” can have traits added to it. The recent Java 8 update added default methods which are similar to traits (methods in interfaces can have fallback implementations so that it&#39;s optional for implementing classes to implement these methods).</p><p>Unfortunately, traits are a fairly recent invention (2002), and are thus fairly rare in the larger mainstream languages.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-oop-what-are-some-of-the-situations-in-which-class-based-design-is-better-than-interface-based-one/'>Java &#8211; OOP :What are some of the situations in which class based design is better than interface based one</a></li><li class="list-group-item"><a href='../object-oriented-when-to-use-interfaces-unit-testing-ioc/'>Object-oriented &#8211; When to use interfaces (unit testing, IoC?)</a></li><li class="list-group-item"><a href='../object-oriented-understanding-programming-to-an-interface/'>Object-oriented &#8211; Understanding &#8220;programming to an interface&#8221;</a></li><li class="list-group-item"><a href='../object-oriented-dependency-inversion-principle-understanding-how-both-low-level-components-and-high-level-components-depend-on-abstractions/'>Object-oriented &#8211; Dependency Inversion Principle: Understanding how both low level components and high level components depend on abstractions</a></li><li class="list-group-item"><a href='../object-oriented-depend-on-abstractions-not-on-concretions-what-is-the-exact-meaning-of-this-term/'>Object-oriented &#8211; “Depend on abstractions, not on concretions” what is the exact meaning of this term</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>