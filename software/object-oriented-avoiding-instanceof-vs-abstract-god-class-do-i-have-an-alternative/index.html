<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Avoiding instanceof vs abstract God Class. Do I have an alternative &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1069391 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1069391" class="post-1069391 software type-software status-publish hentry category-software tag-design-patterns tag-object-oriented tag-polymorphism"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Avoiding instanceof vs abstract God Class. Do I have an alternative</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">design-patterns</span><span class="mr-2 badge badge-info">object-oriented</span><span class="mr-2 badge badge-warning">polymorphism</span></p><div class="entry-content"><p>I have a large number of classes with an abstract base class (A) that contains behaviour that must be supported by all the sub classes say [B..I].</p><p>In my code, I end up with a collection of objects that is created based on input from an external system. These objects belong to subclasses described above and they go through various operations in my code.</p><p>All of these operations require some core and common behaviour so I use the abstract base class and I can call methods on a collection of objects using only the base type ( A.DoTheThing() ).</p><p>The problem is, only a small subset of these types must support a common set of functionality. If I add the methods to the base class with a default implementation that does nothing or returns null then I&#39;m going towards a God class. Only a few subtypes would override these methods but I can keep using the base type to process the collection. The large group of subclasses would do nothing in response to method calls based on the default empty implementation in the base class. The ones that override the default behaviour would do what they need to do.</p><p>If I don&#39;t want to put behaviour where it mostly does not belong, I&#39;d have to define an interface (X) and implement it for the small subset of subtypes that&#39;ll be included in the collection. However, I now have a collection based on the type A and at some point after using methods from A, I need to perform operations on the subset of objects that implement X. The only option I&#39;m left with is to filter the collection based on instanceof(X) and call relevant methods.</p><p>Which one is the lesser evil and do I have another choice here?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Don&#39;t avoid things just because they are considered evil - understand first <strong>why</strong> they are considered evil, and then decide how to avoid that evilness.</p><p>You are warned about these evil things because they are usually the easy, straightforward way to solve the problem - otherwise people wouldn&#39;t always attempt to do them and the warning would be redundant. The problem is that if you don&#39;t understand why method A is evil, you may end up using method B which is evil for the exact same reason as method A, but because method B is more awkward than A it was not very popular so nobody felt the need to warn you of it.</p><p>I can&#39;t find it, but I remember seeing avoiding singleton by making all the class&#39; fields <code>static</code> so that each new object of that class will use the same state(but there is no single <code>instance</code> so it&#39;s not a singleton!)</p><p>Anyways, this is what you are doing with that master base class. Downcasting is not &#34;evil&#34; in your case, but that master base class suffers from the same problem that downcasting usually suffers from!</p><h2>Why is downcasting considered evil?</h2><p>Consider this:</p><pre><code>public abstract class Base {
    // bla bla bla
}

public class ImplA extends Base {
    // bla bla bla
}

public class ImplB extends Base {
    // bla bla bla
}

// somewhere else

void doit(Base base) {
    if (base instanceof ImplA) {
        ImplA implA = (ImplA)base;
        // ImplA specific code
    } else if (base instanceof ImplB) {
        ImplB implB = (ImplB)base;
        // ImplB specific code
    }
}
</code></pre><p><em>Why is this bad?</em> Because it doesn&#39;t handle <code>ImplC</code>. <em>But there is no <code>ImplC</code>!!!</em></p><p>Well, there is no <code>ImplC</code> <strong>now</strong>, but nothing stops me - or someone else - from writing it next year, making it <code>extend Base</code>. And then they will create an instance of <code>ImplC</code>, and that instance will be passed to <code>doit</code> - which will probably handle it wrong. Because, while we don&#39;t know what <code>ImplC</code> means and how <code>doit</code> should handle it, if <code>doit</code> needs special code for <code>ImplA</code> and special code for <code>ImplB</code>, we should assume it&#39;ll need special code for <code>ImplC</code>. But you may not be able to add that code(because <code>doit</code> may be part of a third party library), or you may simply not <strong>know</strong> you need to, because there is no compilation warning that <code>doit</code> does not have special code to handle <code>ImplC</code>. You&#39;ll realize eventually though, after a few hours/days of debugging trying to figure out why your program doesn&#39;t work...</p><p>This is why downcasting is frowned upon, and it&#39;s recommended to favor polymorphism and method overriding:</p><pre><code>public abstract class Base {
    // bla bla bla
    public abstract void doit();
}

public class ImplA extends Base {
    // bla bla bla
    @Override
    public void doit() {
        // ImplC specific code
    }
}

public class ImplB extends Base {
    // bla bla bla
    @Override
    public void doit() {
        // ImplB specific code
    }
}
</code></pre><p>With this design, <code>ImplC</code> can have it&#39;s own override of <code>doit</code> with it&#39;s own specific code, and if you forget to write it you&#39;ll get a compilation error.</p><h2>The problem with the master base class</h2><p>I argue that your base class suffers from a similar problem - you need to modify the base class to add new functionality. It&#39;s not a worst case here, since you have access to the code and you won&#39;t forget to add the base methods because you need to use them. But still - you are avoiding downcasting by creating a construct that suffers from downcasting&#39;s general problem...</p><h2>Downcasting is OK in this case</h2><p>The problem with <code>doit</code> was that it was meant to deal with any <code>Base</code>, but in practice only handled the known types of <code>Base</code> - <code>ImplA</code> and <code>ImplB</code>.</p><p>Your case is different. You are looping over a collection of <code>A</code>, looking for, let&#39;s say, only instances of <code>B</code>, downcasting them to <code>B</code> and using them as <code>B</code>. This loop is not meant to handle all instances of <code>A</code> - it&#39;s only meant to handle the <code>B</code>s in the collection. <code>C</code>, <code>D</code>, ... <code>I</code> will have their own loops, probably elsewhere, that deal with them. And if you add a new subclass <code>J</code> it&#39;ll also need new loop(s) - but writing these loops is a fundamental part of subclassing <code>A</code>, not some random method somewhere that needs to be amended.</p><h3>What if you need to handle multiple subclasses in the same loop?</h3><p>If you find yourself writing something like this:</p><pre><code>for (A a : theBigCollection) {
    if (a instanceof B) {
        B b = (B)a;
        // B specific code
    } else if (a instanceof G) {
        G g = (G)a;
        // G specific code
    }
    // Other subclasses are not handled here
}
</code></pre><p>You are repeating <code>doit</code>&#39;s problem - if this loop needs to handle both <code>A</code> and <code>G</code>, how do we know it doesn&#39;t need to handle <code>J</code>?</p><p>In this case, you should try to bundle this behavior with a mid subclass or with an interface - let&#39;s call it <code>X</code>:</p><pre><code>public interface X {
    // bla bla bla
}

public class B extends A implements X {
}

public class G extends A implements X {
}

// the loop from before
for (A a : theBigCollection) {
    if (a instanceof X) {
        X x = (X)a;
        // X specific code
    }
}
</code></pre><p>Now if <code>J</code> needs to, it can implement <code>X</code> and get handled in this loop. This is probably what you need, since you mentioned a small set of subclasses implementing the same methods. You can have multiple such interfaces if you need to.</p><h2>Epilogue</h2><p>The problem with downcasting is the possibility of adding new subclasses that will go through the same code paths but won&#39;t have specialized code that handles them. So when considering whether or not you should use downcasting always think what will happen if someone adds a new subclass.</p><p>I believe this is a good place to use the wider interpretation of the <a href="http://wiki.c2.com/?ZeroOneInfinityRule" rel="noreferrer">Zero-One-Infinity Rule</a>. In any code &#34;unit&#34;, you should handle zero, one or infinite(==all possible) subclasses of <code>A</code>:</p><ul><li><em>zero</em>: You don&#39;t use <code>A</code> in that code. Not interesting</li><li><em>one</em>: One subclass, or one interface that you try to cast to. But not &#34;one&#34; as in &#34;I have one apple&#34; - it should be one as in &#34;God is one&#34;. It should be conceptually impossible to add alternative downcasts, no matter what other subclasses will be added there you are still allowed to change the <em>one</em> type to some interface - as long as it remains one.</li><li><em>infinity</em>: You deal with all possible subclasses of <code>A</code> - which means you don&#39;t downcast and use <code>A</code> itself.</li></ul><p>Note that there may be multiple levels - in my last example I was first downcasting to <code>X</code>(<em>one</em>), and then writing code for <code>X</code> which will work on all possible subclasses of <code>X</code>(<em>infinity</em>).</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../object-oriented-changing-behaviour-of-abstract-class-without-modifying-subclasses/'>Object-oriented &#8211; Changing behaviour of abstract class without modifying subclasses</a></li><li class="list-group-item"><a href='../c-help-with-inheritance-hierarchy-design/'>C# &#8211; Help with inheritance hierarchy design</a></li><li class="list-group-item"><a href='../c-empty-virtual-method-on-base-class-vs-abstract-methods/'>C# &#8211; Empty virtual method on base class VS abstract methods</a></li><li class="list-group-item"><a href='../c-why-override-a-static-method-of-an-abstract-base-class/'>C# &#8211; Why override a static method of an abstract base class</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>