<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++ &#8211; Using vectors of shared pointers to objects in the C++ code to prevent object duplication &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1066287 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1066287" class="post-1066287 software type-software status-publish hentry category-software tag-c tag-c11 tag-class tag-class-design tag-smart-pointer"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++ &#8211; Using vectors of shared pointers to objects in the C++ code to prevent object duplication</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">c++11</span><span class="mr-2 badge badge-warning">class</span><span class="mr-2 badge badge-primary">class-design</span><span class="mr-2 badge badge-danger">smart-pointer</span></p><div class="entry-content"><p>In my C++ project, I have three classes, <code>Particle</code>, <code>Contact</code>, and <code>Network</code>. The <code>Network</code> class will have N particles (<code>std::vector&lt;Particle&gt; particles</code>) and Nc contacts (<code>std::vector&lt;Contact&gt; contacts</code>). <code>Particle</code> objects will each have a number of contacts, represented by <code>Contact</code> objects, and contacts are shared by pairs of particles.</p><p>It will be necessary for me to know what contacts a specific particle has, and I have decided to be able to obtain that information through the <code>Network</code> object (e.g., using <code>network.getContacts(Particle particle)</code>).</p><p>My question can be broken into two parts:</p><p><strong>First</strong>, what would be an efficient and community-recommended way to store the contacts for each particle?</p><p>I believe that I can either create a vector of vector of shared pointers to <code>Contact</code> objects, <code>vector&lt;vector&lt;shared_ptr&lt;Contact&gt;&gt;&gt; prtContacts</code> (where I have left off <code>std::</code> for ease of viewing), so that <code>prtContacts[i]</code> will contain a vector of shared pointers to the contacts of the <code>i</code>th particle. It has been suggested that using <code>shared_ptr</code> in this context is useful, as it will ensure that I am not creating duplicate <code>Contact</code> objects for two particles with a shared contact. Is there an alternative method that would make more sense?</p><p><strong>Second</strong>, if I do end up creating <code>prtContacts</code> as defined above, what is the best way to initialize it? My current thinking is to have an initial loop that initializes <code>std::vector&lt;Contact&gt; contacts</code> with the Nc contacts and then have a second loop that initializes <code>prtContacts</code> with shared pointers to the Contacts. Is that reasonable or, again, are there alternative, more efficient, approaches?</p><p>Thank you!</p><hr/><p><strong>Some additional information:</strong></p><p>The number of particles, N, will range from <code>O(10^1)</code> to perhaps <code>O(10^4)</code>. The number of contacts per particle will most likely not exceed 6-7, but will be allowed to vary. Each contact will have a position and contact force (2-component vector) associated with it, and both positions and contact forces will be allowed to vary during the course of simulations (e.g., Monte Carlo simulations).</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>The right solution will depend a lot on your non-functional requirements. How many particles will you typically have? How many contacts does a particle typically have? How much is a network updated, and in what ways? How fast does it need to be?</p><p>I suggest referring to objects by index if you can and then particle contacts can be a list of contact indexes. If a particle typically has a small number of contacts then instead of a <code>vector</code> I suggest using something that is optimized for a small number of elements like <code>boost::container::small_vector</code>, <code>absl::inlined_vector</code>, <code>folly::small_vector</code> or <code>llvm::SmallVector</code>.</p><pre><code>using ParticleContacts = boost::container::small_vector&lt;int, 12&gt;;

class Network {
  std::vector&lt;Particle&gt; particles;
  std::vector&lt;Contact&gt; contacts;
  std::vector&lt;ParticleContacts&gt; particle_contacts;
 public:
  ParticleContacts getParticleContacts(int particle_index) const {
    return particle_contacts.at(particle_index);
  }
  Contact getContact(int contact_index) const {
    return contacts.at(contact_index);
  }
  //...
};
</code></pre><p><a href="https://wandbox.org/permlink/uk88K17aKwtRc6MX" rel="nofollow noreferrer">Live demo</a>.</p><p><strong>Edit:</strong> If you have to be able to delete from the middle of the <code>vector</code> of contacts then using an index will not work. I would seriously consider if you can change your algorithm so that this is not necessary. Not only does it invalidate pointers, iterators and indexes but it also is quite inefficient because all the contacts after the deletion have to be moved. Perhaps, for example, you can just leave orphaned contacts until the end of the simulation with no connection to a particle. Anyway, if you really need to be able to delete from the middle of the list of contacts perhaps a <code>vector</code> is not the best data structure and you should prefer something like a linked list. The advantage of a linked list is you can do quick deletion from the middle and also pointers to contacts in the list are not invalidated by inserts or deletions so your list of particle contacts can be raw pointers. The downside is it is much slower and does not allow random access.</p><pre><code>using ParticleContacts = boost::container::small_vector&lt;Contact*, 12&gt;;

class Network {
  std::vector&lt;Particle&gt; particles;
  std::forward_list&lt;Contact&gt; contacts;
  std::vector&lt;ParticleContacts&gt; particle_contacts;
 public:
  ParticleContacts getParticleContacts(int particle_index) const {
    return particle_contacts.at(particle_index);
  } 
  void addParticle(const Particle&amp; particle) {
    particles.push_back(particle);
    particle_contacts.emplace_back();
  } 
  Contact* addParticleContact(int particle_index_1, int particle_index_2) {
    contacts.emplace_front();
    particle_contacts.at(particle_index_1).push_back(&amp;contacts.front());
    particle_contacts.at(particle_index_2).push_back(&amp;contacts.front());  
    return &amp;contacts.front();
  }
};
</code></pre><p><a href="https://wandbox.org/permlink/NoFUvy5IJSkn9CXu" rel="nofollow noreferrer">Live demo</a>.</p><p>Alternatively, you could use <code>std::vector&lt;std::unique_ptr&lt;Contact&gt;&gt;</code>. Raw pointers to the contact won&#39;t be invalidated by insertions and deletions. It has the advantage of allowing random access but the disadvantage of being slower at insertions and deletions: <a href="https://wandbox.org/permlink/Tr70m8OunNXJXFnV" rel="nofollow noreferrer">Live demo</a></p><p>The right choice will depend on how the data is typically accessed by the simulation.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-efficient-way-to-find-unique-elements-in-a-vector-compared-against-multiple-vectors/'>C++ &#8211; Efficient way to find unique elements in a vector compared against multiple vectors</a></li><li class="list-group-item"><a href='../c-concrete-types-as-described-by-stroustrup-c-programming-language-4th-ed/'>C++ &#8211; Concrete types &#8211; as described by Stroustrup &#8211; C++ Programming Language 4th ed</a></li><li class="list-group-item"><a href='../c-returning-persistent-objects/'>C++ returning persistent objects</a></li><li class="list-group-item"><a href='../c-using-asynchronous-calls-for-heavy-io-operation-how-to-prevent-crushing-the-cpu/'>C++ &#8211; Using asynchronous calls for heavy IO operation: How to prevent crushing the CPU</a></li><li class="list-group-item"><a href='../c-how-to-resolve-class-interdependence-in-the-c-code/'>C++ &#8211; How to resolve class interdependence in the C++ code</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>