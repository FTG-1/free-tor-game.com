<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Java &#8211; How to make a universal construction more efficient &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1083847 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1083847" class="post-1083847 software type-software status-publish hentry category-software tag-concurrency tag-java tag-multithreading"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Java &#8211; How to make a universal construction more efficient</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">concurrency</span><span class="mr-2 badge badge-info">java</span><span class="mr-2 badge badge-warning">multithreading</span></p><div class="entry-content"><p>A &#34;universal construction&#34; is a wrapper class for a sequential object that enables it to be linearized (a strong consistency condition for concurrent objects). For instance, here&#39;s an adapted wait-free construction, in Java, from [1], which presumes the existence of a wait-free queue that satisfies the interface <code>WFQ</code> (which only requires one-time consensus between threads) and assumes a <code>Sequential</code> interface:</p><pre class="lang-java prettyprint-override"><code>public interface WFQ&lt;T&gt; // &#34;FIFO&#34; iteration
{
    int enqueue(T t); // returns the sequence number of t
    Iterable&lt;T&gt; iterateUntil(int max); // iterates until sequence max
}
public interface Sequential
{
    // Apply an invocation (method + arguments)
    // and get a response (return value + state)
    Response apply(Invocation i); 
}
public interface Factory&lt;T&gt; { T generate(); } // generate new default object
public interface Universal extends Sequential {}

public class SlowUniversal implements Universal
{
    Factory&lt;? extends Sequential&gt; generator;
    WFQ&lt;Invocation&gt; wfq = new WFQ&lt;Invocation&gt;();
    Universal(Factory&lt;? extends Sequential&gt; g) { generator = g; } 
    public Response apply(Invocation i)
    {
        int max = wfq.enqueue(i);
        Sequential s = generator.generate();
        for(Invocation invoc : wfq.iterateUntil(max))
            s.apply(invoc);
        return s.apply(i);
    }
}
</code></pre><p>This implementation isn&#39;t very satisfying since it is really slow (you remember every invocation, and have to replay it at every apply &#8211; we have linear runtime in the history size). Is there any way that we could extend the <code>WFQ</code> and <code>Sequential</code> interfaces (in reasonable ways) to enable us to save some steps when applying a new invocation?</p><p>Can we make this more efficient (not linear runtime in history size, preferably memory usage goes down too) without losing the wait-free property?</p><p><strong>Clarification</strong></p><p>A &#34;universal construction&#34; is a term I&#39;m pretty sure was made up by [1] which accepts a thread-unsafe but thread-compatible object, which is generalized by the <code>Sequential</code> interface. Using a wait-free queue, the first construction offers a thread-safe, <em>linearizable</em> version of the object that&#39;s also wait-free (this assumes determinism and halting <code>apply</code> operations).</p><p>This is inefficient, since the method is effectively to have each local thread start from a clean slate and applies <strong>every</strong> operation ever recorded to it. In any case, this works because it achieves synchronization effectively by using the <code>WFQ</code> to determine the order in which all operations should be applied: every thread calling <code>apply</code> will see the same local <code>Sequential</code> object, with the same sequence of <code>Invocation</code>s applied to it.</p><p>My question is whether we can (e.g.) introduce a background cleanup process which updates the &#34;starting state&#34; so that we don&#39;t have to restart from scratch. This isn&#39;t as simple as having an atomic pointer with a starting pointer &#8211; these kinds of approaches easily lose the wait-free guarantee. My suspicion is that some other queue-based approach might work here.</p><p>Jargon:</p><ol><li>wait-free &#8211; regardless of the number of threads or the scheduler&#39;s decision making, <code>apply</code> will terminate in a provably bounded number of instructions executed for that thread.</li><li>lock-free &#8211; same as above, but admits the possibility of an unbounded execution time, only in the case that an unbounded number of <code>apply</code> operations are getting done in other threads. Typically, optimistic synchronization schemes fall into this category.</li><li>blocking &#8211; efficiency at the mercy of the scheduler.</li></ol><p><a href="https://gist.github.com/vlad17/bdeddc9b240e7975040f34f6dea23533" rel="nofollow noreferrer">A working example, as requested (now on a page that won&#39;t expire)</a></p><p>[1] Herlihy and Shavit, <em>The Art of Multiprocessor Programming</em>.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Here&#39;s an explanation and example of how this is accomplished.  Let me know if there are parts that aren&#39;t clear.</p><p><a href="https://gist.github.com/James-Matthew-Watson/b724f3b61f5759071b104563d0d8a0e6" rel="nofollow noreferrer">Gist with source</a></p><h1>Universal</h1><h2>Initialization:</h2><p>Thread indexes are applied in a atomically incremented fashion.  This is managed using an <code>AtomicInteger</code> named <code>nextIndex</code>.  These indexes are assigned to threads through a <code>ThreadLocal</code> instance which initializes itself by getting the next index from <code>nextIndex</code> and incrementing it.  This happens the first time each thread&#39;s index is retrieved the first time.
A <code>ThreadLocal</code> is created to track the last sequence this thread created.  It&#39;s initialized 0.
The sequential factory object reference is passed in and stored.
Two <code>AtomicReferenceArray</code> instances are created of size <code>n</code>.  The tail object is assigned to each reference, having been initialized with the initial state provided by the <code>Sequential</code> factory. <code>n</code> is the maximum number of threads allowed.  Each element in these arrays &#39;belongs&#39; to corresponding thread index.</p><h2>Apply method:</h2><p>This is the method that does the interesting work.  It does the following:</p><ul><li>Create a new node for this invocation: mine</li><li>Set this new node in the announce array at the current thread&#39;s index</li></ul><p>Then the sequencing loop begins.  It will continue until the current invocation has been sequenced:</p><ol><li>find a node in the announce array using the sequence of the last node created by this thread.  More on this later.</li><li>if a node is found in step 2 it is not yet sequenced, continue with it, otherwise, just focus on the current invocation.  This will only try to help one other node per invocation.</li><li>Whatever node was selected in step 3, keep trying to sequence it after the last sequenced node (other threads may interfere.)  Regardless of success, set the current threads head reference to the sequence returned by <code>decideNext()</code></li></ol><p>The key to the nested loop described above is the <code>decideNext()</code> method.  To understand that, we need to look at the Node class.</p><h1>Node class</h1><p>This class specifies nodes in a doubly-linked list.  There&#39;s not a lot of action in this class.  Most of the methods are simple retrieval methods that should be fairly self-explanatory.</p><h2>tail method</h2><p>this returns a special node instance with a sequence of 0.  It simply acts as a place-holder until an invocation replaces it.</p><h2>Properties and initialization</h2><ul><li><code>seq</code>: the sequence number, initialized to -1 (meaning unsequenced)</li><li><code>invocation</code>: the value of the invocation of <code>apply()</code>.  Set upon construction.</li><li><code>next</code>: <code>AtomicReference</code> for the forward link.  once assigned, this will never be changed</li><li><code>previous</code>: <code>AtomicReference</code> for the backward link assigned upon sequencing and cleared by <code>truncate()</code></li></ul><h2>Decide Next</h2><p>This method is only one in Node with non-trivial logic.  In a nutshell, a node is offered as a candidate to be the next node in the linked list.  The <code>compareAndSet()</code> method will check if it&#39;s reference is null and if so, set the reference to the candidate.  If the reference is already set, it does nothing.  This operation is atomic so if two candidates are offered at the same moment, only one will be selected.  This guarantees only one node will ever be selected as the next one.  If the candidate node is selected, it&#39;s sequence is set to the next value, and it&#39;s previous link is set to this node.</p><h1>Jumping Back to the Universal class apply method ...</h1><p>Having called <code>decideNext()</code> on the last sequenced node (when checked) with either our node or a node from the <code>announce</code> array, there are two possible occurrences:
 1. The node was successfully sequenced
 2. Some other thread pre-empted this thread.</p><p>The next step is to check whether the node created for this invocation.  This could happen because this thread successfully sequenced it or some other thread picked it up from the <code>announce</code> array and sequenced it for us.  If it has not been sequenced, the process is repeated. Otherwise the call finishes up by clearing the announce array for at this thread&#39;s index and returning the result value of the invocation.  The announce array is cleared to guarantee there are no references to the node left around that would prevent the node from being garbage collected and therefore keep all nodes in the linked list from that point on alive on the heap.</p><h2>Evaluate method</h2><p>Now that the invocation&#39;s node has been successfully sequenced, the invocation needs to be evaluated.  To do that, the first step is to ensure that the invocations preceding this one have been evaluated.  If they haven&#39;t this thread will not wait but will do that work immediately.</p><h3>EnsurePrior method</h3><p>The <code>ensurePrior()</code> method does this work by checking the previous node in the linked list.  If it&#39;s state is not set, the previous node will be evaluated.  Node that this is recursive.  If the node prior to prior node has not been evaluated, it will call evaluate for that node and so on an so forth.</p><p>Now that the previous node is known to have a state, we can evaluate this node.  The last node is retrieved and assigned to a local variable.  If this reference is null, it means that some other thread has pre-empted this one and already evaluated this node; setting it&#39;s state.  Otherwise, the prior node&#39;s state is passed to the <code>Sequential</code> object&#39;s apply method along with this node&#39;s invocation.  The state returned is set on the node and the <code>truncate()</code> method is called, clearing the backward link from the node as it is no longer needed.</p><h3>MoveForward method</h3><p>The move forward method will attempt to move all head references to this node if they are not already pointing to something further along.  This is to ensure that if a thread stops calling, it&#39;s head will not retain a reference to an node that is no longer needed.  The <code>compareAndSet()</code> method will make sure we only update the node if some other thread hasn&#39;t changed it since it was retrieved.</p><h1>Announce array and helping</h1><p>The key to making this approach wait-free as opposed to simply lock-free is that we can&#39;t assume that the thread scheduler will give each thread priority when it needs it.  If each thread simply attempted to sequence it&#39;s own nodes, it&#39;s possible that a thread could be continually pre-empted under load.  To account for this possibility each thread will first try to &#39;help&#39; other threads that may be unable to get sequenced.</p><p>The basic idea is that as each thread successfully creates nodes, the sequences assigned are monotonically increasing.  If a thread or threads are continually pre-empting another thread, the index the use to find unsequenced nodes in the <code>announce</code> array will move forward.  Even if every thread that is currently trying to sequence a given node is continually pre-empted by another thread, eventually all threads will be trying to sequence that node.  To illustrate, we&#39;ll construct an example with three threads.</p><p>At the starting point, all three threads&#39; head and announce elements are pointed at the <code>tail</code> node.  The <code>lastSequence</code> for each thread is 0.</p><p>At this point, <em>Thread 1</em> is executed with an invocation.  It checks the announce array for it&#39;s last sequence (zero) which is the node it is currently scheduled to index.  It sequences the node and it&#39;s <code>lastSequence</code> is set to 1.</p><p><em>Thread 2</em> is now executed with an invocation, it checks the announce array at it&#39;s last sequence (zero) and sees that it doesn&#39;t need help and so attempts to sequence it&#39;s invocation.  It succeeds and now it&#39;s <code>lastSequence</code> is set to 2.</p><p><em>Thread 3</em> is now executed and it also sees that the node at <code>announce[0]</code> is already sequenced and sequences it&#39;s own invocation.  It&#39;s <code>lastSequence</code> is now set to 3.</p><p>Now <em>Thread 1</em> is invoked again.  It checks the announce array at index 1 and finds that it&#39;s already sequenced.  Concurrently, <em>Thread 2</em> is invoked.  It checks the announce array at index 2 and finds that it is already sequenced.  Both <em>Thread 1</em> and <em>Thread 2</em> now attempt to sequence their own nodes. <em>Thread 2</em> wins and it sequences it&#39;s invocation.  It&#39;s <code>lastSequence</code> is set to 4.  Meanwhile, thread three has been invoked.  It checks the index it <code>lastSequence</code> (mod 3) and finds that the node at <code>announce[0]</code> has not been sequenced. <em>Thread 2</em> is again invoked at the same time that <em>Thread 1</em> is on it&#39;s second attempt. <em>Thread 1</em> finds an unsequenced invocation at <code>announce[1]</code> which is the node just created by <em>Thread 2</em>.  It attempts to sequence <em>Thread 2&#39;s</em> invocation and succeeds. <em>Thread 2</em> finds it&#39;s own node at <code>announce[1]</code> and it has been sequenced.  It set&#39;s it&#39;s <code>lastSequence</code> to 5. <em>Thread 3</em> is then invoked and finds that node that thread 1 placed at <code>announce[0]</code> is still not sequenced and attempts to do so.  Meanwhile <em>Thread 2</em> has also been invoked and pre-empts Thread 3.  It sequences it&#39;s node and sets it&#39;s <code>lastSequence</code> to 6.</p><p>Poor <em>Thread 1</em>.  Even though <em>Thread 3</em> is trying to sequence it, both threads have been continually thwarted by the scheduler.  But at this point. <em>Thread 2</em> is also now pointing to <code>announce[0]</code> (6 mod 3).  All three threads are set to attempt to sequence the same invocation.  No matter which thread succeeds, the next node to be sequenced will be the waiting invocation of <em>Thread 1</em> i.e. the node referenced by <code>announce[0]</code>.</p><p>This is inevitable.  In order for threads to be pre-empted, other threads must be sequencing nodes and as they do so, they will continually move their <code>lastSequence</code> ahead.  If a given thread&#39;s node is continually not sequenced, eventually all the threads will be pointing to it&#39;s index in the announce array.  No thread will do anything else until the node it is trying to help has been sequenced, the worst case scenario is that all threads are pointing to the same unsequenced node.  Therefore, the time required to sequence any invocation is a function of the number of threads and not the size of the input.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-plagued-by-multithreaded-bugs/'>C++ &#8211; Plagued by multithreaded bugs</a></li><li class="list-group-item"><a href='../cache-concurrency-ensuring-latest-version-in-cache/'>Cache concurrency: ensuring latest version in cache</a></li><li class="list-group-item"><a href='../java-difference-between-consumer-producer-and-observer-observable/'>Java &#8211; Difference between Consumer/Producer and Observer/Observable</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>