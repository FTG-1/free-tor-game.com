<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Mvc &#8211; Is it reasonable to build applications (not games) using a component-entity-system architecture &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1069484 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1069484" class="post-1069484 software type-software status-publish hentry category-software tag-applications tag-architecture tag-design-patterns tag-game-development tag-mvc"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Mvc &#8211; Is it reasonable to build applications (not games) using a component-entity-system architecture</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">applications</span><span class="mr-2 badge badge-info">Architecture</span><span class="mr-2 badge badge-warning">design-patterns</span><span class="mr-2 badge badge-primary">game development</span><span class="mr-2 badge badge-danger">mvc</span></p><div class="entry-content"><p>I know that when building applications (native or web) such as those in the Apple AppStore or Google Play app store that it&#39;s very common to use a Model-View-Controller architecture.</p><p>However, is it reasonable to also create applications using the Component-Entity-System architecture common in game engines?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>However, is it reasonable to also create applications using the
 Component-Entity-System architecture common in game engines?</p></blockquote><p>To me, absolutely. I work in visual FX and studied a wide variety of systems in this field, their architectures (including CAD/CAM), hungry for SDKs and any papers that would give me a sense of the pros and cons of the seemingly-infinite architectural decisions that could be made, with even the most subtle ones not always making a subtle impact.</p><p>VFX is rather similar to games in that there is one central concept of a &#34;scene&#34;, with viewports that display the rendered results. There also tends to be a lot of central loopy processing going on revolving around this scene constantly in animation contexts, where there might be physics happening, particle emitters spawning particles, meshes being animated and rendered, motion animations, etc, and ultimately to render them all to the user at the end.</p><p>Another similar concept to at least very complex game engines was the need for a &#34;designer&#34; aspect where designers could flexibly design scenes, including the ability do some lightweight programming of their own (scripts and nodes).</p><p>I found, over the years, that ECS made the best fit. Of course that&#39;s never completely divorced from subjectivity, but I would say it strongly appeared to give the fewest problems. It solved a lot more major problems we were always struggling with, while only giving us some few new minor ones in return.</p><h2>Traditional OOP</h2><p>More traditional OOP approaches can be really strong when you have a firm grasp of the design requirements upfront but not the implementation requirements. Whether through a flatter multiple interface approach or a more nested hierarchical ABC approach, it tends to cement the design and make it more difficult to change while making the implementation easier and safer to change. There&#39;s always a need for instability in any product that goes past a single version, so OOP approaches tend to skew stability (difficulty of change and lack of reasons for change) towards the design level, and instability (ease of change and reasons for change) to the implementation level.</p><p>However, against evolving user-end requirements, both design and implementation may need to frequently change. You might find something weird like a strong user-end need for the analogical creature that needs to be both plant and animal at the same time, completely invalidating the entire conceptual model you built. Normal object-oriented approaches don&#39;t protect you here, and can sometimes make such unanticipated, concept-breaking changes even harder. When very performance-critical areas are involved, the reasons for design changes further multiply.</p><p>Combining multiple, granular interfaces to form the conforming interface of an object can help a lot in stabilizing client code, but it doesn&#39;t help in stabilizing the subtypes which could sometimes dwarf the number of client dependencies. You can have one interface being used by only part of your system, for example, but with a thousand different subtypes implementing that interface. In that case, maintaining the complex subtypes (complex because they have so many disparate interface responsibilities to fulfill) can become the nightmare rather than the code using them through an interface. OOP tends to transfer complexity to the object level, while ECS transfers it to the client (&#34;systems&#34;) level, and that can be ideal when there are very few systems but a whole bunch of conforming &#34;objects&#34; (&#34;entities&#34;).</p><p><a href="../../../i.stack.imgur.com/hMiqr.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/hMiqr.png" alt="enter image description here"/></a></p><p>A class also owns its data privately, and thus can maintain invariants all on its own. Nevertheless, there are &#34;coarse&#34; invariants that can actually still be hard to maintain when objects interact with each other. For a complex system as a whole to be in a valid state often needs to consider a complex graph of objects, even if their individual invariants are properly maintained. Traditional OOP-style approaches can help with maintaining granular invariants, but can actually make it difficult to maintain broad, coarse invariants if the objects focus on teeny facets of the system.</p><p>That&#39;s where these kinds of lego-block-building ECS approaches or variants can be so helpful. Also with systems being coarser in design than the usual object, it becomes easier to maintain those kinds of coarse invariants at the bird&#39;s-eye view of the system. A lot of teeny object interactions turn into one big system focusing on one broad task instead of teeny little objects focusing on teeny little tasks with a dependency graph that would cover a kilometer of paper.</p><p>Yet I had to look outside of my field, at the gaming industry, to learn about ECS, though I was always one of a data-oriented mindset. Also, funnily enough, I almost made my way towards ECS on my own just iterating through and trying to come up with better designs. I didn&#39;t make it all the way though and missed a very crucial detail, which is the formalization of the &#34;systems&#34; part, and squashing components all the way down to raw data.</p><p>I&#39;ll try to go through how I ended up settling on ECS, and how it ended up solving all the problems with previous design iterations. I think that&#39;ll help to highlight exactly why the answer here could be a very strong &#34;yes&#34;, that ECS is potentially applicable far beyond the gaming industry.</p><h2>1980s Brute Force Architecture</h2><p>The first architecture I worked on in the VFX industry had a long legacy that was already going past a decade since I joined the company. It was brute force crude C coding all the way (not a slant on C, as I love C, but the way it was being used here was really crude). A miniature and oversimplistic slice resembled dependencies like this:</p><p><a href="../../../i.stack.imgur.com/xwbee.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/xwbee.png" alt="enter image description here"/></a></p><p>And this is an enormously simplified diagram of one tiny piece of the system. Each of these clients in the diagram (&#34;Rendering&#34;, &#34;Physics&#34;, &#34;Motion&#34;) would get some &#34;generic&#34; object through which they would check a type field, like so:</p><pre><code>void transform(struct Object* obj, const float mat[16])
{
    switch (obj-&gt;type)
    {
        case camera:
            // cast to camera and do something with camera fields
            break;
        case light:
            // cast to light and do something with light fields
            break;
        ...
    }
}
</code></pre><p>Of course with significantly uglier and more complex code than this. Often additional functions would be called from these switch cases which would recursively do the switch again and again and again. This diagram and code might almost look like ECS-lite, but there was no strong entity-component distinction (&#34;<em>is</em> this object a camera?&#34;, not &#34;does this object <em>provide</em> motion?&#34;), and no formalization of &#34;system&#34; (just a bunch of nested functions going all over the place and mixing up responsibilities). In that case, just about everything was complicated, any function was a potential for a disaster waiting to happen.</p><p>Our testing procedure here often had to check things like meshes separate from other types of items, even if the identical thing was happening to both, since the brute force nature of the coding here (often accompanied by a lot of copy and paste) often made it very probable that what is otherwise the exact same logic could fail from one item type to the next. Trying to extend the system to handle new types of items was pretty hopeless, even though there was a strongly-expressed user-end need, as it was too difficult when we were struggling so much just to handle the existing types of items.</p><p>Some pros:</p><ul><li>Uhh... doesn&#39;t take any engineering experience, I guess? This system does not require any knowledge of even basic concepts like polymorphism, it&#39;s totally brute force, so I guess even a beginner might be able to understand some of the code even if a pro at debugging can barely maintain it.</li></ul><p>Some cons:</p><ul><li>Maintenance nightmare. Our marketing team actually felt the need to boast the we fixed over 2000 unique bugs in one 3-year cycle. To me that&#39;s something to be embarrassed about that we had so many bugs in the first place, and that process probably still only fixed around 10% of the bugs total which were growing in number all the time.</li><li>About the most inflexible solution possible.</li></ul><h2>1990s COM Architecture</h2><p>Most of the VFX industry uses this style of architecture from what I&#39;ve gathered, reading documents about their design decisions and glancing at their software development kits.</p><p>It may not exactly be COM at the ABI level (some of these architectures could only have plugins written using the same compiler), but shares a lot of similar characteristics with interface queries made on objects to see what interfaces their components support.</p><p><a href="../../../i.stack.imgur.com/OWo4S.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/OWo4S.png" alt="enter image description here"/></a></p><p>With this kind of approach, the analogical <code>transform</code> function above came to resemble this form:</p><pre><code>void transform(Object obj, const Matrix&amp; mat)
{
    // Wrapper that performs an interface query to see if the 
    // object implements the IMotion interface.
    MotionRef motion(obj);

    // If the object supported the IMotion interface:
    if (motion.valid())
    {
        // Transform the item through the IMotion interface.
        motion-&gt;transform(mat);
        ...
    }
}
</code></pre><p>This is the approach the new team of that old codebase settled on, to eventually refactor towards. And it was a dramatic improvement over the original in terms of flexibility and maintainability, but there were still some issues I&#39;ll cover in the next section.</p><p>Some pros:</p><ul><li>Dramatically more flexible/extensible/maintainable than the previous brute force solution.</li><li>Promotes a strong conformance to many principles of SOLID by making every interface completely abstract (stateless, no implementation, only pure interfaces).</li></ul><p>Some cons:</p><ul><li>Lots of boilerplate. Our components had to be published through a  registry in order to instantiate objects, the interfaces they supported required both inheriting (&#34;implementing&#34; in Java) the interface and providing some code to indicate which interfaces were available in a query.</li><li>Promoted duplicated logic all over the place as a result of the pure interfaces. For example, all components that implemented <code>IMotion</code> would always have the exact same state and exact same implementation for all of the functions. To mitigate this, we&#39;d start centralizing base classes and helper functionality throughout the system for the things that would tend to be redundantly implemented the same way for the same interface, and possibly with multiple inheritance going on behind the hood, but it was pretty messy under the hood even though the client code had it easy.</li><li>Inefficiency: vtune sessions often showed the basic <code>QueryInterface</code> function almost always showing up as a middle to upper hotspot, and occasionally even the #1 hotspot. To mitigate that, we&#39;d do things like have rendering parts of the codebase cache a list of objects already known to support <code>IRenderable</code>, but that significantly escalated the complexity and maintenance costs. Likewise, this was more difficult to measure but we noticed some definite slowdowns compared to the C-style coding we were doing before when every single interface required a dynamic dispatch. Things like branch mispredictions and optimization barriers are difficult to measure outside a little facet of code, but the users were just generally noticing the responsiveness of the user interface and things like that getting worse by comparing previous and newer versions of the software side-by-side for areas where the algorithmic complexity didn&#39;t change, only the constants.</li><li>Was still difficult to reason about correctness at a broader system level. Even though it was significantly easier than the previous approach, it was still hard to grasp the complex interactions between objects throughout this system, especially with some of the optimizations that started to become necessary against it.</li><li>We had trouble getting our interfaces correct. Even though there might only be one broad place in the system that uses an interface, user-end requirements would change over versions, and we would end up having to do cascading changes to all classes that implement the interface to accommodate a new function added to the interface, e.g., unless there was some abstract base class that was already centralizing the logic under the hood (some of these would manifest in the middle of these cascading changes in hopes of not repeatedly doing this again and again).</li></ul><p><a href="../../../i.stack.imgur.com/fAPY3.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/fAPY3.png" alt="enter image description here"/></a></p><h2>Pragmatic Response: Composition</h2><p>One of the the things we were noticing before (or at least I was) that was causing issues was that <code>IMotion</code> might be implemented by 100 different classes but with the exact same implementation and state associated. Furthermore, it would only be used by a handful of systems like rendering, keyframed motion, and physics.</p><p>So in such a case, we might have like a 3-to-1 relationship between the systems using the interface to the interface, and a 100-to-1 relationship between the subtypes implementing the interface to the interface.</p><p>The complexity and maintenance then would be drastically skewed to the implementation and maintenance of 100 subtypes, instead of 3 client systems who depend on <code>IMotion</code>. This shifted all of our maintenance difficulties to the maintenance of these 100 subtypes, not the 3 places using the interface. Updating 3 places in the code with few or no &#34;indirect efferent couplings&#34; (as in dependencies to it but indirectly through an interface, not a direct dependency), no big deal: updating 100 subtype places with a boatload of &#34;indirect efferent couplings&#34;, pretty big deal *.</p><blockquote><p><sub>* <strong><em>I realize it&#39;s odd and wrong to screw with the definition of
 &#34;efferent couplings&#34; in this sense from an implementation perspective, I
 just haven&#39;t found a better way to describe the maintenance complexity associated when both interface and corresponding implementations of a hundred subtypes must change.</em></strong></sub></p></blockquote><p>So I had to push hard but I proposed that we try to become a little more pragmatic and relax the whole &#34;pure interface&#34; idea. It made no sense to me to make something like <code>IMotion</code> completely abstract and stateless unless we saw a benefit to it having a rich variety of implementations. In our case, for <code>IMotion</code> to have a rich variety of implementations would actually turn into quite a maintenance nightmare, as we didn&#39;t <em>want</em> variety. Instead we were iterating towards trying to make a single motion implementation that&#39;s really good against changing client requirements, and often were working around the pure interface idea a lot trying to force every implementor of <code>IMotion</code> to use the same implementation and state associated so that we don&#39;t duplicate goals.</p><p>Interfaces thus became more like broad <code>Behaviors</code> associated with an entity. <code>IMotion</code> would simply become a <code>Motion</code> &#34;component&#34; (I changed the way we defined &#34;component&#34; away from COM to one where is closer to the usual definition, of a piece making up a &#34;complete&#34; entity).</p><p>Instead of this:</p><pre><code>class IMotion
{
public:
    virtual ~IMotion() {}
    virtual void transform(const Matrix&amp; mat) = 0;
    ...
};
</code></pre><p>We evolved it to something more like this:</p><pre><code>class Motion
{
public:
    void transform(const Matrix&amp; mat)
    {
        ...
    }
    ...

private:
    Matrix transformation;
    ...
};
</code></pre><p>This is a blatant violation of the dependency inversion principle to start shifting away from the abstract back to the concrete, but to me such a level of abstraction is only useful if we can foresee a genuine need in some future, beyond a reasonable doubt and not exercising ridiculous &#34;what if&#34; scenarios completely detached from user experience (which would probably require a design change anyway), for such flexibility.</p><p>So we started evolving to this design. <code>QueryInterface</code> became more like <code>QueryBehavior</code>. Furthermore, it started to seem pointless to use inheritance here. We used composition instead. Objects turned into a collection of components whose availability could be queried and injected at runtime.</p><p><a href="../../../i.stack.imgur.com/2y2GL.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/2y2GL.png" alt="enter image description here"/></a></p><p>Some pros:</p><ul><li>Was a lot easier to maintain still in our case than the previous, pure-interface COM-style system. Unforeseen surprises like a change in requirements or workflow complaints could be accommodated more easily with one very central and obvious <code>Motion</code> implementation, e.g., and not dispersed across a hundred subtypes.</li><li>Gave a whole new level of flexibility of the kind we actually needed. In our previous system, since inheritance models a static relationship, we could only effectively define new entities at compile-time in C++. We couldn&#39;t do it from the scripting language, e.g. With the composition approach, we could string together new entities on the fly at runtime by merely attaching components to them and adding them to a list. An &#34;entity&#34; turned into a blank canvas upon which we could just throw together a collage of whatever we needed on the fly, with relevant systems automatically recognizing and processing these entities as a result.</li></ul><p>Some cons:</p><ul><li>We were still having a hard time in the efficiency department, and maintainability in the performance-critical areas. Each system would still end up wanting to cache components of entities that provided these behaviors to avoid looping through them all repeatedly and checking what was available. Each system demanding performance would do this ever so slightly-differently, and was prone to a different set of bugs in failing to update this cached list and possibly a data structure (if some form of search was involved like frustum culling or raytracing) on some obscure scene change event, e.g.</li><li>There was still something awkward and complex that I couldn&#39;t put my finger on related to all these granular little behavioral, simple objects. We still spawned a lot of events to deal with interactions between these &#34;behavior&#34; objects that were sometimes necessary, and the result was very decentralized code. Each little object was easy to test for correctness and, taken individually, often were perfectly correct. Yet it still felt like we were trying to maintain a massive ecosystem composed of little villages and trying to reason about what they all individually do and add up to make as a whole. The C-style 80s codebase felt like one epic, overpopulated megalopolis which was definitely a maintenance nightmare, but dispersing that complexity across into too many teeny villages was also making it hard to think about the system at a bird&#39;s-eye view without getting overwhelmed by the complexity of the interactions between everything.</li><li>Loss of flexibility with the lack of abstraction but in an area where we never actually encountered a genuine need for it, so hardly a practical con (though definitely at least a theoretical one).</li><li>Preserving ABI compatibility was always hard, and this made it harder by requiring stable data and not just stable interface associated with a &#34;behavior&#34;. However, we could easily add new behaviors and simply deprecate existing ones if a state change was needed, and that was arguably easier than doing backflips underneath the interfaces at the subtype-level to handle versioning concerns.</li></ul><p>One phenomena that occurred was that, since we lost the abstraction on these behavioral components, we had more of them. For example, instead of an abstract <code>IRenderable</code> component, we&#39;d attach an object with a concrete <code>Mesh</code> or <code>PointSprites</code> component. The rendering system would know how to render <code>Mesh</code> and <code>PointSprites</code> components and would find entities that provide such components and draw those. At other times, we had miscellaneous renderables like <code>SceneLabel</code> that we discovered we needed in hindsight, and so we&#39;d attach a <code>SceneLabel</code> in those cases to relevant entities (possibly in addition to a <code>Mesh</code>). The rendering system implement would then be updated to know how to render entities that provided those, and that was a pretty easy change to make.</p><p>In this case, an entity composed of components could also then be used as a component to another entity. We&#39;d build things up that way by hooking up lego blocks.</p><h2>ECS: Systems and Raw Data Components</h2><p>That last system was as far as I made it on my own, and we were still bastardizing it with COM. It felt like it was wanting to become an entity-component system but I was not familiar with it at the time. I was looking around at COM-style examples which saturated my field, when I should have been looking at AAA game engines for architectural inspiration. I finally started doing that.</p><p>What I was missing were several key ideas:</p><ol><li>The formalization of &#34;systems&#34; to process &#34;components&#34;.</li><li>&#34;Components&#34; being raw data rather than behavioral objects composed together into a bigger object.</li><li>Entities as nothing more than a strict ID associated to a collection of components.</li></ol><p>I finally left that company and started working on an ECS as an indy (still working on it while draining my savings), and it has been the easiest system to manage by far.</p><p>What I noticed with the ECS approach was that it solved the problems I was still struggling with above. Most importantly to me, it felt like we were managing healthy-sized &#34;cities&#34; instead of teeny little villages with complex interactions. It wasn&#39;t as hard to maintain as a monolithic &#34;megalopolis&#34;, too big in its population to effectively manage, but wasn&#39;t as chaotic as a world filled with tiny little villages interacting with each other where just thinking about the trade routes in between them formed a nightmarish graph. ECS distilled all the complexity towards bulky &#34;systems&#34;, like a rendering system, a healthy-sized &#34;city&#34; but not an &#34;overpopulated megalopolis&#34;.</p><p>Components becoming raw data felt <em>really weird</em> to me at first, as it breaks even the basic information hiding principle of OOP. It was kind of challenging one of the biggest values I held dear about OOP, which was its ability to maintain invariants which required encapsulation and information hiding. But it started to become a non-concern as it quickly became obvious what was happening with just a dozen or so broad systems transforming that data instead of such logic being dispersed across hundreds to thousands of subtypes implementing a combo of interfaces. I tend to think of it like still in an OOP-style fashion except spread out where the systems are providing the functionality and implementation that access the data, the components are providing the data, and the entities are providing components.</p><p>It became even <em>easier</em>, counter-intuitively, to reason about the side effects caused by the system when there were just a handful of bulky systems transforming the data in broad passes. The system became a lot &#34;flatter&#34;, my call stacks became shallower than ever before for each thread. I could think about the system at that overseer level and not run into weird surprises.</p><p>Likewise, it made even the performance-critical areas simple with respect to eliminating those queries. Since the idea of &#34;System&#34; became very formalized, a system could subscribe to the components it was interested in, and just be handed a cached list of entities which satisfy that criteria. Each individual one didn&#39;t have to manage that caching optimization, it became centralized to a single place.</p><p>Some pros:</p><ul><li>Seems to just solve almost every major architectural problem I was encountering in my career without ever feeling trapped in a design corner when encountering unanticipated needs.</li></ul><p>Some cons:</p><ul><li>I still have a hard time wrapping my head around it sometimes, and it&#39;s not the most mature or well-established paradigm even within the game industry, where people argue about exactly what it means and how to do things. It&#39;s definitely not something I could have done with the former team I worked with, which consisted of members deeply hooked to the COM-style mindset or the 1980s C-style mindset of the original codebase. Where I get confused sometimes is like how to model graph-style relationships between components, but I&#39;ve always found a solution which didn&#39;t turn out to be horrible later where I can just make a component dependent upon another one (&#34;this motion component depends on this other one as a parent, and the system will use memoization to avoid repeatedly doing the same recursive motion calculations&#34;, e.g.)</li><li>ABI is still difficult, but so far I&#39;d even venture to say that it&#39;s easier than pure interface approach. It&#39;s a shift in mindset: data stability becomes the sole focus for ABI, rather than interface stability, and in some ways it&#39;s easier to achieve data stability than interface stability (ex: no temptations to change a function just because it needs a new parameter. That kind of stuff happens inside coarse system implementations which don&#39;t break ABI).</li></ul><p><a href="../../../i.stack.imgur.com/cYpoC.png" rel="noreferrer"><img src="../../../i.stack.imgur.com/cYpoC.png" alt="enter image description here"/></a></p><blockquote><p>However, is it reasonable to also create applications using the
 Component-Entity-System architecture common in game engines?</p></blockquote><p>So anyway, I&#39;d say absolutely &#34;yes&#34;, with my personal VFX example being a strong candidate. But that&#39;s still fairly similar to the needs of gaming.</p><p>I haven&#39;t put it to practice in more remote areas completely detached from the concerns of game engines (VFX is quite similar), but it seems to me like far more areas are good candidates for an ECS approach. Maybe even a GUI system would be suitable for one, but I still use a more OOP approach there (but without deep inheritance unlike Qt, e.g.).</p><p>It&#39;s widely-unexplored territory, but it seems suitable to me whenever your entities can be composed of a rich combination of &#34;traits&#34; (and exactly what combo of traits they provide being ever subject to change), and where you have a handful of generalized systems that process entities that have the necessary traits.</p><p>It becomes a very practical alternative in those cases to any scenario where you might be tempted to use something like multiple inheritance or an emulation of the concept (mixins, e.g.) only to produce hundreds or more combos in a deep inheritance hierarchy or hundreds of combos of classes in a flat hierarchy implementing a specific combo of interfaces, but where your systems are few in number (dozens, e.g.).</p><p>In those cases, the complexity of the codebase starts to feels more proportional to the number of systems instead of the number of type combinations, since each type is now just an entity composing components which are nothing more than raw data. GUI systems naturally fit these kinds of specs where they might have hundreds of possible widget types combined from other base types or interfaces, but only a handful of systems to process them (layout system, rendering system, etc). If a GUI system used ECS, it would probably be so much easier to reason about the correctness of the system when all the functionality is provided by a handful of these systems instead of hundreds of different object types with inherited interfaces or base classes. If a GUI system used ECS, widgets would have no functionality, only data. Only the handful of systems that process widget entities would have functionality. How overridable events for a widget would be handled is beyond me, but just based on my limited experience so far, I haven&#39;t found a case where that type of logic could not be transferred centrally to a given system in a way that, in hindsight, yielded a much more elegant solution that I&#39;d ever expect.</p><p>I would love to see it employed in more fields, as it was a lifesaver in mine. Of course it&#39;s ill-suited if your design doesn&#39;t break down this way, from entities aggregating components to coarse systems that process those components, but if they naturally fit this kind of model, it is the most wonderful thing I&#39;ve encountered yet.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../mvc-sharing-code-logic-between-controllers-through-the-model-layer/'>Mvc &#8211; Sharing code logic between controllers, through the Model layer</a></li><li class="list-group-item"><a href='../design-how-to-allow-for-custom-rules-in-a-entity-component-system-designed-game-engine/'>Design &#8211; How to allow for custom Rules in a Entity Component System designed game engine</a></li><li class="list-group-item"><a href='../mvc-application-service-layer-calling-database-functions-bad-architecture/'>Mvc &#8211; Application service layer calling database functions. Bad architecture</a></li><li class="list-group-item"><a href='../mvc-how-should-the-model-notify-changes-to-the-controller-in-the-mvc-paradigm/'>Mvc &#8211; How should the model notify changes to the controller in the MVC paradigm</a></li><li class="list-group-item"><a href='../isnt-an-entity-component-system-terrible-for-decoupling-information-hiding/'>Isn&#8217;t an Entity-Component System terrible for decoupling/information hiding</a></li><li class="list-group-item"><a href='../mvc-in-mvc-soa-architecture-what-is-the-rationale-for-placing-business-logic-in-models/'>Mvc &#8211; In MVC + SOA Architecture, What is the Rationale for Placing Business Logic in Models</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>