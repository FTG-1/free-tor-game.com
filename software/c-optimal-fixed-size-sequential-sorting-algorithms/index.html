<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++ &#8211; Optimal fixed-size sequential sorting algorithms &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1086785 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1086785" class="post-1086785 software type-software status-publish hentry category-software tag-algorithms tag-c tag-sorting"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++ &#8211; Optimal fixed-size sequential sorting algorithms</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">algorithms</span><span class="mr-2 badge badge-info">c</span><span class="mr-2 badge badge-warning">sorting</span></p><div class="entry-content"><p>I have been working on sorting algorithms for a few weeks now, but one of my question still hasn&#39;t an answer: are there optimal sequential comparison sorts for fixed-size – and random-access – collections? Most sorting algorithms adapt to the size of the collection, but knowing the size of the collection to sort allows to pick a specific sorting algorithm for this size. For example, the following algorithm should sort three values with both an optimal number of comparisons and an optimal number of swaps or assignments (it&#39;s C++, but it should be fairly easy to translate to any language):</p><pre><code>void sort3(int&amp; x, int&amp; y, int&amp; z)
{    
    if (x &lt; y) {
        if (z &lt; y) {
            if (z &lt; x) {
                int tmp = z;
                z = y;
                y = x;
                x = tmp;
            } else {
                std::swap(y, z);
            }
        }
    } else if (z &lt; y) {
        std::swap(x, z);
    } else if (z &lt; x) {
        int tmp = x;
        x = y;
        y = z;
        z = tmp;
    } else {
        std::swap(x, y);
    }
}
</code></pre><p>Whatever the input, this algorithm will sort three values with at most 3 comparisons and 4 assignments. <em>I may be wrong</em>, but I don&#39;t think that sorting three values can be done with less comparisons and less assignments than this algorithm. If it is indeed the case, then this would be an optimal comparison sorting algorithm to sort three values.</p><p>It seems that optimal sorting algorithms of this kind for any size <em>could</em> be generated thanks to some permutation algorithm, but I was unable to find such a generation algorithm and writing one does not seem to be trivial. I tried to find <em>near-optimal</em> sorting algorithms for some fixed sizes, but couldn&#39;t find any simple way to generate such algorithms:</p><ul><li><p><a href="https://en.wikipedia.org/wiki/Sorting_network" rel="nofollow">Sorting networks</a> seemed like a good idea but they always perform a fixed number of comparisons and swaps, which means that they do not adapt to the data. Even <em>optimal sorting networks</em> of size greater than 5 qickly lose the battle against a simple insertion sort for some inputs.</p></li><li><p>Parallel sorting algorithms and non-comparison sorts (spreadsort, radix sort&#8230;) are interesting but I am interested in sequentially sorting small collections. And these categories of algorithms tend to hide a big constant complexity, which means that they are more suitable for big collections.</p></li><li><p>My current method to find the most optimal sorting algorithm to sort a small fixed-size collection is to count the number of comparisons needed to sort all the possible permutations of a collection of size N:</p><pre><code>// Fill an array of size N
std::array&lt;int, N&gt; collection;
std::iota(std::begin(collection), std::end(collection), 0);

// Count comparisons made by an insertion sort
cppsort::counting_adapter&lt;
    cppsort::insertion_sorter
&gt; sorter;

// Total number of comparisons
std::size_t count = 0;

// For each possible permutation of collection
do
{
    auto to_sort = collection;
    // Sort collection, get the number of comparisons made
    count += sorter(to_sort);
} while (std::next_permutation(std::begin(collection), std::end(collection)));
</code></pre><p>This code uses my <a href="https://github.com/Morwenn/cpp-sort" rel="nofollow">cpp-sort</a> library. I used it because it makes it easy to count comparisons made by a sorting algorithm, but it could be implemented without it or in another language. This method has a problem though: it only takes into account the number of comparisons and can only help to find the most optimal algorithm <em>amongst known algorithms</em>, it doesn&#39;t allow to write a sorting algorithms generators.</p></li></ul><p>That was quite the introduction, but my question is basically as follows: are there known methods to generate sequential comparison sorting algorithms for fixed-size collections that are optimal with regards to the number of assignments and/or the number of comparisons performed?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>The problem with finding <em>the</em> optimal algorithm is the word &#34;optimal&#34;: A sorting algorithm may be optimal in one case, but it will be suboptimal in at least one other case. The question is, what optimum you are designing it for. Take for instance your algorithm. It is optimal for the sequences:</p><pre><code>x &lt; y &lt;= z
x &gt;= y &gt; z
</code></pre><p>(Aside: This means that you failed to optimize the cases <code>x == y &lt;= z</code> and <code>x &gt;= y == z</code> properly, because they could have been handled by the same code paths. But that&#39;s not my point here.)</p><p>Yet your algorithm is suboptimal for the other four possible orderings. Now, you can write algorithms like yours, that are optimal for any two of the six possible orderings (taking two comparisons), but they will all require a third comparison in the other four cases.</p><p>It is simply not possible to write an algorithm that is optimal for any input order. This is true for any count of objects larger than two. That is, you have to decide, <em>what</em> input orderings to optimize for, and whether you have input orderings which you don&#39;t want to optimize for.</p><p>To take my point a bit further: Consider the two algorithms quick-sort and insertion-sort. Can you say that either one is absolutely better than the other? No, you can&#39;t. Quick-sort will be much faster for random input, but it will simply be pawned by insertion-sort on almost sorted input. Only when you know what kind of input data to <em>expect</em>, you can choose one over the other.</p><p>It is a bit like trying to measure location and momentum of a quantum particle. If you know one, you have no idea about the other, and vice versa. You can measure both at the same time, but then both will be inexact. Nature simply does not allow you to know both precisely at the same time. Likewise, when you compare <code>x</code> and <code>y</code> first in your algorithm, you are already breaking the symetry of the problem at hand, making optimal sorting of two thirds of the possible input sequences impossible.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-efficient-way-to-count-number-of-swaps-in-insertion-sort/'>C++ &#8211; efficient way to count number of swaps in insertion sort</a></li><li class="list-group-item"><a href='../sorting-an-array-of-numbers-with-decimal-places/'>Sorting an array of numbers with decimal places</a></li><li class="list-group-item"><a href='../algorithms-for-making-image-mosaics-is-there-a-quicker-way-than-this/'>Algorithms for making image mosaics &#8211; is there a quicker way than this</a></li><li class="list-group-item"><a href='../quickest-sorting-algorithm-for-sorting-a-low-number-of-integers/'>Quickest sorting algorithm for sorting a low number of integers</a></li><li class="list-group-item"><a href='../algorithm-to-merge-two-sorted-arrays-with-minimum-number-of-comparisons/'>Algorithm to merge two sorted arrays with minimum number of comparisons</a></li><li class="list-group-item"><a href='../how-does-pearson-hashing-compare-with-other-non-cryptographic-hashing-algorithms/'>How does Pearson hashing compare with other non-cryptographic hashing algorithms</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>