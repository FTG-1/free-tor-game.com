<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Is it appropite for a tokenizer to use regex to gather tokens &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1071138 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1071138" class="post-1071138 software type-software status-publish hentry category-software tag-lexer tag-regular-expressions"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Is it appropite for a tokenizer to use regex to gather tokens</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">lexer</span><span class="mr-2 badge badge-info">regular expressions</span></p><div class="entry-content"><p>I have recently caught the &#39;Toy Language&#39; bug, and have been experimenting with various simple tokenizer configurations. The most recent one, makes use of the boost.regex library to identify and get the value of tokens.  It seems to me that regex would be the preferred way to go, when creating a tokenizer. My research has proved my assumption to be false however, or at least not completely true.</p><p>This is what a user from Stack Overflow had to say regarding a question about: <a href="https://stackoverflow.com/questions/14761776/is-it-bad-idea-using-regex-to-tokenize-string-for-lexer">Is it bad idea using regex to tokenize string for lexer?</a>:</p><blockquote><p>Using regular expressions is THE traditional way to generate your tokens.</p></blockquote><p>After doing more research into this topic, I realized that even the most popular lexer generators use regex. For example, take the lexer generator <a href="https://en.wikipedia.org/wiki/Lex_(software)" rel="nofollow noreferrer">Lex</a>:</p><blockquote><p>Lex helps write programs whose control flow is directed by instances of <strong>regular expressions</strong> in the input stream. It is well suited for editor-script type transformations and for segmenting input in preparation for a parsing routine. &#8211; <a href="http://dinosaur.compilertools.net/lex/" rel="nofollow noreferrer">http://dinosaur.compilertools.net/lex/</a>.</p></blockquote><hr/><p>That lead me to  draw the conclusion that regex is the usual, preferred way to create a tokenizer. After researching my topic once more, and trying to find a second opinion however, I came across this statement in response to <a href="https://stackoverflow.com/questions/29395950/how-to-implement-a-language-interpreter-without-regular-expressions">this</a> question on Stack Overflow:</p><blockquote><p>The reason why people tell you that regular expressions aren&#39;t the best idea for a case like this is because regular expressions take more time to evaluate, and the regular expression language has many limitations and quirks that make it unsuitable for many applications. &#8211; user:670358</p></blockquote><p>And he went on to say</p><blockquote><p>Many compilers use a basic single-pass tokenization algorithm. The tokenizer has a very basic idea of what can be used as a delimiter, how constants and identifiers should be treated, etc. The tokenizer will then just iterate through the input quickly and emit a string of tokens that can then be easily parsed. &#8211; user:670358</p></blockquote><hr/><p>This left me both confused and contemplating several things:</p><ul><li>Is regex <strong>necessary</strong> for a hand built tokenizer. Or is it overkill?</li><li>If regex is not used often, then how extacly are the tokens parsed?</li></ul><p>This may or may not opinion based, but I believe that there is a preferred method/accepted method among programmers.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Regexs work great for lexing / tokenization.</p><p><strong>TL;DR</strong></p><p>Using regular expressions to tokenize is entirely appropriate. The default approach, really. As for efficiency, regexs traditionally map directly to <a href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="nofollow noreferrer">finite state machines</a>. They&#39;re about as simple and efficient as you can get for syntax definitions of any generality whatsoever.</p><p><a href="../../../i.stack.imgur.com/jARGa.png" rel="nofollow noreferrer"><img src="../../../i.stack.imgur.com/jARGa.png" alt="fsm graphic"/></a></p><p>Modern regex engines aren&#39;t pure mathematical FSM implementations, having been extended with features like look-ahead, look-behind, and backtracking. But they have a strong theoretical foundation, and in practice are highly optimized and extremely well vetted.</p><p>Much of the last fifty-plus years&#39; of computer language parsing boils down to finding techniques to detangle the process and make it practical. Divide and conquer / layering is common. Thus the idea of splitting the language understanding problem into a &#34;lexing&#34; lower level and &#34;parsing&#34; upper level.</p><p>The same with finding strength-reducing approaches like using only subsets of <a href="https://en.wikipedia.org/wiki/Context-free_grammar" rel="nofollow noreferrer">context-free</a> and ambiguity-free grammars. Pascal was limited to what could be parsed <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser" rel="nofollow noreferrer">recursive-descent</a>, and Python is famously restricted to <a href="https://en.wikipedia.org/wiki/LL_parser" rel="nofollow noreferrer">LL(1)</a>. There are whole alphabet soups of LL, LR, SLR, LALR, etc. language grammars / parser families. Almost all implemented language designs are carefully constrained by the parsing techniques they use. Perl is the only major language I can think of that isn&#39;t so constrained. This dance is described in the <a href="https://en.wikipedia.org/wiki/Dragon_Book" rel="nofollow noreferrer">&#34;Dragon book(s)&#34;</a> that were the most common &#34;how to language&#34; textbooks for generations.</p><p>The strict lexing/parsing split and &#39;use only subsets of unambiguous, context-free grammars&#39; rules are softening. Lexical understanding is now sometimes not split off as an entirely different layer, and most systems have enough CPU power and memory to make that feasible. <a href="https://softwareengineering.stackexchange.com/a/330000/55314">Another answer</a> mentioned <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar" rel="nofollow noreferrer">PEG</a> parsers. That starts to break the orthodoxy of language families. Even wider afield you can see renewed interest in more general parsers/grammars like the <a href="https://en.wikipedia.org/wiki/Earley_parser" rel="nofollow noreferrer">Earley parser</a> which go beyond the limited look-aheads of the LL/LR aristocracies. Recent implementations and refinements (e.g. <a href="http://blogs.perl.org/users/jeffrey_kegler/2011/11/what-is-the-marpa-algorithm.html" rel="nofollow noreferrer">Marpa</a>) show that, on modern hardware, there really is no barrier to generalized parsing.</p><p>All that said, however, infinite freedom (or even much greater freedom) is not necessarily a good thing. The mechanical, practical, and technique restrictions of any art form--writing, painting, sculpting, film-making, coding, etc.--often require a discipline of approach that is useful beyond matching available implementation techniques. Would Python, for instance, be greatly improved by generalizing beyond LL(1) parsing? It&#39;s not clear that it would. Sure there are a few unfortunate inconsistencies and limitations, and it needs that significant whitespace. But it also stays clean and consistent, across a vast number of developers and uses, partially as a result of those restrictions. Don&#39;t do the language equivalent of what happened when different type faces, sizes, colors, background colors, variations, and decorations became widely available in word processors and email. Don&#39;t use all the options profusely and indiscriminately. That&#39;s not good design.</p><p>So while large generality and even ambiguity are now open to you as you implement your toy language, and while you can certainly use one of the newly fashionable PEG or Earley approaches, unless you&#39;re writing something mimicking natural human language, you probably don&#39;t need to. Standard lexing and parsing approaches would suffice. Or, long story short, regexs are fine.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../python-coming-up-with-tokens-for-a-lexer/'>Python &#8211; Coming up with tokens for a lexer</a></li><li class="list-group-item"><a href='../can-the-csv-format-be-defined-by-a-regex/'>Can the csv format be defined by a regex</a></li><li class="list-group-item"><a href='../is-it-possible-to-create-a-single-tokenizer-to-parse-this/'>Is it possible to create a single tokenizer to parse this</a></li><li class="list-group-item"><a href='../what-should-be-the-datatype-of-the-tokens-a-lexer-returns-to-its-parser/'>What should be the datatype of the tokens a lexer returns to its parser</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>