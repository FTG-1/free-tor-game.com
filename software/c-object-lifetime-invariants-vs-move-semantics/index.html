<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++ &#8211; Object lifetime invariants vs. move semantics &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1078203 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1078203" class="post-1078203 software type-software status-publish hentry category-software tag-c tag-c11 tag-invariants tag-object-oriented-design"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++ &#8211; Object lifetime invariants vs. move semantics</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">c++11</span><span class="mr-2 badge badge-warning">invariants</span><span class="mr-2 badge badge-primary">object-oriented-design</span></p><div class="entry-content"><p>When I learned C++ long ago, it was strongly emphasized to me that part of the point of C++ is that just like loops have &#34;loop-invariants&#34;, classes also have invariants associated to the lifetime of the object &#8212; things that should be true for as long the object is alive. Things that should be established by the constructors, and preserved by the methods. Encapsulation / access control is there to help you enforce the invariants. RAII is one thing that you can do with this idea.</p><p>Since C++11 we now have move semantics. For a class that supports moving, moving from an object does not formally end its life-time &#8212; the move is supposed to leave it in some &#34;valid&#34; state.</p><p>In designing a class, is it <em>bad practice</em> if you design it so that the invariants of the class are only preserved up to the point that it is moved from? Or is that <em>okay</em> if it will allow you to make it go faster.</p><p>To make it concrete, suppose I have a non-copyable but moveable resource type like so:</p><pre><code>class opaque {
  opaque(const opaque &amp;) = delete;

public:
  opaque(opaque &amp;&amp;);

  ...

  void mysterious();
  void mysterious(int);
  void mysterious(std::vector&lt;std::string&gt;);
};
</code></pre><p>And for whatever reason, I need to make a copyable wrapper for this object, so that it can be used, perhaps in some existing dispatch system.</p><pre><code>class copyable_opaque {
  std::shared_ptr&lt;opaque&gt; o_;

  copyable_opaque() = delete;
public:
  explicit copyable_opaque(opaque _o)
    : o_(std::make_shared&lt;opaque&gt;(std::move(_o)))
  {}

  void operator()() { o_-&gt;mysterious(); }
  void operator()(int i) { o_-&gt;mysterious(i); }
  void operator()(std::vector&lt;std::string&gt; v) { o_-&gt;mysterious(v); }
};
</code></pre><p>In this <code>copyable_opaque</code> object, an invariant of the class established at construction is that the member <code>o_</code> always points to a valid object, since there is no default ctor, and the only ctor that isn&#39;t a copy ctor guarantees these. All of the <code>operator()</code> methods assume that this invariant holds, and preserve it afterwards.</p><p>However, if the object is moved from, then <code>o_</code> will then point to nothing. And after that point, calling any of the methods <code>operator()</code> will cause UB / a crash.</p><p>If the object is never moved from, then the invariant will be preserved right up to the dtor call.</p><p>Let&#39;s suppose that hypothetically, I wrote this class, and months later, my imaginary coworker experienced UB because, in some complicated function where lots of these objects were being shuffled around for some reason, he moved from one of these things and later called one of its methods. Clearly it&#39;s his fault at the end of the day, but is this class &#34;poorly designed?&#34;</p><p>Thoughts:</p><ol><li><p>It&#39;s usually bad form in C++ to create zombie objects that explode if you touch them.<br /> If you can&#39;t construct some object, can&#39;t establish the invariants, then throw an exception from the ctor. If you can&#39;t preserve the invariants in some method, then signal an error somehow and roll-back. Should this be different for moved-from objects?</p></li><li><p>Is it enough to just document &#34;after this object has been moved from, it is illegal (UB) to do anything with it other than destroy it&#34; in the header?</p></li><li><p>Is it better to continually assert that it is valid in each method call?</p></li></ol><p>Like so:</p><pre><code>class copyable_opaque {
  std::shared_ptr&lt;opaque&gt; o_;

  copyable_opaque() = delete;
public:
  explicit copyable_opaque(opaque _o)
    : o_(std::make_shared&lt;opaque&gt;(std::move(_o)))
  {}

  void operator()() { assert(o_); o_-&gt;mysterious(); }
  void operator()(int i) { assert(o_); o_-&gt;mysterious(i); }
  void operator()(std::vector&lt;std::string&gt; v) { assert(o_); o_-&gt;mysterious(v); }
};
</code></pre><p>The assertions don&#39;t substantially improve the behavior, and they cause a slow-down. If your project does use the &#34;release build / debug build&#34; scheme, rather than just always running with assertions, I guess this is more attractive, since you don&#39;t pay for the checks in the release build. If you don&#39;t actually have debug builds, this seems quite unattractive though.</p><ol start="4"><li>Is it better to make the class copyable, but not movable?<br /> This also seems bad and causes a performance hit, but it solves the &#34;invariant&#34; issue in a straightforward way.</li></ol><p>What would you consider to be the relevant &#34;best practices&#34; here?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>It&#39;s usually bad form in C++ to create zombie objects that explode if you touch them.</p></blockquote><p>But that&#39;s not what you&#39;re doing. You&#39;re creating a &#34;zombie object&#34; that will explode if you touch it <em>wrongly</em>. Which is ultimately no different than any other state-based precondition.</p><p>Consider the following function:</p><pre><code>void func(std::vector&lt;int&gt; &amp;v)
{
  v[0] = 5;
}
</code></pre><p>Is this function safe? No; the user can pass an <em>empty</em> <code>vector</code>. So the function has a de-facto precondition that <code>v</code> has at least one element in it. If it does not, then you get UB when you call <code>func</code>.</p><p>So this function is not &#34;safe&#34;. But that doesn&#39;t mean it&#39;s broken. It is only broken if the code using it violates the precondition. Maybe <code>func</code> is a static function used as a helper in the implementation of other functions. Localized in such a way, nobody would call it in a way that violates its preconditions.</p><p>Many functions, whether namespace-scoped or class members, will have expectations on the state of a value they operate on. If these preconditions are not met, then the functions will fail, typically with UB.</p><p>The C++ standard library defines a &#34;valid-but-unspecified&#34; rule. This says that, unless the standard says otherwise, every object which is moved from will be valid (it is a legal object of that type), but the <em>specific state</em> of that object is not specified. How many elements does a moved-from <code>vector</code> have? It doesn&#39;t say.</p><p>This means that you cannot call any function which has <em>any</em> precondition. <code>vector::operator[]</code> has the precondition that the <code>vector</code> has at least one element. Since you don&#39;t know the state of the <code>vector</code>, you cannot call it. It would be no better than calling <code>func</code> without first verifying that the <code>vector</code> is not empty.</p><p>But this also means that functions which <em>do not</em> have preconditions are fine. This is perfectly legal C++11 code:</p><pre><code>vector&lt;int&gt; v1 = {1, 2, 3, 4, 5};
vector&lt;int&gt; v2{std::move(v1)};
v1.assign({6, 7, 8, 9, 10});
</code></pre><p><code>vector::assign</code> has no preconditions. It will work with any valid <code>vector</code> object, even one that has been moved from.</p><p>So you&#39;re not creating an object that is broken. You&#39;re creating an object who&#39;s state is unknown.</p><blockquote><p>If you can&#39;t construct some object, can&#39;t establish the invariants, then throw an exception from the ctor. If you can&#39;t preserve the invariants in some method, then signal an error somehow and roll-back. Should this be different for moved-from objects?</p></blockquote><p>Throwing exceptions from a move constructor is generally considered... rude. If you move an object that owns memory, then you are transferring ownership of that memory. And that doesn&#39;t usually involve anything that can throw.</p><p>Sadly, <a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2015/p0129r0.html" rel="noreferrer">we can&#39;t enforce this for various reasons</a>. We have to accept that throwing-move is a possibility.</p><p>It should also be noted that you don&#39;t have to follow the &#34;valid-yet-unspecified&#34; language. That&#39;s simply the way the C++ standard library says that movement for standard types works <em>by default</em>. Certain standard library types have more strict guarantees. For example, <code>unique_ptr</code> is very clear about the state of a moved-from <code>unique_ptr</code> instance: it is equal to <code>nullptr</code>.</p><p>So you can choose to provide a stronger guarantee if you wish.</p><p>Just remember: movement is a <em>performance optimization</em>, one which is usually being done on objects that are <em>about</em> to be destroyed. Consider this code:</p><pre><code>vector&lt;int&gt; func()
{
  vector&lt;int&gt; v;
  //fill up `v`.
  return v;
}
</code></pre><p>This will move from <code>v</code> into the return value (assuming the compiler doesn&#39;t elide it). And there is <em>no way</em> to reference <code>v</code> after the move has completed. So whatever work you did to put <code>v</code> into a useful state is meaningless.</p><p>In most code, the likelihood of using a moved-from object instance is low.</p><blockquote><p>Is it enough to just document &#34;after this object has been moved from, it is illegal (UB) to do anything with it other than destroy it&#34; in the header?</p><p>Is it better to continually assert that it is valid in each method call?</p></blockquote><p>The whole point of having preconditions is to <em>not</em> check such things. <code>operator[]</code> has a precondition that the <code>vector</code> have an element with the given index. You get UB if you try to access outside the size of the <code>vector</code>. <code>vector::at</code> <em>does not</em> have such a precondition; it explicitly throws an exception if the <code>vector</code> does not have such a value.</p><p>Preconditions exist for performance reasons. They&#39;re so that you don&#39;t have to check things that the caller could have verified for themselves. Every call to <code>v[0]</code> doesn&#39;t have to check if <code>v</code> is empty; only the first one does.</p><blockquote><p>Is it better to make the class copyable, but not movable?</p></blockquote><p>No. In fact, a class should <em>never</em> be &#34;copyable but not movable&#34;. If it can be copied, then it should be able to be moved by calling the copy constructor. This is the standard behavior of C++11 if you declare a user-defined copy constructor but don&#39;t declare a move constructor. And it&#39;s the behavior you should adopt if you don&#39;t want to implement special move semantics.</p><p>Move semantics exist to solve a very specific problem: dealing with objects that have large resources where copying would be prohibitively expensive or meaningless (ie: file handles). If your object doesn&#39;t qualify, then copying and moving are the same to you.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-move-semantics-in-c-move-return-of-local-variables/'>C++ &#8211; Move semantics in C++ &#8211; Move-return of local variables</a></li><li class="list-group-item"><a href='../c-how-to-make-the-choice-between-non-copyable-non-movable-types-and-move-only-types-without-relying-on-intuition-or-implementation-details/'>C++ &#8211; How to make the choice between non-copyable non-movable types and move-only types without relying on intuition or implementation details</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>