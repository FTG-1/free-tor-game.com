<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Factories, vectors and smart pointers &#8211; Design Question &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1084433 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1084433" class="post-1084433 software type-software status-publish hentry category-software tag-c tag-design-patterns tag-factory-method tag-object-oriented tag-smart-pointer"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Factories, vectors and smart pointers &#8211; Design Question</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">design-patterns</span><span class="mr-2 badge badge-warning">factory-method</span><span class="mr-2 badge badge-primary">object-oriented</span><span class="mr-2 badge badge-danger">smart-pointer</span></p><div class="entry-content"><p>So, my Business Code needs some Objects.<br /> It does not know how much objects it needs and it does not know the exact types (because polymorphism is involved).<br /> For me, that sounds for a good reason to go factory pattern.</p><p>My code now looks like:</p><pre><code>std::vector&lt;AbstractBaseClass*&gt; objectList;
Factory f;
objectList = f.create(&#34;path/to/config.txt&#34;);
</code></pre><p>The prototype of the factory&#39;s create-method looks like:</p><pre><code>std::vector&lt;AbstractBaseClass*&gt; Factory ::create(std::string configFile)
</code></pre><p>Good news, its working!<br /> The Factory reads the config, and then decides how many objects to create and which concrete types they have.</p><p>Well, I did a lot of searching but I couldn&#39;t find an example of a factory returning not a single object but a container. Thus, my question: is this good style?</p><p>I think yes because this way the whole parsing/creation process is hidden from the business logic. The logic only knows it has some container with a bunch of objects. But maybe you have other opinions?<br /> Please note: this project is all about learning good OOP habits.</p><p>Ok, imagine this approach is OK.<br /> I learned, raw pointers are evil. (OK, they are not evil per definition, but I try to avoid them).<br /> So, I want to move to some smart pointers. Lacking <code>boost</code> and <code>C++11</code> on this machine I&#39;m starting with <code>auto_ptr</code>.</p><p>OK, new approach:</p><pre><code>std::vector&lt; auto_ptr&lt;AbstractBaseClass&gt; &gt; objectList;
Factory f;
objectList = f.create(&#34;path/to/config.txt&#34;);
</code></pre><p>And Factory:</p><pre><code>std::vector&lt; auto_ptr &lt;AbstractBaseClass&gt; &gt; Factory ::create(std::string configFile)
</code></pre><p>This looks evil.<br /> And it doesn&#39;t compile because at the moment, I&#39;m getting some crazy STL compiler errors.<br /> But, imagin&#39; it compiles.<br /> Is this good?</p><p>I&#39;ve never seen such a construct &#8211; a factory returning a container of smart pointers.<br /> And because I&#39;m not that expert, I want to ask what you think about this.</p><p>On a related note, what smart pointer shall I use?<br /> The business logic is the only owner of the objects, so I guess unique_ptr.<br /> However, I&#39;m not sure if a unique_ptr container can be returned.<br /> shared_ptr is easier to implement, I think.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>If you use C++ as a mostly OOP language, you&#39;ll have to deal with pointers in some form or another. The answer to almost all pointer problems is <code>std::unique_ptr</code>, because it has fairly value-like semantics while still enabling you to use polymorphism. Its only overhead is syntactic clutter. This is a lot better than</p><ul><li>raw pointers, because pointers have no inherent ownership semantics. I&#39;ve seen pointers being used for both reference-like borrowing semantics, and copy-like ownership transferral. That might be in the documentation, but it certainly isn&#39;t encoded in the source code or the type system.</li><li>the C++11 <code>std::shared_ptr</code> because this has additional overhead for reference counting.</li><li>the deprecated <code>std::auto_ptr</code> because it has confused semantics: copying behaves like moving, which also requires that the copy source is not <code>const</code> so that the moved pointer can be erased from the source. (Also note that the copy assignment operator for <code>std::vector</code> expects a const reference, so <code>vector&lt;auto_ptr&lt;T&gt;&gt;</code> is non-copyable.)</li><li>hand-written Pimpl wrappers, since it can be challenging to implement a type correctly – I&#39;ve seen enough memory leaks and segfaults from less-than-correct implementations (tip: make it impossible to use a null pointer as the impl). In fact, I recommend Pimpls to be implemented in terms of a private <code>unique_ptr</code> field since that takes care of all necessary resource management.</li></ul><p>However, using a Pimpl as Bridge Pattern can enable you to design a polymorphic class hierarchy with a value-based API but pointer-like semantics. In particular, you could use <code>vector&lt;BaseClass&gt;</code> as a more convenient notation for <code>vector&lt;unique_ptr&lt;BaseClassIf&gt;&gt;</code>.</p><p>The “problem” with <code>std::unique_ptr</code> is that it requires C++11. The core idea of this pointer type is that it can&#39;t be copied, but it can be moved. Therefore, ownership is always clearly defined. When you return an object by value, it will be subject to copy semantics (even if the actual copy might be optimized away), except in C++11 where move semantics will allow you to return an <code>unique_ptr</code> by value.</p><p>In general, using a container of smart pointers is perfectly fine, and better than the alternatives. In your case, it fails because of the restricted semantics of C++03 with regards to <code>auto_ptr</code>. If you can&#39;t upgrade to C++11 (which is supported in all current mainstream compilers), you have two realistic choices: use raw pointers, or wrap the pointer in a custom Pimpl. I&#39;d use the Pimpl if the effort is justifiable. It isn&#39;t tremendously complicated code, but you have to be careful to forward all necessary operations:</p><pre><code>class BaseClassIf {
public:
  virtual ~BaseClassIf() {}
  virtual void someOperation() = 0;
  virtual BaseClassIf* copy() = 0; // { return new T(*this); }
}

class BaseClass {
  BaseClassIf* impl;
  void assertInvariant() { if (!impl) throw ...; }
public:
  BaseClass(BaseClassIf* impl) : impl(impl) { assertInvariant(); }

  ~BaseClass() { if (impl) delete impl; impl = 0; }

  BaseClass(const BaseClass&amp; o) : impl(o.impl-&gt;copy()) { assertInvariant(); }

  void someOperation() { impl-&gt;someOperation(); }

private:
  BaseClass&amp; operator=(const BaseClass&amp;);
  // Cannot be reasonably overloaded as a value-based copy,
  // e.g. &#34;*impl = *rhs.impl&#34; since the exact types are unknown.
  // Cannot be overloaded as a reference copy,
  // e.g. &#34;impl = rhs.impl&#34; since that violates pointer ownership.
};
</code></pre><p>Note that the interface must make provisions to access the copy constructor, since the exact type is unknown by the <code>BaseClass</code> wrapper. This is an occasionally useful technique (e.g. as “type erasure” to hide template parameters), but here it&#39;s just annoying fallout from using polymorphism. Also note that it is not possible to define a copy assignment operator for the adapter, unless you include a common <code>virtual BaseClassIf::operator=(const BaseClassIf&amp;)</code> method in your interface – but most object hierarchies cannot do an useful copy from their common base.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../object-oriented-gtkmm-manage-add-vs-smart-pointers/'>Object-oriented &#8211; gtkmm manage/add vs smart pointers:</a></li><li class="list-group-item"><a href='../when-is-it-worth-not-using-a-factory/'>When is it worth NOT using a Factory</a></li><li class="list-group-item"><a href='../c-using-vectors-of-shared-pointers-to-objects-in-the-c-code-to-prevent-object-duplication/'>C++ &#8211; Using vectors of shared pointers to objects in the C++ code to prevent object duplication</a></li><li class="list-group-item"><a href='../c-api-design-using-references-vs-smart-pointers-in-a-getter-api/'>C++ API design: using references vs smart pointers in a getter API</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>