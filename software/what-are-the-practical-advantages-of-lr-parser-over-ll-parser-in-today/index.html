<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>What are the &#8216;practical&#8217; advantages of LR parser over LL parser &#8216;in today&#8217; &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1086250 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1086250" class="post-1086250 software type-software status-publish hentry category-software tag-compiler tag-parsing"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">What are the &#8216;practical&#8217; advantages of LR parser over LL parser &#8216;in today&#8217;</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">compiler</span><span class="mr-2 badge badge-info">parsing</span></p><div class="entry-content"><p>My English skill is poor because I&#39;m not a native English speaker.<br /> Please understand.</p><p>I write this article because want to discuss about this topic.</p><p>I think LR parser has no &#39;practical&#39; advantages over the LL parser. The fact that many tools uses LR parser is not a effective advantage.</p><p>I think the criteria of practical advantage is like below.</p><ol><li>Speed (fast -&gt; practical, slow -&gt; impractical)</li><li>Error recovery (easy -&gt; practical, difficult -&gt; impractical)</li><li>Convenience of compiler error display (easy -&gt; practical, difficult -&gt; impractical)</li><li>The cost for parser develop (easy -&gt; practical, difficult -&gt; impractical)</li></ol><p>I think that the speed of LL parser and LR parser is not much different. LR parser was fast enough to feel than LL parser because the performance of hardware was low in past. But in today, anymore LR parser is not fast enough to feel than LL parser. addition in today, other factors affect speed are greater.<br /> I am emphasizing &#39;in Today&#39;, yes I think the advantage in past is meanless.</p><p>So I think there is no significant difference on speed.</p><p>And on 2,3,4 feature, LL parser is good than LR parser overwhelmingly.<br /> The typical disadvantage of LR parser is difficult error handling. And this cause the external program (ex : IDE) difficult to display useful error.<br /> Addition the writing LL parser is easy than LR parser. this means the develop cost is low than LR parser.</p><p>&#39;I guess&#39; that clang compiler was consider this (error handling convenience, the development cost) and used LL(k) algorithm.<br /> Many modern parser generator, including the clang compiler, use LL(k) on the other hand LR-based compilers and parser generators were created a long time ago and are often updated until now.</p><blockquote><p>I think this phenomenon inform the trend has started to change from LR<br /> to LL.</p></blockquote><p>AI algorithm was useless in past because the performance of hardware was low but with improvement of performance of hardware AI algorithm show true worth.</p><p>Likewise that in past the performance of hardware was low so the speed of algorithm was top important so has to fast. In the result LR parser was useful greatly. but &#39;in today&#39; I think the speed is not the only thing that matters because the performance of hardware is so high.</p><p>I think the advantage LR parser compare to LL parser is only speed and the speed advantage also is not big. I think this only merit of LR parser gets lower with time because the performance of hardware increase.</p><p>I wonder what are the &#39;practical&#39; advantages of LR parser over LL parser &#39;in today&#39;?</p><p>Thank you for reading.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>True LL parsers are fast and simple – but also completely unable to parse many interesting languages. Many real-world programming languages are in the LALR class, which is closely related to LR but can be parsed far more efficiently. These different approaches like LL, LALR, LR are not just different algorithms, but they also correspond to a different set of languages that can be parsed.</p><p>For example, let&#39;s consider arithmetic expressions with this simple grammar:</p><pre><code>Expr ::= Expr &#34;+&#34; Term;
Expr ::= Term;
Term ::= Term &#34;*&#34; Factor;
Term ::= Factor;
Factor ::= Var;
Factor ::= Num;
</code></pre><p>This grammar would turn the input <code>x * 3 + 2</code> into the parse tree <code>Expr(Term(Term(Factor(Var(x)), &#34;*&#34;, Factor(Num(3))), &#34;+&#34;, Term(Factor(Num(2))))</code>.</p><p>While LL(k) is able to <em>recognize</em> this language, it cannot produce the correct parse tree because it cannot handle left-recursive productions directly. Where an LL parser is used, this frequently requires substantial post-processing of the parse tree to get a useful representation of the input. Also, massaging the grammar to fit the limitations of LL is very tedious, though some parser generators can do this automatically. And to be clear: LR also has some restrictions that the grammar needs to be written around.</p><p>So no one actually uses LL parsers. They seem simple but usually introduce more problems than they solve. They are not practical for most languages.</p><p>What is frequently used is Recursive Descent or PEG (= formalized RecDesc). These are closely related to LL in that their parse tree is the leftmost derivation, but have important extensions.</p><p>First, the concept of choice. LL(k) needs to choose the next production with constant lookahead, LL(*) has infinite lookahead but can only use a regular language (which can&#39;t even detect balanced parentheses…). In contrast, RecDesc and PEG use an ordered choice: first try this production, and backtrack if it doesn&#39;t work out to try another alternative. This works very well in practice but leads to exponential worst-time complexity. PEG can limit this with lookaheads and has a Packrat optimization that allows for a space–time tradeoff.</p><p>Second, these parsers are often not pure top-down parsers all the way. It is common to extend a RecDesc parser with a bottom-up parser for expression parsing (e.g. using Shunting Yard) or to combine PEG with a Pratt Parser for expressions. After all, any terminal in the grammar can be its own nested sublanguage in a top-down parser.</p><p>Third, the &#34;computational&#34; approach of RecDesc and PEG allow straightforward interaction with side effects. In some languages like Perl or C++, the correct parse depends on the current state of a symbol table. Whereas Perl extends a Yacc-generated LR parser, most C++ parsers are now RecDesc parsers.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../what-are-the-arguments-against-parsing-the-cthulhu-way/'>What are the arguments against parsing the Cthulhu way</a></li><li class="list-group-item"><a href='../chosing-a-parser-for-a-code-beautifier/'>Chosing a parser for a code beautifier</a></li><li class="list-group-item"><a href='../why-does-llvm-have-an-assembly-like-ir-rather-than-a-tree-like-ir-or-why-do-projects-target-llvm-ir-instead-of-clangs-ast/'>Why does LLVM have an assembly-like IR rather than a tree-like IR? Or: why do projects target LLVM IR instead of clang&#8217;s AST</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>