<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>How does a compiler work when it&#8217;s not directly compiling to machine code &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1079096 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1079096" class="post-1079096 software type-software status-publish hentry category-software tag-c tag-compiler"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">How does a compiler work when it&#8217;s not directly compiling to machine code</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">compiler</span></p><div class="entry-content"><p>I know the compilation process goes with this flow:</p><pre><code>source -&gt; parse -&gt; AST -&gt; intermediate code -&gt; assembly -&gt; machine code
</code></pre><p>and in the case of Java you will have bytecode which is translated by JVM.</p><p>In languages such as C/C++ and GO, we parse the source code and output direct machine code in a compiled file, easy enough;</p><p>But what about other languages, such as Java, JavaScript, Python etc?</p><p>Lets say I want to construct my own simple language and write it&#39;s <code>Just in time compiler</code> in <code>C</code>, my language is going to be similar to JavaScript, here is a code snippet:</p><p><strong>my language:</strong></p><pre><code>var a, b = 5;
print(a+b)
</code></pre><p>My compiler (which is written in C), after it has constructed an AST will try to add these 2 tree nodes together:</p><pre><code>int compilerDoAdd(node a, node b){
 return a + b;
}
</code></pre><p>Here is my question:</p><p>Is the above method the normal way to create a compiler? I&#39;m not creating a heap, I&#39;m not creating stack, I&#39;m not creating assembly, I&#39;m not creating machine code or instructions directly anywhere and I&#39;m just letting the <code>C</code> language do all that work for me. My compiler will act just as a parser.</p><p>Is this how other languages like Python and JavaScript work? or do they create their own machine instructions (and basically redo whatever C is designed to do)?</p><p>Edit. is what I just explained how an Interpreter works?<br /> I have read in many places that <code>An interpreter steps through the source code line by line, figuring out what itâ€™s doing and does it.</code> but it never explains how the <code>does it</code> works, does it turn into machines code? Or it works like how I explained it.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>I know the compilation process goes with this flow:</p><pre><code>source -&gt; parse -&gt; AST -&gt; intermediate code -&gt; assembly -&gt; machine code
</code></pre><p>,and in the case of Java you will have bytecode which is translated by JVM.</p></blockquote><p>This is not true for many, many, reasons.</p><ul><li>Not all compilers produce &#34;machine code&#34; (except for the trivial interpretation that <em>all code</em> in some language is machine code for an abstract machine induced by that language). For example, lots of compilers produce ECMAScript source code: CoffeeScript, TypeScript, PureScript, Elm, Opal, GWT, Emscripten, Babel, Clozure, Scala.js, Kotlin, Clue.</li><li>Not all compilers use assembly as an intermediate language.</li><li>Not all compilers use an intermediate language at all, they may generate code directly from the AST, for example.</li><li>Compilers may have multiple intermediate languages. E.g. in GCC, there are GENERIC, GIMPLE, and RTL, and frontends may also have their own intermediate languages as well.</li><li>Many compilers have a tokenization step (aka lexical analysis, lexing, scanning) before the parsing step.</li><li>Many compilers will first produce a parse tree (aka Concrete Syntax Tree / CST) and then transform that to an Abstract Syntax Tree / AST.</li><li>You are completely missing any form of semantic analysis, e.g. type checking, type inference, name resolution / binding, definite assignment.</li><li>Most compilers perform optimizations. In fact, the entirety of what is usually called the mid-end is missing from your description.</li><li>You are not accounting for things like macros, compile-time metaprogramming, compile-time reflection, etc., which may require embedding an interpreter (or another compiler) inside the compiler.</li></ul><blockquote><p>In languages such as C/C++ and GO, we parse the source code and output direct machine code in a compiled file, easy enough;</p></blockquote><p>This is also not true. There is nothing in the language specification of C, C++, or Go that says that it has to be implemented by a compiler that produces machine code. In fact, there is nothing in those specifications that says the language has to be implemented by a compiler at all.</p><p>For example, Cint is an interpreter for C. Clue is a compiler for C that outputs Lua, Javascript, Perl, Common Lisp, Java, or C. GCC, one of the most widely-used C compilers does not output machine code either, it actually outputs assembly to be compiled by an assembler. You just don&#39;t see it because for performance reasons, modern versions no longer write the assembly to a file, they hand the code off to the assembler directly in memory.</p><blockquote><p>But what about other languages, such as Java, Javascript, Python etc?</p></blockquote><p>Still the same. A language is simply a set of abstract mathematical / logical rules and restrictions. That&#39;s it. A language is a piece of paper, written in English.</p><p>How you implement this piece of paper is completely your choice. You could write an interpreter. You could write a compiler that outputs ECMAScript. You could write a compiler that outputs C. You could write a compiler that outputs JVM bytecode. You could write a compiler that outputs bytecode for a specialized VM for that language.</p><p>The <em>language</em> says nothing about how it is going to be implemented. That is purely a choice for the implementor. You can implement C with an interpreter if you want, and indeed, it has been done. You can implement ECMAScript with a compiler that compiles to native machine code if you want, and indeed, it has been done.</p><blockquote><p>Lets say I want to construct my own simple language and write it&#39;s Just in time compiler in C, my language is going to be similar to Javasciprt, here is a code snippet:</p><p><strong>my language</strong></p><pre><code>var a, b = 5;
print(a+b)
</code></pre><p>My compiler (which is written in C), after it has constrcuted an AST will try to add these 2 tree nodes together:</p><pre><code>int compilerDoAdd(node a, node b){
 return a + b;
}
</code></pre><p>Here is my question:</p><p>Is the above method the normal way to create a compiler?</p></blockquote><p>It depends on what you mean by &#34;normal way to create a compiler&#34;. There are many, many, many different ways of creating a compiler. This <em>could</em> in fact be part of a compiler that produces subroutine-threaded code or indirect-threaded code. If you interpret &#34;normal&#34; as &#34;common in mainstream compilers&#34;, then no, subroutine-threaded or indirect-threaded code is not used in mainstream compilers. Threaded code is popular in the Forth community, for example, but I would not consider Forth &#34;mainstream&#34; in the general purpose computing market.</p><p>It actually looks much more likely that what you have is a part of an interpreter. But it is impossible to say without knowing how this function is called, and what the rest of the code is doing.</p><blockquote><p>I&#39;m not creating a heap, I&#39;m not creating stack, I&#39;m not creating assembly, I&#39;m not creating machine code or instructions directly anywhere and I&#39;m just letting the C language do all that work for me.</p></blockquote><p>Heaps, stacks, assembly, machine code, they are not necessary components of a compiler. A compiler is simply a program which takes a program <strong>P</strong> written in language <strong>X</strong> as input and produces a semantically equivalent program <strong>Pâ€²</strong> written in language <strong>Y</strong> as output, where &#34;semantically equivalent&#34; means that running <strong>P</strong> on an interpreter for <strong>X</strong> should have the exact same result as running <strong>Pâ€²</strong> on an interpreter for <strong>Y</strong>.</p><blockquote><p>My compiler will act just as a parser.</p></blockquote><p>Well, then it is not a compiler, nor is it an interpreter. It is a parser.</p><blockquote><p>Is this how other languages like Python and Javascript work? or do they create their own machine instructions (and basically redo whatever C is designed to do)?</p></blockquote><p>Again, this has nothing to do with the language. It has to do with how the particular version of the particular implementation of the language works. For example, the Nashorn implementation of ECMAScript works very different from the V8 implementation of ECMAScript. And the current version of the V8 implementation of ECMAScript works very different than the original version of the V8 implementation of ECMAScript, both of which are again different from some of the versions that came in between.</p><blockquote><p>Edit. is what I just explained how an Interpreter works? I have read in many places that An interpreter steps through the source code line by line,</p></blockquote><p>Only some very simple interpreters do that. In fact, in languages where a single statement can span multiple lines, it isn&#39;t even possible to do this. For example, the following snippet of ECMAScript <em>cannot possibly</em> be executed line-by-line, since neither of the lines makes sense on its own:</p><pre><code>console.log(
&#34;Hello&#34;);
</code></pre><p>A <em>very simple</em> interpreter may indeed execute code statement-by-statement, but the majority of interpreters create an AST and interpret that. (So-called <em>AST-walking interpreters</em>.) The original interpreter for Ruby was such an interpreter, for example.</p><p>Many implementations that are <em>called</em> interpreters are actually combinations of interpreters and compilers. For example, the CPython &#34;Python interpreter&#34; actually compiles Python to CPython bytecode, then interprets that bytecode. So, technically calling it a &#34;Python interpreter&#34; is simply wrong, since it never interprets Python, it interprets a different language. However, calling it a &#34;Python compiler&#34;, while technically correct, could also be perceived as misleading.</p><blockquote><p>figuring out what itâ€™s doing and does it. but it never explains how the does it works, does it turn into machines code? or it works like how I explained it.</p></blockquote><p>If it turns it into machine code, then it is not an interpreter, it is a compiler.</p><p>Again: a compiler <em>translates</em> from one language to another. An interpreter <em>executes</em>.</p><p>To answer also some of your questions from the comments:</p><blockquote><p>Thanks for the great detailed info. So just to confirm, compilerDoAdd in it&#39;s current state is an interpreter?,</p></blockquote><p>It very much looks like an interpreter, but it could also be part of a compiler for subroutine-threaded or indirect-threaded code. It is impossible to tell without seeing the rest of the system. The main question is: do you call this function? If you call this function, then it is an interpreter. If you emit code that calls this function, then it is a subroutine-threaded compiler.</p><blockquote><p>by saying an interpreter executes things; this is how it&#39;s done? you let your parent language do the work</p></blockquote><p>In some sense this is trivially true. Your interpreter is written in some language, so everything this interpreter does, must somehow be performed by that language.</p><p>However, I interpret your question to mean whether there is usually a simple, direct, 1:1 mapping the interpreted language and the host language of the interpreter. The answer is most often: &#34;No&#34;. There can only be a simple, direct, 1:1 mapping if the semantics of the two languages are very similar. But if the semantics of the two languages are very similar, then why have two languages? Usually, we create new languages because we want them to be semantically <em>different</em> from existing languages. We want them to be in some sense &#34;better&#34;.</p><p>The only exception to this are languages that are specifically designed to be semantically identical (or close) but with different syntax. E.g. Vala and Genie are such examples, both Vala and Genie are intended to be semantically identical with Vala having a syntax inspired by Câ™¯ and Genie having a syntax inspired by Python. (Note, however, that in reality, both Vala and Genie are implemented as compilers to C, not as interpreters.)</p><p>Languages like TypeScript are also examples of this. TypeScript is designed to be mostly a semantic and syntactic superset of ECMAScript, so for the parts where TypeScript is semantically identical to ECMAScript, a hypothetical TypeScript interpreter implemented in ECMAScript could just use ECMAScript semantics to execute the code. (Note, however, that in reality, TypeScript is implemented as a compiler, not an interpreter, and it is implemented in TypeScript, not ECMAScript.)</p><p>Looking at your example, though, you say that your language is &#34;similar to JavaScript&#34;. In that case, what you have written is <em>probably</em> not valid, since you are assuming that adding two values in your language behaves the same as adding two <code>int</code>s in C. I can tell you that this is most definitely not the case for JavaScript, and if your language is similar in that aspect, then it is also not the case for yours!</p><p>For example, here are some properties of adding <code>int</code>s in C that are not true for adding values in JavaScript:</p><ul><li>Addition of <code>int</code>s in C is commutative: <code>a + b == b + a</code>. This is not true in JavaScript, e.g. for <code>a = &#34;Hello&#34;; b = &#34;World&#34;;</code>.</li><li><code>int</code>s in C have a limited range but they are always precise. Numbers in JavaScript have also a limited range, but <em>much larger</em> than typical <code>int</code>s in C. BUT!!! Most importantly, they are variably precise, i.e. numbers very close to <code>0</code> as well as very large and very small numbers are imprecise. For example, for a very large number <code>a</code> it can happen that <code>a + 1 == a</code>. This is not true for <code>int</code>s in C.</li><li>On the other hand, in JavaScript, it is always true that <code>a + 1 &gt;= a</code>, whereas in C, it can happen that <code>a + 1 &lt;= a</code>.</li></ul><p>So, it is highly likely that you will have to do more work to implement the <code>+</code> operator than simply to delegate to <code>int</code> addition in C. You will have to check whether <code>a</code> and <code>b</code> are strings, arrays, or numbers, and when they are numbers, you will have to check if the numbers are integers or real numbers, and when they are integers, you will have to check if the numbers and their result fit into a C <code>int</code> or you need e.g. something like a C <code>long</code> or even BigInt math, and generally do some other clever things, and implement your own logic for adding things. Especially if your language is really like JavaScript, where <code>[] + {}</code> is <code>{}</code> and <code>{} + []</code> is <code>0</code>.</p><p>Here are some other questions and answers on this site that may help you:</p><ul><li><a href="https://softwareengineering.stackexchange.com/a/269878/1352">Understanding the differences: traditional interpreter, JIT compiler, JIT interpreter and AOT compiler</a></li><li><a href="https://softwareengineering.stackexchange.com/a/269781/1352">Which components/phases of a JIT compiler are different from a traditional ahead of time compiler?</a></li><li><a href="https://softwareengineering.stackexchange.com/a/300639/1352">Does an interpreter produce machine code?</a></li></ul></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../python-general-rules-for-writing-a-x-compiler-to-z-in-y/'>Python &#8211; General rules for writing a X compiler to Z in Y</a></li><li class="list-group-item"><a href='../python-why-does-python-need-both-a-compiler-and-an-interpreter/'>Python &#8211; Why does Python need both a compiler and an interpreter</a></li><li class="list-group-item"><a href='../does-an-interpreter-produce-machine-code/'>Does an interpreter produce machine code</a></li><li class="list-group-item"><a href='../how-does-a-compiler-know-the-machine-language-of-targeted-processor-to-which-the-source-code-has-to-be-converted/'>How does a compiler know the machine language of targeted processor to which the source code has to be converted</a></li><li class="list-group-item"><a href='../how-does-garbage-collection-work-in-languages-which-are-natively-compiled/'>How does garbage collection work in languages which are natively compiled</a></li><li class="list-group-item"><a href='../how-does-code-work-without-getting-compiled-or-interpreted/'>How does code work without getting compiled or interpreted</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>