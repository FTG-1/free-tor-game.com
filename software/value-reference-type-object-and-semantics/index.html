<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Value/reference type, object and semantics &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1086151 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1086151" class="post-1086151 software type-software status-publish hentry category-software tag-reference tag-terminology tag-value-object"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Value/reference type, object and semantics</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">reference</span><span class="mr-2 badge badge-info">terminology</span><span class="mr-2 badge badge-warning">value-object</span></p><div class="entry-content"><p>What are the relationships between these pairs of concepts:</p><ul><li><a href="https://en.wikipedia.org/wiki/Value_type_and_reference_type" rel="nofollow noreferrer">value/reference type</a>;</li><li><a href="https://en.wikipedia.org/wiki/Value_object" rel="nofollow noreferrer">value/reference object</a>;</li><li><a href="https://en.wikipedia.org/wiki/Value_semantics" rel="nofollow noreferrer">value/reference semantics</a>?</li></ul><p>For the first pair of concepts, it seems to me that an object of value type is an <em>element</em> (data or procedure), and an object of reference type is the <em>location</em> (absolute or relative) of an element.</p><p>Questions:</p><ul><li>Is an object of value type a value object?</li><li>Is an object of reference type a reference object?</li><li>Does an object of value type have value semantics?</li><li>Does an object of reference type reference semantics?</li></ul></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><h1>TL;DR</h1><p>Note. — The meaning of &#34;value semantics&#34; in the context of programming has drifted, as evidenced by the definitions provided in the appendix. What follows is my attempt to make sense of it all.</p><ul><li>Value semantics is instance independence.</li><li>Value-semantic types are types with value semantics.</li><li>Reference semantics is instance interdependence.</li><li>Reference-semantic types are types with reference semantics.</li><li>Value type variables hold instances.</li><li>Reference type variables hold references to instances.</li><li>Objects are instances of classes.</li><li>Value objects have value based equality.</li><li>Value objects should have value semantics.</li><li>Value objects can be instances of either value types or reference types.</li><li>Reference objects have identity based equality.</li><li>Reference objects can be instances of either value types or reference types.</li><li>Entities are reference objects that have value.</li><li>Services are reference objects that do not have value.</li><li>Value semantics can be archived by:<ul><li>Complete copy. Which can be archived by:<ul><li>Shallow copy of value types without reference type fields.</li><li>Deep copy.</li></ul></li><li>Deep copy of mutable fields and shallow copy of immutable fields.</li><li>Immutable types.</li><li>Copy-on-write implementation.</li></ul></li><li>Reference semantics is archived by… not having value semantics.</li></ul><hr/><h2>Spaces in Memory</h2><p>Information is stored in spaces in memory where they can be reused. There three spaces in memory:</p><ul><li>Stack (e.g. arguments, local variables).</li><li>Heap (e.g. globals, static fields).</li><li>Relative (e.g. array elements, instance fields).</li></ul><p>Of each kind, there can be multiple spaces in memory. For example, multiple arguments. Each a space in memory.</p><p>A language/runtime/platform may or may not have any of these. For example, some do not have a stack. Some do not have arrays or composite types. And some do not have a heap. However, they will all have at least heap or stack.</p><p><em>We will not be talking about named constants, literals, immediate values, or the distinction between l-values and r-values.</em></p><hr/><h2>Variables</h2><p>In most languages we give names to spaces in memory. This makes it easier to use them. We call these named spaces in memory “variables”.</p><p>Going forward, we will refer to the information stored in the space in memory named by a variable as the contents of the variable.</p><p>It is also worth noting that the names of the variables may or may not exist in runtime (e.g. reflection), also if they do, their static type information may or may not exist in runtime (e.g. type erasure).</p><p>Furthermore, the position in memory of named variable may change.</p><p>Note. — What I call here contents, other authors call value. I&#39;m not calling it value, because I&#39;m using Lakos&#39; definition of value. However, I would agree that the contents of a variable is a value. A physical value. While the value that Lakos&#39; talks about is a <strike>platonic</strike> logic value.</p><hr/><h2>Types and Instances</h2><p>A type is a set of memory layout. We will refer to each of each of the possible memory layout of a given type that actually exist in memory as instances. <em>Instances may overlap in memory.</em></p><p>These memory layouts will define the contents of the variable that hold said instances. <em>See “Value Types and Reference Types” below.</em></p><hr/><h2>Variables and Types</h2><p>In a dynamically typed language, the contents of the variables can be of any type.</p><p>On the other hand, in statically typed languages, the variables have a type, and this type specifies the possible contents of the variable.</p><p>Note. — Some statically typed language support typing a variable as dynamic. That is, the type of the variable is “look into the contents of the variable to figure out the type”.</p><hr/><h2>Primitive Types and Composite Types</h2><p>Composite types are types constructed out of other types. Which is not true for primitive types.</p><p>Do not confuse primitive types with build-in types. That is the set of types provided by a languages. As currently plenty of languages provide composite types. Instead primitive types are indivisible within the constraints of the language.</p><hr/><h2>Equality</h2><p>Considering the instances of a type, we may or may not care about a concept of equality for these instances. That is, equality may or may not be part of the specification/requirements for the type.</p><p>We only care about equality, when the type has a concept of “value”.</p><hr/><h2>Values</h2><p>For types that have a concept of value, the value is derived from the contents of the instances. Or rather, I should say, that the contents represent the value.</p><p>However, the contents is not the value. I mean, the equality of the instances does not imply equal representation in memory. This is because there could be multiple representations in memory for the same value. Consider, for example, that in some types there are multiple ways to represent a value in memory, and thus would require canonization/normalization (e.g. strings, date, decimal floating point numbers).</p><p>This is also how we can say that values stored in different types have the same value, i.e. are equal (e.g. 5 stored in a short integer vs 5 stored in a long integer).</p><hr/><p>When dealing with composite types, we would talk about salient attributes.</p><p>From the book <em>Large-Scale C++ Volume I: Process and Architecture</em> by John S. Lakos:</p><blockquote><p>A salient attribute of a value-semantic type is one of its (typically observable) attributes that contributes to the overall value of the object itself.</p></blockquote><p><em>Will get to “value-semantic type”.</em></p><p>Only salient attributes are considered part of the value of a type, and which attributes are salient is decided by the specification/requirements for that type, not by the representation in memory.</p><hr/><h2>References</h2><p>References are variables such that their contents refers to an instance, instead of being an instance. That is, the contents will have a position in memory where an instance is found, instead of containing the instance directly.</p><p><em>What I define above would be pointers in C++. We are not talking about the C++ distinction of pointers and references.</em></p><p>In some platforms there is a garbage collector that may move instances around. When this happens, the garbage collector also has to update the references to them.</p><hr/><p>Due to composition, we may have instances that have references.</p><hr/><h2>Copy and Move</h2><p>Since each variable has a space in memory, when we assign a variable to another (assuming their types are compatible) we need to copy the contents. <em>See “Types of Copy” below.</em></p><p>If the types of the variables are not compatible. A conversion is necessary. One special case is when assigning to a reference.</p><p>In some cases, we know that a variable will cease to exist. For example, a local variable when returning from a subroutine goes out of scope. If we are returning the local variable, and assigning the returned value to another variable, the compiler may opt to not copy it, but move it instead. Moving here means changing the space in memory named by the variable.</p><p>Since move happens only when a variable is ceasing to exist. We do not have to worry about move.</p><hr/><h2>Pass by Reference and Pass by Value</h2><p>A parameter of a subroutine is a variable. When we call the subroutine, the parameters are assigned. If the parameters are types are references, then we are passing instances by references. Otherwise, they are passing by value. And yes, that is a copy.</p><hr/><h2>Types of Copy</h2><p>A shallow copy limits itself to copying the contents of a variable. On the other hand, a deep copy would follow references and copy them too. That is, a deep copy is recursive with respect to references.</p><p><em>Please note that these are not the only options when it comes to copy instances. We will come back to that.</em></p><hr/><p>For contents that do not include references, a shallow copy is a complete copy. However, for contents that include references, a deep copy is necessary to get a complete copy.</p><p>We will understand as complete copy, a copy of the whole memory layout of an instance. If we do not copy the whole, then it is an incomplete copy. If the memory layout does not have references and exists only in the contents of the variable, then a shallow copy is a complete copy. Otherwise, a shallow copy is an incomplete copy.</p><p>A shallow copy is the default.</p><hr/><p>Note. — A variable contents could be a handle to a resource. It could be an external resources, such as a a handle to a window object or a key to a row in a database table. It could also be an internal resource such as an index to an array (See <a href="https://en.wikipedia.org/wiki/Entity_component_system" rel="nofollow noreferrer">Entity-Component-System</a>). These are not references as defined above, however they can be considered as such (we could say a pointer is a physical reference, while a handle is a logical reference). If the referenced resources are not copied, they may provide a means for instances to affect each other. <em>See &#34;Rule of Three&#34; below</em>. You may also be interested in <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization" rel="nofollow noreferrer">RAII</a>. My personal opinion we should not try to archive value semantics with that include handles to external resources, and if we were to, it would require to copy those resources too.</p><hr/><h2>Value Types and Reference Types</h2><p>We find in the <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types" rel="nofollow noreferrer"><em>C# language reference</em></a>:</p><blockquote><p>A variable of a value type contains an instance of the type. This differs from a variable of a reference type, which contains a reference to an instance of the type.</p></blockquote><p>Reference types are types such that variables of that type are references to the instance. <em>That memory layout for reference types defines that the variables hold a reference to the instance.</em></p><p><em>In C++, only pointers and references are reference types. However, we find plenty of reference types in other languages. For example, Java and .NET classes are reference types. C# structs, by the way, are value types.</em></p><p>On the other hand, value types are types such that variables of that type are not references. In other words, the contents of the variable is the instance.</p><p><em>Do not confuse value types and reference types with value-semantic types and reference-semantic types. Also do not confuse value types with primitive types.</em></p><hr/><p>Now, since variables of reference types are references. And a shallow copy is the default. The assignment of reference types results in an incomplete copy… unless the default is overridden.</p><p>For value types, the assignment results in a complete copy, if and only, they are not composite types that include references. See also <a href="https://stackoverflow.com/a/945708/2326961">Can structs contain fields of reference types</a> (C#).</p><hr/><h2>Value-Semantic Types and Reference-Semantic Types</h2><p>A value-semantic type is a type such that copy provides instance independence. That is, the result of the copy should not be usable to mutate the original. <em>Emphasis on copy. This is not about making a reference.</em></p><p>This matches <a href="https://academy.realm.io/posts/swift-gallagher-value-semantics/" rel="nofollow noreferrer">Alexis Gallagher’s Mutation game</a>.</p><p>There are two simple ways to accomplish this:</p><ul><li>Providing a complete copy. As we saw earlier, we can have a complete copy with a value type that includes no reference type fields, or overriding the default copy with a deep copy.</li><li>Make the type immutable. With an immutable type, a shallow copy will provide instance independence regardless of whatever or not the instance includes references… The reason is that you cannot mutate the original anyway. <em>Which also means that it is OK for immutable instances to share memory.</em></li></ul><p>However, in general, you must provide a copy that copies every part of the instance which is not immutable. If the type is immutable, then shallow copy is sufficient. If the type has no immutable parts (and it is a reference type or a value type which includes references) then you must provide a deep copy. If some parts are immutable and some are not, then you can archive value semantics by doing a deep copy of the mutable parts (and shallow copy of the immutable parts, sharing them). Which, by the way, is neither a shallow copy nor a deep copy, but a mixture.</p><p>Note. — Bjarne Stroustrup only considers deep and shallow copy when defining value semantics in <a href="https://books.google.fr/books?id=We21AwAAQBAJ&amp;pg=PA637&amp;lpg=PA637&amp;dq=%E2%80%9Cvalue+semantics%22+%22deep+copy%22&amp;source=bl&amp;ots=og1J80pkdW&amp;sig=ACfU3U1bgBVssrqw6r_Rxecx22P5FgycRg&amp;hl=fr&amp;sa=X&amp;ved=2ahUKEwjMj7qQ3t7oAhXrDmMBHaypClMQ6AEwDnoECAwQKw#v=onepage&amp;q=%E2%80%9Cvalue%20semantics%22&amp;f=false" rel="nofollow noreferrer"><em>Programming: Principles and Practice Using C++</em></a>.</p><p>If we have a reference type, which only contains a field of an immutable reference type. Then it is sufficient to copy that reference. There is no need to copy the immutable instance. Then, when implement mutation operations by swapping that reference with a new one. This is copy-on-write.</p><hr/><h2>Value Objects</h2><p>From the book <em>Domain-Driven Design: Tackling Complexity in the Heart of Software</em> by Eric Evans (who coined the term “value object”):</p><blockquote><p>Does an object represent something with continuity and identity—something that is tracked through different states or even across different implementations? Or is it an attribute that describes the state of something else? This is the basic distinction between an ENTITY and a VALUE OBJECT.</p></blockquote><p>Evans also had the concern of value semantics:</p><blockquote><p>We don’t care which instance we have of a VALUE OBJECT. This lack of constraints gives us design freedom we can use to simplify the design or optimize performance. This involves making choices about copying, sharing, and immutability.</p></blockquote><hr/><p>We see the same definition, and the same concern for value semantics echoed by other authors.</p><p>From the book <em>Patterns of Enterprise Application Architecture</em> by Martin Fowler et al.:</p><blockquote><p>The key difference between reference and value objects lies in how they deal with equality. A reference object uses identity as the basis for equality […]. A Value Object bases its notion of equality on field values within the class. Thus, two date objects may be the same if their day, month, and year values are the same.
 […]
 Most languages have no special facility for value objects. For value objects to work properly in these cases it’s a very good idea to make them immutable—that is, once created none of their fields change. The reason for this is to avoid aliasing bugs. An aliasing bug occurs when two objects share the same value object and one of the owners changes the values in it.</p></blockquote><p>See also <a href="https://wiki.c2.com/?ValueObject" rel="nofollow noreferrer">Value Object</a>.</p><hr/><p>It is worth noting that Evans also describes Entities, which are objects that have value, are mutable, and have identity.</p><p>Beyond that, Evans also describes Services, which are objects that do not have value and are about behavior. A lot of threading constructs are services. For example, a read-write lock. A read-write lock is not a value.</p><hr/><p>Note. — I’m saying that value objects do not imply value semantics, only value equality. However, value semantics is a desirable feature of value objects. We can say that value objects without value semantics are poorly designed.</p><hr/><h2>Bonus Chatter</h2><p><strong>Rule of three</strong></p><p><em>This is particular to C++.</em></p><p>Let us say we want value semantics, and we have a value type that has no reference type fields. For this, the default shallow copy is sufficient.</p><p>Now, let us say we add a reference type field to our type. And thus, our shallow copy results in two instances with fields pointing to the same instance of the reference type.</p><p>To avoid the shallow copy we need to override the assignment operator, and implementing a deep copy. However, if we are not assigning to an existing variable but initializing a new one, the assignment operator does not get called, but the copy constructor instead (and again, the default is shallow copy). Thus, we need to override the copy constructor too.</p><p>We run into a similar problem with the default destructor. It will not follow reference. That is, it will not do a deep destruction. Which would mean we would be leaking the instance of the reference type field. Thus, we also need to override the default destructor.</p><p>Thus, we want to override the assignment operator, the copy constructor and the destructor. <em>This is not possible in most languages.</em></p><p>See also <a href="https://en.wikipedia.org/wiki/Rule_of_three_(C++_programming)" rel="nofollow noreferrer">Rule of three</a>.</p><hr/><h2>On References and Value Semantics</h2><p>We should not require the concept of references or pointers to define value semantics. Languages that do not have these concepts can still have value semantics.</p><hr/><p>There is another concept related to value objects we need to talk about: <a href="https://en.wikipedia.org/wiki/Data_transfer_object" rel="nofollow noreferrer">data transfer objects</a>. DTOs are meant to cross boundaries. They might be going to another process, even to another machine. They may not. When crossing these boundaries references do not work. And thus, DTOs must avoid references.</p><p>DTOs should have no behavior, and have value semantics.</p><p>DTOs are often confused with value objects. Martin Fowler:</p><blockquote><p>You usually can’t send the domain object itself, because it’s tied in a Web of fine-grained local inter-object references. So you take all the data that the client needs and bundle it in a particular object for the transfer—hence the term Data Transfer Object. (Many people in the enterprise Java community use the term value object for this, but this causes a clash with other meanings of the term Value Object).</p></blockquote><hr/><h2>Objects</h2><p>If you go back to the definition of object (according to Grady Booch), you will find that objects have identity (and state and behavior, which could be none). However, we are ignoring this definition, instead we are saying that objects are instances of classes.</p><p><em>Plus, I would argue that the name value object is influence by the fact that Evans was working in Java, and thus could not define custom value types. To reiterate, Value Objects in Java are of reference types.</em></p><hr/><h2>Thread Safety</h2><p>Another argument for value semantics is thread safety.</p><p>Please note that if we are passing references, even if const references, that could be modified by another thread behind the scenes, we will run into trouble. Thus, any reference must be to an immutable type or a thread safe type.</p><hr/><h1>Your Questions</h1><p><strong>is an object of value type a value object?</strong></p><p>Value objects can be of value types or reference types.</p><hr/><p><strong>is an object of reference type a reference object?</strong></p><p>Instances of reference types would be reference objects, unless they override equality.</p><hr/><p><strong>does an object of value type have value semantics?</strong></p><p>If it does not have reference type fields, or if it overrides the default copy to provide value semantics.</p><hr/><p><strong>does an object of reference type have reference semantics?</strong></p><p>If it is not immutable and does not override the default copy to provide value semantics.</p><hr/><h1>Appendix: Definitions of &#34;Value Semantics&#34;, a time line</h1><hr/><h2>1998</h2><p>This template version of <strong>List</strong> includes a generic iterator and <em>value semantics</em> to store generic data. Value semantics means that <strong>List</strong> stores instantiated <em>objects</em>, not <em>pointers</em> to objects. During insertion operations, <strong>List</strong> stores copies of data values instead of storing pointers. Although containers with value semantics allow applications to manage small objects and build-in types easily, many applications cannot tolerate the overhead of copying objects.</p><p>– Paul Anderson, Gail Anderson – <a href="https://books.google.com/books?id=LSfKMkrXRgUC" rel="nofollow noreferrer">Navigating C++ and Object-oriented Design</a></p><hr/><h2>2004</h2><p>STL containers are value semantic. When a task object is added to an STL container, the task object&#39;s allocator and copy constructor are called to clone the original. Similarly, when a task object is removed from an STL container, the task object&#39;s deallocator is called to delete the copy. The value semantics may be a performance concern, especially if producers and consumers frequently add tasks to and remove tasks from a queue.</p><p>– Ted Yuan – <a href="https://www.drdobbs.com/a-c-producer-consumer-concurrency-templa/184401751" rel="nofollow noreferrer">A C++ Producer-Consumer Concurrency Template Library</a></p><hr/><h2>2004</h2><p>ValueSemantics for objects-by-value are preserved by copying values between objects. ValueSemantics for objects-by-reference are preserved by using a CopyOnWrite mechanism. I had always thought that the story ended there. Are ValueObjects simply objects that preserve ValueSemantics or is there something more to them?</p><p>– PhilGoodwin – <a href="https://wiki.c2.com/?ValueObjectsCanBeMutable" rel="nofollow noreferrer">Value Objects Can Be Mutable</a></p><hr/><h2>2014</h2><p>Types that provide shallow copy (like pointers and references) are said to have pointer semantics or reference semantics (they copy addresses). Types that provide deep copy (like <strong>string</strong> and <strong>vector</strong>) are said to have value semantics (they copy the values pointed to). From a user perspective, types with value semantics behave as if no pointers were involved – just values that can be copied. One way of thinking of types with values semantics is that they “work just like integers” as far as copying is concerned.</p><p>– Bjarne Stroustrup – <a href="https://ptgmedia.pearsoncmg.com/images/9780321992789/samplepages/9780321992789.pdf" rel="nofollow noreferrer">Programming: Principles and Practice Using C++</a></p><hr/><h2>2015</h2><p>it&#39;s (…) possible for a type to be value semantic provided that it keeps one very important property true which is if two objects of the given type have the same value today and we apply in the same salient operation (by salient I mean an operation that is intended to approximate the Platonic type that lives outside of the process that we&#39;re using as our model) then after that operation is applied to both objects they will again have the same value or they never did and that is a key property of value semantics.</p><p>Another way to say this would be if two objects have the same value then there does not exist a distinguishing sequence of salient operations that will cause them to no longer have the same value.</p><p>– John Lakos – <a href="https://www.youtube.com/watch?v=CQANOtQ9IvE" rel="nofollow noreferrer">An interview with John Lakos</a></p><hr/><h2>2016</h2><p>Value semantics amounts to being a guarantee of the independence of the value of variables.</p><p>And independence doesn’t mean structural things. What we’re talking about is can one thing affect another. So a type has value semantics if the only way to modify a variable’s value, a variable that has the value semantic type, is through the variable itself. If the only way to modify a variable’s values is through the variable itself, it’s a variable with semantic type.</p><p>(…)</p><p>The type is value semantic if it’s immune from side effects produced by other things. Not if it’s guaranteed not to perpetrate side effects on other things.</p><p>– Alexis Gallagher – <a href="https://academy.realm.io/posts/swift-gallagher-value-semantics/" rel="nofollow noreferrer">Value SEMANTICS (not value types!)</a></p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../unique-value-object-vs-entity/'>Unique Value Object vs Entity</a></li><li class="list-group-item"><a href='../correct-terminology-in-type-theory-types-type-constructors-kinds-sorts-and-values/'>Correct terminology in type theory: types, type constructors, kinds/sorts and values</a></li><li class="list-group-item"><a href='../c-returning-persistent-objects/'>C++ returning persistent objects</a></li><li class="list-group-item"><a href='../c-immutable-string-in-array-reference-type-vs-value-type/'>C# &#8211; immutable string in array, reference type vs value type</a></li><li class="list-group-item"><a href='../in-domain-driven-design-is-a-timestamp-a-property-or-a-value-object/'>In domain driven design, is a timestamp a property or a value object</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>