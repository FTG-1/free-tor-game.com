<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="https://free-tor-game.com/wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++ &#8211; Are there real world examples demonstrating reasonable performance improvement by using move semantics &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js?ver=11.2.0' id='highlight-js'></script>     <script>( function( w, d, s, l, i ) {
				w[l] = w[l] || [];
				w[l].push( {'gtm.start': new Date().getTime(), event: 'gtm.js'} );
				var f = d.getElementsByTagName( s )[0],
					j = d.createElement( s ), dl = l != 'dataLayer' ? '&l=' + l : '';
				j.async = true;
				j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
				f.parentNode.insertBefore( j, f );
			} )( window, document, 'script', 'dataLayer', ' ' );</script>      <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1081947 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="https://free-tor-game.com/3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="https://free-tor-game.com/contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1081947" class="post-1081947 software type-software status-publish hentry category-software tag-c tag-c11 tag-memory tag-performance"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++ &#8211; Are there real world examples demonstrating reasonable performance improvement by using move semantics</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">c++11</span><span class="mr-2 badge badge-warning">memory</span><span class="mr-2 badge badge-primary">performance</span></p><div class="entry-content"><p>(I&#39;ve asked a similar question on <a href="https://stackoverflow.com/questions/29879687/any-real-world-cases-demonstrating-reasonable-performance-improvement-by-using-m?noredirect=1">SO</a> but unfortunately it might not be proper, so I also put here; please kindly point out if you think it&#39;s a duplicate.)</p><p>I&#39;ve heard <a href="http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/" rel="nofollow noreferrer">many</a> <a href="http://cpprocks.com/9-reasons-to-start-using-c11/" rel="nofollow noreferrer">words</a> about the <em>move semantics</em> (essentially rvalue) introduced in C++11. <em>In theory</em>, it should bring much performance improvement due to the fact it avoids unnecessary <em>copies</em>.</p><p>However, there have already been <a href="https://en.wikipedia.org/wiki/Copy_elision" rel="nofollow noreferrer">some optimization</a>s for legacy code during compilation to deal with the inefficient temporary copies, such as:</p><ul><li>(named) <a href="http://en.wikipedia.org/wiki/Return_value_optimization" rel="nofollow noreferrer">return value optimizations</a></li><li>constructor copy elision</li></ul><p>And additionally for frequently used data structures, some C++ standard libraries use special optimizations (e.g., small string optimization for <code>std::string</code>).</p><p>More importantly, although some pieces of legacy code are <em>really</em> inefficient they don&#39;t result in much latency since they are</p><ul><li>not frequently invoked</li><li>modern computers have enough physical memories for them</li></ul><p>So I&#39;m asking: are there <em>real-world examples</em> that greatly accelerate the performance when using modern C++ (C++11/14/17) syntax, or improve the performance by a reasonable percentage (e.g., &gt;10%) <em>overall</em>?</p><p>I expect that the answer can be any of the 3 categories:</p><pre><code>#include &lt;vector&gt;
using std::vector;
using std::size_t;

size_t const MAX = NNN;  // NNN is specified by -DNNN=xxx option
size_t const NUM = NNN/100;

vector&lt;int&gt; factory(size_t size) {
  vector&lt;int&gt; v;
  for (size_t i = 0u; i &lt; size; ++i) {
    v.push_back(i);
  }
  return v;
}

// Version 1
/// void doubles(vector&lt;int&gt; &amp; v) {
// Version 2
void doubles(vector&lt;int&gt; &amp;&amp; v) {
  for (size_t i = 0u; i &lt; v.size(); ++i) {
    v[i] = v[i] * 2;
  }
}

int main() {
// Version 1
/// vector&lt;int&gt; v = factory(MAX);
/// doubles(v);
// Version 2
  doubles(factory(MAX));
}
</code></pre><ol><li>Some performance bugs/bottlenecks existing in real world repositories that can be handled modern C++ well.</li><li>Some <em>profiling</em> for <em>a piece of code</em> that show the improvement.</li><li>Starting by modifying some of the <em>above</em> trivial code to help me get an example that can bring the performance benefit.</li></ol><p>And the improvement can still be viewed with <code>default</code> (e.g., <code>-O0</code>) compilation options (so <code>-fno-elide-constructors</code> is not allowed during compilation) by gcc <em><code>or</code></em> clang <em><code>or</code></em> MSVC.</p><p>I ask this question because I was doing a survey on the move semantics impact on performance for real world programs but after I tried some (trivial) code and did some basic profiling myself, I found that I simply cannot find the significant differences. So please forgive me if you feel it stupid/pedantic.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>If you need an overview of the benefits and best-practices on move semantics, please watch some of the <a href="https://isocpp.org/blog/category/video-on-demand" rel="nofollow">conference recordings on the <strong>isocpp</strong> website</a>. <br/><em>(At the bottom there&#39;s a link to older recordings.)</em></p><hr/><p>Bjarne Stroustrup provide a prime motivating example on his website.</p><p><a href="http://www.stroustrup.com/C++11FAQ.html#rval" rel="nofollow">http://www.stroustrup.com/C++11FAQ.html#rval</a></p><p>Just consider the typical implementation of <code>std::swap</code>, assuming that this method <em>does not have special access to the type</em>. <br/><sub>The sample code and comments below are copied verbatim from the link above.</sub></p><pre><code>template&lt;class T&gt; swap(T&amp; a, T&amp; b)      // &#34;old style swap&#34;
{
    T tmp(a);   // now we have two copies of a
    a = b;      // now we have two copies of b
    b = tmp;    // now we have two copies of tmp (aka a)
} 
</code></pre><p>When new objects are created, it incurs the cost of copying that object. Most of the time, this implies <em>deep copying - share nothing</em>, because each object must be prepared to be independently modifiable, because there&#39;s nothing to imply otherwise.</p><p>But in this example, it is clear that <code>tmp</code> is a temporary. What can we do to avoid the cost of deep copying in this case?</p><hr/><p>As @DocBrown points out in comment, the benefits of move semantics is dependent on:</p><ul><li>The coding style</li><li>The implementation of data structures used most heavily in the code</li></ul><hr/><p>In object oriented programming, there is a contentious issue: <strong>copying or sharing</strong>? (Another contentious issue is the <em>mutable or immutable</em>.)</p><p>Most software programs will spend time copying stuff. The questions are:</p><ul><li>Does the situation require copying?</li><li>Is there a cheaper way of copying?</li></ul><p>If two or more instances of code need access to the same object, and if all of these instances promise they will never modify the object (i.e. cause its states to change), then perhaps sharing the object reference (by pointer or other means) may be sufficient.</p><p>If one instance of code needs to make a copy so that the object can be modified, it will not benefit from most &#34;make copy cheap&#34; scheme.</p><p>Sometimes it is a middle ground. An object has multiple properties, and the code wants to make a copy so that one or several properties can be modified. In this case, &#34;make copy cheap&#34; would require one to allow sharing of unchanged properties between the old and new object. <em>(Note: move semantics <strong>does not</strong> enable this. I mention this because move semantics have to face a number of competing <strong>other kinds of semantics</strong>.)</em></p><hr/><p>C++ code that is written to a C style, with its heavy use of pointers, may not see any benefit, because such code already freely share any data structure by  sharing pointers, and do so without much syntactic safeguards.</p><p>C++ code that already implements reference counting (such as <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat" rel="nofollow">OpenCV&#39;s <code>Mat</code> class</a>), <a href="https://msdn.microsoft.com/en-us/library/417w8b3b.aspx" rel="nofollow">Microsoft COM pointers (<code>com_ptr_t</code>)</a>, etc., allow multiple instances of code to share the same piece of data.</p><hr/><p>The kind of C++ code that may benefit from move semantics are those that</p><ol><li>Mainly rely on STL data structures (most importantly <code>std::vector</code>),</li><li>Uses &#34;value semantics&#34; heavily (makes objects immutable, makes copies of objects heavily, prefers copying values to sharing references), and</li><li>In order for its performance improvements to be measurable,<ul><li>It should be doing some heavy-lifting (i.e. the amount of data and computation should be reasonably big to be measurable)</li><li>It should not be dominated by other types of bottlenecks (such as disk, IO, database, etc.).</li></ul></li></ol><hr/><p>One may say that each of those factors are questionable, and rightly so.</p><p>There are C++ programs that implement <strong>their own</strong> reference counting, reference-sharing schemes, lazy (on-demand) evaluation, asynchronous operations or promise-futures, etc., long before C++11 was conceived. These C++ programming environments chose a trajectory that make them largely independent of the evolutions of C++. From a historical perspective, they might be right, because the evolutions of C++ had apparently been stagnant for a decade or so, where most of the innovations are thought to be doable with library code (such as the Boost Libraries) without requiring changes to the language standard.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='https://free-tor-game.com/software/php-performance-benefit-to-using-immutable-objects-in-a-scripting-language/'>Php &#8211;  performance benefit to using immutable objects in a scripting language</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/c-are-there-alternatives-to-using-an-optional-type-in-a-multithreaded-environment/'>C++ &#8211; Are there alternatives to using an optional type in a multithreaded environment</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/c-using-php-or-c-for-in-real-world-electronic-devices/'>C++ &#8211; Using PHP or C++ for in real world electronic devices</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/maintenance-cost-of-simd-programming-code-base/'>Maintenance cost of SIMD programming code base</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/java-performance-benefit-to-using-the-method-reference-syntax-instead-of-lambda-syntax-in-java-8/'>Java &#8211;  performance benefit to using the method reference syntax instead of lambda syntax in Java 8</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/c-key-value-store-development-porting-to-modern-c/'>C++ &#8211; Key / Value store development porting to modern C++</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='http://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="https://free-tor-game.com/wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>