<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="https://free-tor-game.com/wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Is it possible to create a &#8220;bootstrapped&#8221; interpreter independent of the original interpreter &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js?ver=11.2.0' id='highlight-js'></script>     <script>( function( w, d, s, l, i ) {
				w[l] = w[l] || [];
				w[l].push( {'gtm.start': new Date().getTime(), event: 'gtm.js'} );
				var f = d.getElementsByTagName( s )[0],
					j = d.createElement( s ), dl = l != 'dataLayer' ? '&l=' + l : '';
				j.async = true;
				j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
				f.parentNode.insertBefore( j, f );
			} )( window, document, 'script', 'dataLayer', ' ' );</script>      <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1079915 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="https://free-tor-game.com/3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="https://free-tor-game.com/contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1079915" class="post-1079915 software type-software status-publish hentry category-software tag-compiler tag-interpreters tag-language-agnostic"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Is it possible to create a &#8220;bootstrapped&#8221; interpreter independent of the original interpreter</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">compiler</span><span class="mr-2 badge badge-info">interpreters</span><span class="mr-2 badge badge-warning">language-agnostic</span></p><div class="entry-content"><p>According to <a href="https://en.wikipedia.org/wiki/Bootstrapping_(compilers)" rel="noreferrer">Wikipedia, the term &#34;bootstrapping&#34; in the context of writing compilers means this</a>:</p><blockquote><p>In computer science, bootstrapping is the process of writing a compiler (or assembler) in the source programming language that it intends to compile. Applying this technique leads to a self-hosting compiler.</p></blockquote><p>And I can understand how that would work. However, the story seems to be a little different for interpreters. Now, of course, it is possible to write a self-hosting interpreter. That&#39;s not what I&#39;m asking. What I&#39;m actually asking is: <strong>Is it possible to make a self-hosted interpreter independent of the original, first interpreter</strong>. To explain what I mean, consider this example:</p><p>You write your first interpreter version in language <strong>X</strong>, and the interpreter is for a new language you&#39;re creating, called <strong>Y</strong>. You first use language <strong>X</strong>&#39;s compiler to create an executable. You now can interpret files written in your new language <strong>Y</strong> using the interpreter written in language <strong>X</strong>.</p><p>Now, as far as I understand, to be able to &#34;bootstrap&#34; the interpreter you wrote in language <strong>X</strong>, you&#39;d need to rewrite the interpreter in language <strong>Y</strong>. But here is the catch: even if you do rewrite the entire interpreter in language <strong>Y</strong>, you&#39;re still going to need the original interpreter you wrote in language <strong>X</strong>. Because to run the interpreter in language <strong>Y</strong>, you&#39;re going to have to interpret the source files. But what exactly is going to interpret the source files? Well, it can&#39;t be nothing, of course, so you&#39;re forced to still use the first interpreter.</p><p>No matter how many new interpreters you write in language <strong>Y</strong>, you&#39;re always going to have to use the first interpreter written in <strong>X</strong> to interpret the subsequent interpreters. This seems to be a problem simply because of the nature of interpreters.</p><p><em>However</em>, on the flip side, <a href="https://en.wikipedia.org/wiki/Interpreter_(computing)#Self-interpreter" rel="noreferrer">This Wikipedia article on interpreters actually talks about self-hosting interpreters</a>. Here is a small excerpt which is relevant:</p><blockquote><p>A self-interpreter is a programming language interpreter written in a programming language which can interpret itself; an example is a BASIC interpreter written in BASIC. Self-interpreters are related to self-hosting compilers.</p><p>If no compiler exists for the language to be interpreted, creating a self-interpreter requires the implementation of the language in a host language (which may be another programming language or assembler). By having a first interpreter such as this, the system is bootstrapped and new versions of the interpreter can be developed in the language itself</p></blockquote><p>It&#39;s still not clear to me though, how exactly this would be done. It seems that no matter what, you&#39;re always going to be forced to use the first version of your interpreter written in the host language.</p><p>Now the article mentioned above <a href="https://en.wikipedia.org/wiki/Meta-circular_evaluator#Examples" rel="noreferrer">links to another article in which Wikipedia gives some examples of supposed self-hosting interpreters</a>. Upon closer inspection though, it seems that the main &#34;interpreting&#34; part of many of those self-hosting interpreters (especially some of the more common ones such as PyPy or Rubinius) are actually written in other languages such as C++ or C.</p><p>So is what I describe above possible? Can a self-hosted interpreter be independent of its original host? If so, how exactly would this be done?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>The short answer is: you are right in your suspicion, you always need either another interpreter written in <strong>X</strong> or a compiler from <strong>Y</strong> to some other language for which you have an interpreter already. Interpreters execute, compilers only translate from one language to another, at <em>some</em> point in your system, there <em>must</em> be an interpreter â€¦ even it&#39;s just the CPU.</p><blockquote><p>No matter how many new interpreters you write in language <strong>Y</strong>, you&#39;re always going to have to use the first interpreter written in <strong>X</strong> to interpret the subsequent interpreters. This seems to be a problem simply because of the nature of interpreters.</p></blockquote><p>Correct. What you <em>can</em> do is write a compiler from <strong>Y</strong> to <strong>X</strong> (or another language for which you have an interpreter), and you can even do that in <strong>Y</strong>. Then you can run your <strong>Y</strong> compiler written in <strong>Y</strong> on the <strong>Y</strong> interpreter written in <strong>X</strong> (or on the <strong>Y</strong> interpreter written in <strong>Y</strong> running on the <strong>Y</strong> interpreter written in <strong>X</strong>, or on the <strong>Y</strong> interpreter written in <strong>Y</strong> running on the <strong>Y</strong> interpreter written in <strong>Y</strong> running on the <strong>Y</strong> interpreter written in <strong>X</strong>, or â€¦ ad infinitum) to compile your <strong>Y</strong> interpreter written in <strong>Y</strong> to <strong>X</strong>, so that you can then execute it on an <strong>X</strong> interpreter. That way, you have gotten rid of your <strong>Y</strong> interpreter written in <strong>X</strong>, but now you need the <strong>X</strong> interpreter (we know that we already have one, though, since otherwise we couldn&#39;t ran the <strong>X</strong> interpreter written in <strong>Y</strong>), <em>and</em> you had to write a <strong>Y</strong>-to-<strong>X</strong>-compiler first.</p><blockquote><p><em>However</em>, on the flip side, The Wikipedia article on interpreters actually talks about self-hosting interpreters. Here is a small excerpt which is relevant:</p><blockquote><p>A self-interpreter is a programming language interpreter written in a programming language which can interpret itself; an example is a BASIC interpreter written in BASIC. Self-interpreters are related to self-hosting compilers.</p><p>If no compiler exists for the language to be interpreted, creating a self-interpreter requires the implementation of the language in a host language (which may be another programming language or assembler). By having a first interpreter such as this, the system is bootstrapped and new versions of the interpreter can be developed in the language itself</p></blockquote><p>It&#39;s still not clear to me though, how exactly this would be done. It seems that no matter what, you&#39;re always going to be forced to use the first version of your interpreter written in the host language.</p></blockquote><p>Correct. Note that the Wikipedia article explicitly says that you need a <em>second</em> implementation of your language, and it doesn&#39;t say that you can get rid of the first.</p><blockquote><p>Now the article mentioned above links to another article in which Wikipedia gives some examples of supposed self-hosting interpreters. Upon closer inspection though, it seems that the main &#34;interpreting&#34; part of many of those self-hosting interpreters (especially some of the more common ones such as PyPy or Rubinius) are actually written in other languages such as C++ or C.</p></blockquote><p>Again, correct. Those are really bad examples. Take Rubinius, for example. Yes, it&#39;s true that the Ruby part of Rubinius is self-hosted, but it is a compiler, not an interpreter: it compiles to Ruby source code to Rubinius bytecode. The interpreter part OTOH isn&#39;t self-hosted: it interprets Rubinius bytecode, but it is written in C++. So, calling Rubinius a &#34;self-hosted interpreter&#34; is wrong: the <em>self-hosted</em> part isn&#39;t an <em>interpreter</em>, and the <em>interpreter</em> part isn&#39;t <em>self-hosted</em>.</p><p>PyPy is similar, but even more incorrect: it isn&#39;t even written in Python in the first place, it is written in RPython, which is a different language. It is syntactically similar to Python, semantically an &#34;extended subset&#34;, but it actually is a statically-typed language roughly on the same abstraction level as Java, and its implementation is a compiler with multiple backends which compiles RPython to C source code, ECMAScript source code, CIL byte code, JVM bytecode, or Python sourcecode.</p><blockquote><p>So is what I describe above possible? Can a self-host interpreter be independent of its original host? If so, how exactly would this be done?</p></blockquote><p>No, not on its own. You would either need to keep the original interpreter or write a compiler and compile your self-interpreter.</p><p>There <em>are</em> some meta-circular VMs, such as <a href="https://github.com/AdamSpitz/klein" rel="noreferrer">Klein</a> (written in <a href="http://www.selflanguage.org/" rel="noreferrer">Self</a>) and <a href="https://labs.oracle.com/pls/apex/f?p=labs:49:::::P49_PROJECT_ID:9" rel="noreferrer">Maxine</a> (written in Java). Note, however, that here the definition of &#34;meta-circular&#34; is yet different: these VMs are not <em>written</em> in the language they execute: Klein executes Self bytecode but is written in Self, Maxine executes JVM bytecode but is written in Java. However, the Self / Java source code of the VM actually gets compiled to Self / JVM bytecode and then executed by the VM, so by the time the VM gets executed, it <em>is</em> in the language it executes. Phew.</p><p>Note also that this is different from VMs such as the <a href="http://squeak.org/" rel="noreferrer">SqueakVM</a> and the <a href="http://jikesrvm.org/" rel="noreferrer">Jikes RVM</a>. Jikes is written in Java, and the SqueakVM is written in Slang (a statically typed syntactic and semantic subset of Smalltalk roughly on the same abstraction level as a high-level assembler), and both get statically compiled to native code before they are run. They don&#39;t run inside of themselves. You <em>can</em>, however, run them <em>on-top of themselves</em> (or on top of another Smalltalk VM / JVM). But that is not &#34;meta-circular&#34; in this sense.</p><p>Maxine and Klein, OTOH <em>do</em> run inside of themselves; they execute their own bytecode using their own implementation. This is truly mindbending! It allows some cool optimization opportunities, for example since the VM executes itself together with the user program, it can inline calls from the user program to the VM and vice versa, e.g. call to the garbage collector or the memory allocator can be inlined into user code, and reflective callbacks in the user code can be inlined into the VM. Also, all of the clever optimization tricks that modern VMs do, where they watch the executing program and optimize it depending on the actual workload and data, the VM can apply those same tricks to itself while it is executing the user program while the user program is executing the specific workload. In other words, the VM highly specialized itself for <em>that</em> particular program running <em>that</em> particular workload.</p><p>However, notice I skirted around the use of the word &#34;interpreter&#34; above, and always used &#34;execute&#34;? Well, those VMs aren&#39;t built around interpreters, they are built around (JIT) compilers. There was an interpreter added to Maxine later, but you always need the compiler: you have to run the VM <em>once</em> on top of another VM (e.g. Oracle HotSpot in the case of Maxine), so that the VM can (JIT) compile itself. In the case of Maxine, it will JIT compile its own bootup phase, then serialize that compiled native code to a bootstrap VM image and stick a very simple bootloader in front (the only component of the VM written in C, although that&#39;s just for convenience, it could be in Java also). Now you can use Maxine to execute itself.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='https://free-tor-game.com/software/python-general-rules-for-writing-a-x-compiler-to-z-in-y/'>Python &#8211; General rules for writing a X compiler to Z in Y</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/understand-scripting-language/'>Understand scripting language</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/why-is-studying-a-lisp-interpreter-in-lisp-so-important/'>Why is studying a Lisp interpreter in lisp so important</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/how-does-garbage-collection-work-in-languages-which-are-natively-compiled/'>How does garbage collection work in languages which are natively compiled</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='http://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="https://free-tor-game.com/wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>