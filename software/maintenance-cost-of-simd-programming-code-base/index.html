<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Maintenance cost of SIMD programming code base &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1080523 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1080523" class="post-1080523 software type-software status-publish hentry category-software tag-estimation tag-optimization tag-performance"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Maintenance cost of SIMD programming code base</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">estimation</span><span class="mr-2 badge badge-info">optimization</span><span class="mr-2 badge badge-warning">performance</span></p><div class="entry-content"><h3>Question:</h3><p>The software industry&#39;s consensus is that clean and simple code is fundamental to the long-term viability of the code base and the organization that owns it. These properties lead to lower maintenance costs and increased likelihood of the code base being continued.</p><p>However, SIMD code is different than general application code, and I would like to know if there is a similar consensus regarding clean and simple code applying specifically to SIMD code.</p><hr/><p><strong>Background to my question.</strong></p><p>I write plenty of SIMD (single-instruction, multiple data) code for various image processing and analysis tasks. Recently I also had to port a small number of these functions from one architecture (SSE2) to another (ARM NEON).</p><p>The code is written for shrink-wrapped software, therefore it cannot depend on proprietary languages without unrestricted redistribution rights such as MATLAB.</p><p>An example of typical code structure:</p><ul><li>Using <a href="http://opencv.org/" rel="nofollow noreferrer">OpenCV</a>&#39;s matrix type <a href="http://docs.opencv.org/modules/core/doc/basic_structures.html#mat" rel="nofollow noreferrer">(<code>Mat</code>)</a> for all memory, buffer and lifetime management.</li><li>After checking the size (dimensions) of input arguments, the pointers to the start address of each row of pixels is taken.</li><li>The pixel count, and the start addresses of each row of pixels from each input matrix is passed into some low-level C++ functions.</li><li>These low-level C++ functions use SIMD intrinsics (for <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/" rel="nofollow noreferrer">Intel Architecture</a>, and <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0472j/chr1359125040001.html" rel="nofollow noreferrer">ARM NEON</a>), loading from and saving to raw pointer addresses.</li><li>Characteristics of these low-level C++ functions:<ul><li>Exclusively one-dimensional (consecutive in memory)</li><li>Does not deal with memory allocations. <br /><em>(Every allocation, including temporaries, are handled by the outer code using OpenCV facilities.)</em></li><li>The range of name lengths of symbols (intrinsics, variable names, etc) are roughly 10 &#8211; 20 characters, which is quite excessive. <br /><em>(Reads like techno-babble.)</em></li><li>Reuse of SIMD variables is discouraged because compilers are quite buggy in correctly parsing code that is <em>not</em> written in the &#34;single-assignment&#34; coding style. <br /><em>(I&#39;ve filed several compiler bug reports.)</em></li></ul></li></ul><hr/><p><strong>What aspects of SIMD programming would cause the discussion to differ from the general case?  Or, why is SIMD different?</strong></p><p><strong>In terms of initial development cost</strong></p><ul><li>It is well-known that the initial development cost of C++ SIMD code with good performance is about 10x &#8211; 100x (with a wide margin) compared to <em>casually-written</em> C++ code.</li><li>As noted in the answers to <a href="https://softwareengineering.stackexchange.com/questions/204355/choosing-between-performance-vs-readable-cleaner-code">Choosing between performance vs readable/cleaner code?</a> , most code (including casually-written code and SIMD code) is initially <strong><em>neither clean nor fast</em></strong>.</li><li>Evolutionary improvements in code performance (in both scalar and SIMD code) is discouraged (because it is seen as a kind of <strong><em>software rework</em></strong>), and the cost and benefit is not tracked.</li></ul><p><strong>In terms of propensity</strong><br /> <em>(e.g. <a href="http://en.wikipedia.org/wiki/Pareto_principle" rel="nofollow noreferrer">the Pareto principle, a.k.a. the 80-20 rule</a>)</em></p><ul><li>Even if image processing only comprises 20% of a software system (in both code size and functionality), image processing is comparatively slow (when viewed as a percentage of CPU time spent), taking more than 80% of time.<ul><li>This is due to the data size effect: A typical image size is measured in megabytes, whereas the typical size of non-image data is measured in kilobytes.</li></ul></li><li>Within the image processing code, a SIMD programmer is trained to automatically recognize the 20% code comprising the hotspots by identifying the loop structure in the C++ code. Thus, from a SIMD programmer&#39;s perspective, 100% of the &#34;code that matters&#34; is performance bottleneck.</li><li>Often in an image processing system, multiple hotspots exist and take up comparable proportions of time. For example, there may be 5 hotspots each taking up (20%, 18%, 16%, 14%, 12%) of total time. To achieve a high performance gain, all of the hotspots need to be rewritten in SIMD.<ul><li>This is summarized as the <strong><em>balloon-popping rule</em></strong>: a balloon cannot be popped twice.</li><li>Suppose there are some balloons, say 5 of them. The only way to decimate them is to pop them one by one.</li><li>Once the first balloon is popped, the remaining 4 balloons now comprises a higher percentage of total execution time.</li><li>To make further gains, one must then pop another balloon. <br /><em>(This is <strong>in defiance to</strong> the 80-20 rule of optimization: a good economical outcome can be achieved after the 20% of lowest-hanging fruits has been picked.)</em></li></ul></li></ul><p><strong>In terms of readability and maintenance</strong></p><ul><li><p>SIMD code is patently hard to read.</p><ul><li>This is true even if one follows every software engineering best-practice e.g. naming, encapsulation, const-correctness (and making side-effects obvious), function decomposition, etc.</li><li>This is true even for experienced SIMD programmers.</li></ul></li><li><p>Optimal SIMD code is very contorted, <em>(see remark)</em> compared to its equivalent C++ prototype code.</p><ul><li>There are many ways to contort SIMD code, but only 1 out of 10 such attempts will attain acceptably fast results.</li><li><em>(That is, in the tunes of 4x-10x performance gains in order to justify to high development cost. Even higher gains have been observed in practice.)</em></li></ul></li></ul><p><strong><em>(Remark)</em></strong><br /> This is the main thesis of <a href="http://people.csail.mit.edu/jrk/halide12/" rel="nofollow noreferrer">the MIT Halide project</a> &#8211; quoting the paper&#39;s title verbatim:</p><blockquote><blockquote><p>&#34;decoupling algorithms from schedules for easy optimization of image processing pipelines&#34;</p></blockquote></blockquote><p><strong>In terms of forward applicability</strong></p><ul><li>SIMD code is strictly tied to a single architecture. Each new architecture (or each widening of SIMD registers) requires a rewrite.</li><li>Unlike the majority of software development, each piece of SIMD code is typically written for a single purpose that never changes.<br /><em>(With the exception of porting to other architectures.)</em></li><li>Some architectures maintain perfect backward compatibility (Intel); some fall short by a trivial amount (ARM AArch64, replacing <code>vtbl</code> with <code>vtblq</code>) but which is sufficient to cause some code to fail to compile.</li></ul><p><strong>In terms of skills and training</strong></p><ul><li>It is not clear what knowledge prerequisites are required to properly train a new programmer to write and maintain SIMD code.</li><li>College graduates who have learned SIMD programming in school seems to despise and dismiss it as an impractical career track.</li><li>Disassembly-reading and low-level performance profiling are cited as two fundamental skills for writing high-performance SIMD code. However, it is unclear how to systematically train programmers in these two skills.</li><li>Modern CPU architecture (which diverges significantly from what is taught in textbooks) makes training even more difficult.</li></ul><p><strong>In terms of correctness and defect-related costs</strong></p><ul><li>A single SIMD processing function is actually cohesive enough that one can establish correctness by:<ul><li>Applying formal methods <em>(with pen-and-paper)</em>, and</li><li>Verifying output integer ranges <em>(with prototype code and performed outside run-time)</em>.</li></ul></li><li>The verification process is, however, very costly (spends 100% time on code review and 100% time on prototype model checking), which triples the already-expensive development cost of SIMD code.</li><li>If a bug somehow manages to slip through this verification process, it is nearly impossible to &#34;repair&#34; (fix) except to replace (rewrite) the suspected defective function.</li><li>SIMD code suffers from the blunt of defects in the C++ compiler (optimizing code generator).<ul><li>SIMD code generated using C++ <em>expression templates</em> also suffers greatly from defects of the compiler.</li></ul></li></ul><p><strong>In terms of disruptive innovations</strong></p><ul><li><p>Many solutions have been proposed from academia, but few are seeing widespread commercial usage.</p><ul><li>MIT Halide</li><li>Stanford Darkroom</li><li>NT2 (Numerical Template Toolbox) and the related Boost.SIMD</li></ul></li><li><p>Libraries with widespread commercial usage do not seem to be heavily SIMD-enabled.</p><ul><li>Open-source libraries seem lukewarm to SIMD.<ul><li>Recently I have this first-hand observation of this after profiling a large number of OpenCV API functions, as of version 2.4.9.</li><li>Many other image processing libraries I have profiled also do not make heavy use of SIMD, or they miss the true hotspots.</li></ul></li><li>Commercial libraries seem to avoid SIMD altogether.<ul><li>In a few cases, I have even seen image processing libraries reverting SIMD-optimized code in an earlier version to non-SIMD code in a later version, resulting in severe performance regressions. <br /><em>(The vendor&#39;s response is that it was necessary to avoid compiler bugs.)</em></li></ul></li></ul></li></ul><hr/><p>This Programmer&#39;s question: <a href="https://softwareengineering.stackexchange.com/questions/179924/does-low-latency-code-sometimes-have-to-be-ugly">Does low latency code sometimes have to be &#34;ugly&#34;?</a> is related, and I previously wrote an answer to that question to explain my view points a few years ago.</p><p>However, that answer is pretty much &#34;appeasement&#34; to the &#34;premature optimization&#34; viewpoint, i.e. to the viewpoint that:</p><ul><li>All optimizations are <em>premature by definition</em> (or, <strong><em>short-term by nature</em></strong>), and</li><li>The only optimization that has long-term benefit is toward simplicity.</li></ul><p>But such viewpoints are contested in this <a href="http://ubiquity.acm.org/article.cfm?id=1147993" rel="nofollow noreferrer">ACM article</a>.</p><hr/><p><strong>All of that leads me to ask:</strong><br /> SIMD code is different than general application code, and I would like to know if there is a similar industry consensus regarding the value of clean and simple code for SIMD code.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>I did not write much SIMD code for myself, but a lot of assembler code some decades ago. AFAIK using SIMD intrinsics is essentially assembler programming, and your whole question could be rephrased just by replacing &#34;SIMD&#34; by the word &#34;assembly&#34;. For example, the points you already mentioned, like</p><ul><li><p>the code takes 10x to 100x to develop than &#34;high level code&#34;</p></li><li><p>it is tied to a specific architecture</p></li><li><p>the code is never &#34;clean&#34; nor easy to refactor</p></li><li><p>you need experts for writing and maintaining it</p></li><li><p>debugging and maintaining is hard, evolving really hard</p></li></ul><p>are in no way &#34;special&#34; to SIMD - these points are true for any kind of assembly language, and they are all &#34;industry consensus&#34;. And the conclusion in the software industry is also pretty much the same as for assembler:</p><ul><li><p>don&#39;t write it if you don&#39;t have to - use a high level language whereever possible and let compilers do the hard work</p></li><li><p>if the compilers are not sufficient, at least encapsulate the &#34;low level&#34; parts in some libraries, but avoid to spread the code all over your program</p></li><li><p>since it is almost impossible to write &#34;self-documenting&#34; assembler or SIMD code, try to balance this by lots of documentation.</p></li></ul><p>Of course, there is indeed a difference to the situation with &#34;classic&#34; assembly or machine code: today, modern compilers typically produce high quality machine code from a high level language, which is often better optimized than assembler code written manually. For the SIMD architectures which are popular today, the quality of the available compilers is AFAIK far below that - and maybe it will never reach that, since automatic vectorization is still a topic of scientific research. See, for example, <a href="http://yosefk.com/blog/humans-and-compilers-need-each-other-the-vliw-simd-case.html" rel="nofollow">this article</a> which describes the differences in opimization between a compiler and a human, giving a notion that it might be very hard to create good SIMD compilers.</p><p>As you described in your question already, there exist also a quality problem with current state-of-the-art libraries. So IMHO best we can hope is that in the next years the quality of the compilers and libraries will increase, maybe the SIMD hardware will have to change to become more &#34;compiler friendly&#34;, maybe specialized programming languages supporting easier vectorization (like Halide, which you mentioned twice) will become more popular (wasn&#39;t that already a strength of Fortran?). According to <a href="http://en.wikipedia.org/wiki/SIMD#History" rel="nofollow">Wikipedia</a>, SIMD became &#34;a mass product&#34; around 15 to 20 years ago (and Halide is less than 3 years old, when I interpret the docs correctly). Compare this to the time compilers for &#34;classic&#34; assembly language needed to become mature. According to <a href="http://en.wikipedia.org/wiki/Optimizing_compiler#History" rel="nofollow">this Wikipedia article</a> it took almost 30 years (from ~1970 to the end of the 1990s) until compilers exceeded the performance of human experts (in producing non-parallel machine code). So we may just have to wait more 10 to 15 years until the same happens to SIMD-enabled compilers.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../object-oriented-does-mobile-based-android-development-benefit-from-object-oriented-programming/'>Object-oriented &#8211; Does mobile based (Android) development, benefit from Object Oriented Programming</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>