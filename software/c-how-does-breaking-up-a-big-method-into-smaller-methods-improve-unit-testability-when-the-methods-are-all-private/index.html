<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C# &#8211; How does breaking up a big method into smaller methods improve unit testability when the methods are all private &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1079956 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1079956" class="post-1079956 software type-software status-publish hentry category-software tag-c tag-refactoring tag-tdd tag-unit-testing"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C# &#8211; How does breaking up a big method into smaller methods improve unit testability when the methods are all private</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">refactoring</span><span class="mr-2 badge badge-warning">tdd</span><span class="mr-2 badge badge-primary">unit testing</span></p><div class="entry-content"><p>I&#39;m presently reading Building Maintainable Software by Joost Visser and some of the maintenance guidelines they recommend include: A) each unit/method should be short (less than 15 lines per method) and B) methods should have a low <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" rel="nofollow noreferrer" title="Cyclomatic_complexity">cyclomatic complexity</a>. It suggests that both these guideline helps with testing.</p><p>The example below is from the book explaining how they would refactor a complex method to reduce the per method cyclomatic complexity.</p><p>Before:</p><pre><code>public static int calculateDepth(BinaryTreeNode&lt;Integer&gt; t, int n) {
    int depth = 0;
    if (t.getValue() == n) {
        return depth;
    } else {
        if (n &lt; t.getValue()) {
            BinaryTreeNode&lt;Integer&gt; left = t.getLeft();
            if (left == null) {
                throw new TreeException(&#34;Value not found in tree!&#34;);
            } else {
                return 1 + calculateDepth(left, n);
            }
        } else {
             BinaryTreeNode&lt;Integer&gt; right = t.getRight();
             if (right == null) {
                throw new TreeException(&#34;Value not found in tree!&#34;);
             } else {
                return 1 + calculateDepth(right, n);
             }
        }
    }
}
</code></pre><p>After:</p><pre><code>public static int calculateDepth(BinaryTreeNode&lt;Integer&gt; t, int n) {
     int depth = 0;
     if (t.getValue() == n)
        return depth;
     else
        return traverseByValue(t, n);
}
private static int traverseByValue(BinaryTreeNode&lt;Integer&gt; t, int n) {
     BinaryTreeNode&lt;Integer&gt; childNode = getChildNode(t, n);
     if (childNode == null) {
        throw new TreeException(&#34;Value not found in tree!&#34;);
     } else {
        return 1 + calculateDepth(childNode, n);
     }
}
private static BinaryTreeNode&lt;Integer&gt; getChildNode(
     BinaryTreeNode&lt;Integer&gt; t, int n) {
     if (n &lt; t.getValue()) {
        return t.getLeft();
     } else {
        return t.getRight();
     }
}
</code></pre><p>In their justification they state (emphasis mine):</p><p><strong>Argument:</strong></p><blockquote><p>“Replacing one method with McCabe 15 by three methods with McCabe 5<br /> each means that overall McCabe is still 15 (and therefore, there are<br /> 15 control ow branches overall). So nothing is gained.”</p></blockquote><p><strong>Counter Argument:</strong></p><blockquote><p>Of course, you will not decrease the overall McCabe complexity of a system by<br /> refactoring a method into several new methods. But from a<br /> maintainability perspective, there is an advantage to doing so: <strong>it<br /> will become easier to test</strong> and understand the code that was written.<br /> So, as we already mentioned, newly written unit tests allow you to<br /> more easily identify the root cause of your failing tests.</p></blockquote><p><strong>Question:</strong> How does it become easier to test?</p><p>According to the answers to <a href="https://stackoverflow.com/questions/5601730/should-private-protected-methods-be-under-unit-test">this</a> question, <a href="https://stackoverflow.com/questions/1583363/how-to-unit-test-private-methods-in-bdd-tdd">this</a> question, <a href="https://stackoverflow.com/questions/34571/how-to-test-a-class-that-has-private-methods-fields-or-inner-classes">this</a> question, <a href="https://stackoverflow.com/questions/7075938/making-a-private-method-public-to-unit-test-it-good-idea">this</a> question and <a href="http://devblog.x2k.co.uk/should-you-test-private-methods/" rel="nofollow noreferrer">this</a> blog we should not be testing private methods directly. Which means we need to test them via the public methods that use them. So going back to the example in the book, if we are testing the private methods via the public method, then how does the unit tests functionality improve, or change at all for that matter?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>After having written lots of test, I am strongly in favour of splitting up large methods, and of testing private methods. Splitting up functionality into smaller steps has two great advantages:</p><ol><li><p>By introducing a name for an operation, the code becomes more self-documenting.</p></li><li><p>By using smaller methods, the code is simpler and thus more likely correct. E.g. you can immediately understand <code>getChildNode()</code>.</p></li></ol><p>While the overall program cyclomatic complexity isn&#39;t reduced, these two advantages outweigh the bit of extra code in my book. There is a third advantage: the code becomes much easier to test, assuming we can get around the <code>private</code> access modifier.</p><p>People who advise against testing private implementation details make a good point: the test should show that the implementation adheres to it&#39;s public interface, but this can only be done by black-box tests of the public methods. Such tests don&#39;t require that you get 100% coverage, but missing coverage is an indication of dead code that&#39;s not required by the specification. Since TDD tests should define externally observable behaviour, such tests fall into this category.</p><p>But you can also use a different approach to testing: showing that an existing implementation is likely correct, and works as the programmer expected. Since we already have the code, we can design our tests to maximize coverage. We can use boundary values to meticulously exercise the behaviour of the program. In other words, we can write white-box tests that know about implementation details of the system under test. These tests are highly coupled to the implementation, but that is OK as long as you also have more general black-box tests.</p><p>As a result, I prefer a few black-box tests that walk through the “happy path” and basic guarantees of the interface. But it is way to cumbersome to exercise all possibilities: with each input parameter or state variable in the function, the test space increases exponentially! A function <code>f(bool)</code> might take two tests, a function <code>f(bool, bool)</code> 2²=4, and <code>f(bool, bool, bool, bool)</code> already 2<sup>4</sup>=16. This is untenable. But by splitting a large function into smaller functions, I only have to show that each smaller function works as expected, and that the functions work together correctly (I call this testing by induction). My workload now adds, instead of multiplying – a great improvement if you want to be thorough!</p><hr/><p>In your concrete example, either possibility is suboptimal because in the first try there&#39;s loads of code duplication requiring duplicate testing, and in the second try there are interdependencies between the functions that cannot be mocked away. Only <code>getChildNode()</code> is easy to test, but this function is incorrect if <code>n</code> is equal to <code>t.getValue()</code>, which will never happen if that function is only ever called by <code>traverseByValue()</code>. An easy to test alternative would be:</p><pre><code>public static int calculateDepth(BinaryTreeNode&lt;Integer&gt; t, int n) {
    if (t == null) {
        throw new TreeException(&#34;Value not found in tree!&#34;);
    }

    if (t.getValue() == n) {
        return 0;
    }

    BinaryTreeNode&lt;Integer&gt; child = null;
    if (n &lt; t.getValue()) {
        child = t.getLeft();
    } else {
        child = t.getRight();
    }

    return 1 + calculateDepth(child, n);
}
</code></pre><p>This specific case doesn&#39;t even use any helper functions, because it&#39;s simple enough to do without – there are only 4 paths through this code. Your previous implementation hid this by nesting conditionals when the other branch had already been terminated by a <code>throw</code> or <code>return</code>, and by unnecessary code duplication.</p><p>However, testing a recursion or loop can be difficult. While we could create a fairly complex tree and check for the correct result, we would like a way to check the loop invariant. In a language with higher-order functions, this might be:</p><pre><code>public static int calculateDepth(
        BinaryTreeNode&lt;Integer&gt; t,
        int n)
{
    return calculateDepthLoop(t, n, calculateDepthLoop);
}

type Recurser = int(BinaryTreeNode&lt;Integer&gt;, int, Recurser);

private static int calculateDepthLoop(
         BinaryTreeNode&lt;Integer&gt; t,
         int n,
         Recurser recurse)
{
    if (t == null) {
        throw new TreeException(&#34;Value not found in tree!&#34;);
    }

    if (t.getValue() == n) {
        return 0;
    }

    BinaryTreeNode&lt;Integer&gt; child = null;
    if (n &lt; t.getValue()) {
        child = t.getLeft();
    } else {
        child = t.getRight();
    }

    return 1 + recurse(child, n, recurse);
}
</code></pre><p>Now we could run a test plan like:</p><ul><li><code>calculateDepthLoop(null, ANY, ANY)</code> throws.</li><li><code>calculateDepthLoop(Tree(x, ANY, ANY), x, ANY) is</code>0`.</li><li><code>calculateDepthLoop(Tree(x, left, ANY), y, callback)</code> for <code>y &lt; x</code> invokes <code>result = callback(left, y, callback)</code> and returns the <code>result + 1</code>.</li><li><code>calculateDepthLoop(Tree(x, ANY, right), y, callback)</code> for <code>x &lt; y</code> invokes <code>result = callback(right, y, callback)</code> and returns the <code>result + 1</code>.</li></ul><p>with only 4 tests (one for each path) we can be sure that <code>calculateDepthLoop()</code> works as expected. We might want a couple more just to be sure that everything works for all valid values of <code>x</code> and <code>y</code>. Now we only need another test to check that everything integrates as it should, this can be done with a black-box test of <code>calculateDepth()</code>, which I&#39;d do by creating a moderately complex tree requiring the function to recurse both left and right and return some value.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-object-oriented-class-design/'>Java &#8211; Object-Oriented Class Design</a></li><li class="list-group-item"><a href='../unit-testing-unit-testing-methods-that-call-suppliers-webservices/'>Unit-testing &#8211; Unit testing methods that call suppliers webservices</a></li><li class="list-group-item"><a href='../unit-testing-how-to-not-test-implementation-when-method-returns-void/'>Unit-testing &#8211; How to not test implementation when method returns void</a></li><li class="list-group-item"><a href='../unit-testing-how-to-avoid-the-need-to-unit-test-private-methods/'>Unit-testing &#8211; How to avoid the need to Unit test private methods</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>