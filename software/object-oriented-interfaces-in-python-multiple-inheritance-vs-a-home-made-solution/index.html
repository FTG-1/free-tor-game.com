<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Interfaces in Python, multiple inheritance vs. a home-made solution &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1076782 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1076782" class="post-1076782 software type-software status-publish hentry category-software tag-composition tag-multiple-inheritance tag-object-oriented tag-python"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Interfaces in Python, multiple inheritance vs. a home-made solution</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">composition</span><span class="mr-2 badge badge-info">multiple-inheritance</span><span class="mr-2 badge badge-warning">object-oriented</span><span class="mr-2 badge badge-primary">python</span></p><div class="entry-content"><p>I am writing a <strong>Python framework</strong>. In order to ensure a class has some properties, I make base &#34;interface&#34; classes like:</p><pre><code>class BananaContainer:
    def __init__(self):
        self._bananas = []
    @property
    def bananas(self):
        return self._bananas
</code></pre><p>Then, if an object is supposed to be a container of bananas, I just<br /> derive it from <code>BananaContainer</code>.</p><p>A potential problem arise with objects being multiple containers. In my<br /> team we are asking ourselves whether multiple inheritance is the appropriate<br /> way to go or if some alternative solutions exist.</p><ul><li>is it correct to have an object inheriting both from <code>BananaContainer</code> and <code>AppleContainer</code> for example ?<ul><li>can it hit us back later with problems like method resolution order or name collisions ? (we can be careful not having similar properties like <code>.name</code> for example &#8211; we would like to limit those interfaces to the minimum required, nothing more)</li></ul></li></ul><p>An alternative implementation is proposed via &#34;capabilities&#34; based on composition instead of multiple inheritance. See below for an example of what is proposed:</p><pre><code>class BaseCapabilities:
    EXISTING_CAPABILITIES = {&#34;banana&#34;: BananaContainer, &#34;apple&#34;: AppleContainer, ...}

    def get_capability(self, name):
        if name in self.capabilities():
            return EXISTING_CAPABILITIES[name](self)
    def capabilities(self):
        # should return a list of capabilities
        raise NotImplementedError
</code></pre><p>Each object would have to derive from 1 class only, but then it needs to<br /> implement the capabilities machinery:</p><pre><code> class MyContainer(BaseCapabilities):
     def capabilities(self):
         return [&#34;banana&#34;, &#34;apple&#34;]
</code></pre><p>Then, within the framework it is possible to check if an object has a desired capability and to get an instance of the container class&#8230;<br /> This is to avoid multiple inheritance considered harmful.</p><p>My preferred choice would be to go for multiple inheritance and to use <code>isinstance(obj, BananaContainer)</code> for example to know if <code>obj</code> is a banana container. But I understand my colleague arguments too.</p><p>I would be very grateful to get some help to make a decision on this question.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Using Python&#39;s multiple inheritance (MI) for interfaces, abstract base classes, mixins, or similar techniques is perfectly fine. In most cases, the MRO produces intuitive results.</p><p>However, object initialization under multiple inheritance is really tricky. In Python you cannot combine multiple classes per MI unless all participating classes have been designed for MI. The issue is that the <code>__init__()</code> method cannot know from which class it will be called and what the signature of the <code>super().__init__()</code> method will be. Effectively, this means that MI constructors:</p><ul><li>must call the <code>super().__init__()</code></li><li>must only take arguments by name, not by position</li><li>must forward any <code>**kwargs</code> to the <code>super().__init__()</code></li><li>must not warn on unexpected arguments</li></ul><p>Where possible, the better alternative is to avoid <code>__init__()</code> methods for interface-like classes, and instead express requirements through abstract methods. For example, instead of a <code>BananaContainer</code> class, we might write this interface/ABC:</p><pre class="lang-py prettyprint-override"><code>import abc  # abstract base class

class BananaContainer(abc.ABC):
  @property
  @abc.abstractmethod
  def bananas(self) -&gt; list:
    raise NotImplementedError
</code></pre><p>If a class wants to be a BananaContainer, it would have to implement that property.</p><p>In general, it is perfectly alright if you have a class that inherits from multiple interfaces or mixins. Aside from name collisions, the above <code>__init__()</code> problems, and general API bloat of the class, no noteworthy issues arise.</p><hr/><p>The second part of your question proposes a capability-based approach instead of using inheritance. Using composition instead of inheritance is often a very very good idea. For example, you eliminate the initialization problems by design. It also tends to lead to more explicit APIs that are easier to navigate and avoid name clashes. There should be some method that either returns an object representing a capability, or <code>None</code> if the capability isn&#39;t supported.</p><p>But these capabilities can be implemented in different ways: either by using normal composition, or by storing the capabilities in your own data structures.</p><ul><li><p>Unless you have special needs for the object model, stick to the language. Store methods in normal object fields, provide normal methods to access them. This leads to a more comfortable API, and is more likely to support auto-completer and type-checkers.</p></li><li><p>If you need to modify the available capabilities of an object <em>at run-time</em>, and need to introduce new kinds of capabilities at run-time, then using a dictionary may be appropriate. But at this point you are inventing your own object system. This may be a good idea e.g. in games that have complex capability systems where new capabilities shall be defined in configuration files.</p><p>Most software does not have these requirements, and does not benefit from that kind of flexibility.</p><p>Additionally, Python&#39;s built-in object system is flexible enough that you could create new types and new methods without having to create a new object system. Builtins like <code>getattr()</code>, <code>setattr()</code>, <code>hasattr()</code>, and the <code>type()</code> constructor come in handy here.</p></li></ul><p>I would likely express an object that can have both AppleContainer and BananaContainer capabilities like this:</p><pre class="lang-py prettyprint-override"><code>class BananaContainer:
  ...

class AppleContainer:
  ...

class HasCapabilities:
  def __init__(self, x, y, z):
    # somehow determine the appropriate capabilities and initialize them
    self._banana_container = BananaContainer(y) if x else None
    self._apple_container = AppleContainer(y)

  @property
  def as_banana_container(self) -&gt; Optional[BananaContainer]:
    return self._banana_container

  @property
  def as_apple_container(self) -&gt; Optional[AppleContainer]:
    return self._apple_container

o = HasCapabilities(...)
bc = o.as_banana_container
if bc is not None:
  bc.do_banana_things()
</code></pre><p>Or with Python 3.8 assignment expressions:</p><pre class="lang-py prettyprint-override"><code>if (bc := o.as_banana_container) is not None:
  bc.do_banana_things()
</code></pre><p>If you want to have some custom mechanisms for reflection over capabilities, you can implement that on top of this solution, with some amount of boilerplate. If we want to be MI-safe, we might declare the following base class that all capability-having classes need to inherit:</p><pre class="lang-py prettyprint-override"><code>class CapabilityReflection:
  # a base implementations so that actual implementations
  # can safely call super()._get_capabilities()
  def _list_capabilities(self):
    return ()

  def all_capabilities(self):
    &#34;&#34;&#34;deduplicated set of capabilities that this object supports.&#34;&#34;&#34;
    set(self._list_capabilities())

  def get_capability(self, captype):
    &#34;&#34;&#34;find a capability by its type. Returns None if not supported.&#34;&#34;&#34;
    return None
</code></pre><p>which in the above case would have been implemented as:</p><pre class="lang-py prettyprint-override"><code>class HasCapabilities(CapabilityReflection):
  ...
  def _list_capabilities(self):
    caps = [  # go through properties in case they have been overridden
      self.as_banana_container,
      self.as_apple_container,
    ]
    yield from (cap for cap in caps if cap is not None)
    yield from super()._list_capabilities()

  def get_capability(self, captype):
    if captype == BananaContainer:
      return self.as_banana_container
    if captype == AppleContainer:
      return self.as_apple_container
    return super().get_capability(captype)
</code></pre></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../python-multiple-inheritance-or-decorators-for-composable-behaviours/'>Python multiple inheritance or decorators for composable behaviours</a></li><li class="list-group-item"><a href='../c-adding-base-class-inherited-functionality-to-classes-that-you-dont-control/'>C# &#8211; Adding base-class (inherited) functionality to classes that you don&#8217;t control</a></li><li class="list-group-item"><a href='../object-oriented-what-are-the-benefits-of-dependency-injection-in-cases-where-almost-everyone-needs-access-to-a-common-data-structure/'>Object-oriented &#8211; What are the benefits of dependency injection in cases where almost everyone needs access to a common data structure</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>