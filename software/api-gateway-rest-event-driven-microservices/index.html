<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>API Gateway (REST) + Event-Driven Microservices &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1069180 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1069180" class="post-1069180 software type-software status-publish hentry category-software tag-asynchronous-programming tag-event tag-microservices tag-spring"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">API Gateway (REST) + Event-Driven Microservices</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">asynchronous-programming</span><span class="mr-2 badge badge-info">event</span><span class="mr-2 badge badge-warning">microservices</span><span class="mr-2 badge badge-primary">spring</span></p><div class="entry-content"><p>I have a bunch of microservices whose functionality I expose through a REST API according to the API Gateway pattern. As these microservices are Spring Boot applications, I am using Spring AMQP to achieve RPC-style synchronous communication between these microservices. Things have been going smooth so far. However, the more I read about event-driven microservice architectures and look at projects such as Spring Cloud Stream the more convinced I become that I may be doing things the wrong way with the RPC, synchronous approach (particularly because I will need this to scale in order to respond to hundreds or thousands of requests per second from client applications).</p><p>I understand the point behind an event-driven architecture. What I don&#39;t quite understand is how to actually use such an pattern when sitting behind a model (REST) that expects a response to every request. For example, if I have my API gateway as a microservice and another microservice which stores and manages users, how could I model a thing such as a <code>GET /users/1</code> in a purely event-driven fashion?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Repeat after me:</p><blockquote><p><strong>REST and asynchronous events are not alternatives. They&#39;re completely orthogonal.</strong></p></blockquote><p>You can have one, or the other, or both, or neither. They&#39;re entirely different tools for entirely different problem domains. In fact, <strong>general purpose request-response communication is absolutely capable of being asynchronous, event-driven, and fault tolerant</strong>.</p><hr/><p>As a trivial example, the AMQP protocol sends messages over a TCP connection. In TCP, <em>every packet must be acknowledged by the receiver</em>. If a sender of a packet doesn&#39;t receive an ACK for that packet, it keeps resending that packet until it&#39;s ACK&#39;d or until the application layer &#34;gives up&#34; and abandons the connection. This is clearly a non-fault-tolerant request-response model because every &#34;packet send request&#34; <em>must</em> have an accompanying &#34;packet acknowledge response&#34;, and failure to respond results in the entire connection failing. Yet AMQP, a standardized and widely adopted protocol for asynchronous fault tolerant messaging, is communicated over TCP! What gives?</p><p>The core concept at play here is that scalable loosely-coupled fault-tolerant messaging is defined by <em>what messages you send</em>, not <em>how you send them</em>. In other words, <strong>loose coupling is defined at the application layer</strong>.</p><p>Let&#39;s look at two parties communicating either directly with RESTful HTTP or indirectly with an AMQP message broker. Suppose Party A wishes to upload a JPEG image to Party B who will sharpen, compress, or otherwise enhance the image. Party A doesn&#39;t need the processed image immediately, but does require a reference to it for future use and retrieval. Here&#39;s one way that might go in REST:</p><ul><li>Party A sends an HTTP <code>POST</code> request message to Party B with <code>Content-Type: image/jpeg</code></li><li>Party B processes the image (for a long time if it&#39;s large) while Party A waits, possibly doing other things</li><li>Party B sends an HTTP <code>201 Created</code> response message to Party A with a <code>Content-Location: &lt;url&gt;</code> header which links to the processed image</li><li>Party A considers its work done since it now has a reference to the processed image</li><li>Sometime in the future when Party A needs the processed image, it
GETs it using the link from the earlier <code>Content-Location</code> header</li></ul><p>The <code>201 Created</code> response code tells a client that not only was their request successful, it also created a new resource. In a 201 response, the <code>Content-Location</code> header is a link to the created resource. This is specified in RFC 7231 Sections 6.3.2 and 3.1.4.2.</p><p>Now, lets see how this interaction works over a hypothetical RPC protocol on top of AMQP:</p><ul><li>Party A sends an AMQP message broker (call it Messenger) a message containing the image and instructions to route it to Party B for processing, then respond to Party A with an address of some sort for the image</li><li>Party A waits, possibly doing other things</li><li>Messenger sends Party A&#39;s original message to Party B</li><li>Party B processes the message</li><li>Party B sends Messenger a message containing an address for the processed image and instructions to route that message to Party A</li><li>Messenger sends Party A the message from Party B containing the processed image address</li><li>Party A considers its work done since it now has a reference to the processed image</li><li>Sometime in the future when Party A needs the image, it retrieves the image using the address (possibly by sending messages to some other party)</li></ul><p>Do you see the problem here? In both cases, <strong>Party A can&#39;t get an image address until <em>after</em> Party B processes the image</strong>. Yet Party A doesn&#39;t need the image right away and, by all rights, couldn&#39;t care less if processing is finished yet!</p><p>We can fix this pretty easily in the AMQP case by having Party B tell A that B <em>accepted</em> the image for processing, giving A an address for where the image <em>will be</em> after processing completes. Then Party B can send A a message sometime in the future indicating the image processing is finished. AMQP messaging to the rescue!</p><p>Except guess what: <strong>you can achieve the same thing with REST</strong>. In the AMQP example we changed a &#34;here&#39;s the processed image&#34; message to a &#34;the image is processing, you can get it later&#34; message. To do that in RESTful HTTP, we&#39;ll use the <code>202 Accepted</code> code and <code>Content-Location</code> again:</p><ul><li>Party A sends an HTTP <code>POST</code> message to Party B with <code>Content-Type: image/jpeg</code></li><li>Party B immediately sends back a <code>202 Accepted</code> response which contains some sort of &#34;asynchronous operation&#34; content which describes whether processing is finished and where the image will be available when it&#39;s done processing. Also included is a <code>Content-Location: &lt;link&gt;</code> header which, in a <code>202 Accepted</code> response, is a link to the resource represented by whatever the response body is. In this case, that means it&#39;s a link to our asynchronous operation!</li><li><strong>Party A considers its work done since it now has a reference to the processed image</strong></li><li>Sometime in the future when Party A needs the processed image, it first GETs <em>the async operation resource</em> linked to in the <code>Content-Location</code> header to determine if processing is finished. If so, Party A then uses the link in the async operation itself to GET the processed image.</li></ul><p>The only difference here is that in the AMQP model, Party B tells Party A when the image processing is done. But in the REST model, Party A checks if processing is done just before it actually needs the image. <strong>These approaches are equivalently scalable</strong>. As the system gets larger, the number of messages sent in both the async AMQP and the async REST strategies increase with equivalent asymptotic complexity. The only difference is the client is sending an extra message instead of the server.</p><p>But the REST approach has a few more tricks up its sleeve: <strong>dynamic discovery and protocol negotiation</strong>. Consider how both the sync and async REST interactions started. Party A sent <em>the exact same request</em> to Party B, with the only difference being the particular kind of success message that Party B responded with. What if Party A wanted to <em>choose</em> whether image processing was synchronous or asynchronous? What if Party A doesn&#39;t know if Party B is even capable of async processing?</p><p>Well, HTTP actually has a standardized protocol for this already! It&#39;s called HTTP Preferences, specifically the <code>respond-async</code> preference of RFC 7240 Section 4.1. If Party A desires an asynchronous response, it includes a <code>Prefer: respond-async</code> header with its initial POST request. If Party B decides to honor this request, it sends back a <code>202 Accepted</code> response that includes a <code>Preference-Applied: respond-async</code>. Otherwise, Party B simply ignores the <code>Prefer</code> header and sends back <code>201 Created</code> as it normally would.</p><p>This allows Party A to <em>negotiate</em> with the server, dynamically adapting to whatever image processing implementation it happens to be talking to. Furthermore, the use of explicit links means Party A doesn&#39;t have to know about any parties other than B: no AMQP message broker, no mysterious Party C that knows how to actually turn the image address into image data, no second B-Async party if both synchronous and asynchronous requests need to be made, etc. It simply describes what it needs, what it would optionally like, and then reacts to status codes, response content, and links. Add in <code>Cache-Control</code> headers for explicit instructions on when to keep local copies of data, and now servers can negotiate with clients which resources clients may keep local (or even offline!) copies of. This is how you build loosely-coupled fault-tolerant microservices in REST.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-is-it-a-good-idea-to-use-a-spring-mvc-as-an-frontend-of-a-microservice-architecture/'>Java &#8211; Is it a good idea to use a Spring MVC as an Frontend of a Microservice Architecture</a></li><li class="list-group-item"><a href='../design-event-driven-microservice-architecture-dealing-with-synchronous-external-neighboring-systems/'>Design &#8211; Event Driven Microservice Architecture &#038; Dealing with synchronous external neighboring systems</a></li><li class="list-group-item"><a href='../how-to-update-a-nosql-database-and-publish-event-atomically-in-an-event-driven-microservices-architecture/'>How to update a NoSQL database and publish event atomically in an event-driven microservices architecture</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>