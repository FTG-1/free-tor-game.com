<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Many Blocking VS Single Non-Blocking Workers &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1069744 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1069744" class="post-1069744 software type-software status-publish hentry category-software tag-multithreading tag-server"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Many Blocking VS Single Non-Blocking Workers</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">multithreading</span><span class="mr-2 badge badge-info">server</span></p><div class="entry-content"><p>Assume there is an HTTP server which accepts connections and then it has <em>somehow</em> wait for headers to be fully sent in. I wonder what is the most common way of implementing it and what are the rest pros and cons. I can only think of these:</p><p><strong>Many blocking workers are good because:</strong></p><ul><li>It is more responsive.</li><li>Easier to introduce new connections (workers pick them up them selves rather than outsider waiting till it can add it to a synchronized list).</li><li>CPU usage balances automatically (without any additional effort) as number of connections increases and decreases.</li><li>Less CPU usage (blocked threads are taken out of the execution loop and do not require any logic for jumping between clients).</li></ul><p><strong>Single non-blocking worker is good because:</strong></p><ul><li>Uses less memory.</li><li>Less vulnerable to lazy clients (which connect to the server and send headers slowly or don&#39;t send at all).</li></ul><p>As you probably can see, in my opinion multiple worker-threads seem a bit better solution overall. The only problem with it is that it is easier to attack such server.</p><p><strong>Edit (more research):</strong><br /> Some resource I found on the web (<a href="https://www.google.lt/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=8&amp;ved=0CGIQFjAH&amp;url=http://www.mailinator.com/tymaPaulMultithreaded.pdf&amp;ei=DsflUMOFL8bKswati4HgDg&amp;usg=AFQjCNG3bimZQfd0spInW89SVD-rriUUSQ&amp;bvm=bv.1355534169,d.Yms&amp;cad=rja" rel="noreferrer">Thousands of Threads and Blocking I/O<br /> &#8211; The old way to write Java Servers is New again (and way better)</a> by Paul Tyma) hints that blocking approach is generally better but I still don&#39;t really know how to deal with fake connections.</p><p>P.S. Do not suggest using some library or applications for the task. I am more interested in knowing how it actually works or may work rather than have it working.</p><p>P.S.S. I have split logic into multiple parts and this one only handles accepting HTTP headers. Does not process them.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p><strong>There&#39;s no silver bullet</strong></p><p>In practice it depends...</p><p><em>tl;dr - easy solution, use nginx...</em></p><p><strong>Blocking:</strong></p><p>For instance, Apache by default uses a blocking scheme where the process is forked for every connection. That means every connection needs its own memory space and the sheer amount of context-switching overhead increases more as the number of connections increases. But the benefit is, once a connection is closed the context can be disposed and any/all memory can be easily retrieved.</p><p>A multi-threaded approach would be similar in that the overhead of context switching increases with the number of connections but may be more memory efficient in a shared context. The problem with such an approach is it&#39;s difficult to manage shared memory in a manner that&#39;s safe. The approaches to overcome memory synchronization problems often include their own overhead, for instance locking may freeze the main thread on CPU-intensive loads, and using immutable types adds a lot of unnecessary copying of data.</p><p>AFAIK, using a multi-process approach on a blocking HTTP server is generally preferred because it&#39;s safer/simpler to manage/recovery memory in a manner that&#39;s safe. Garbage collection becomes a non-issue when recovering memory is as simple as stopping a process. For long-running processes (ie a daemon) that characteristic is especially important.</p><p>While context-switching overhead may seem insignificant with a small number of workers, the disadvantages become more relevant as the load scales up to hundreds-to-thousands of concurrent connections. At best, context switching scales O(n) to the number of workers present but in practice it&#39;s most-likely worse.</p><p>Where servers that use blocking may not be the ideal choice for IO heavy loads, they are ideal for CPU-intensive work and message passing is kept to a minumum.</p><p><strong>Non-Blocking:</strong></p><p>Non-blocking would be something like Node.js or nginx. These are especially known for scaling to a much larger number of connections per node under IO-intensive load. Basically, once people hit the upper limit of what thread/process-based servers could handle they started to explore alternative options. This is otherwise known as the <a href="http://en.wikipedia.org/wiki/C10k_problem" rel="nofollow">C10K problem</a> (ie the ability to handle 10,000 concurrent connections).</p><p>Non-blocking async servers generally shares a lot of characteristics with a multi-threaded-with-locking approach in that you have to be careful to avoid CPU-intensive loads because you don&#39;t want to overload the main thread. The advantage is that the overhead incurred by context switching is essentially eliminated and with only one context message passing becomes a non-issue.</p><p>While it may not work for many networking protocols, HTTPs stateless nature works especially well for non-blocking architectures. By using the combination of a reverse-proxy and multiple non-blocking HTTP servers it&#39;s possible to identify and route around the nodes experiencing heavy load.</p><p>Even on a server that only has one node, it&#39;s very common for the setup to include one server per processor core to maximize throughput.</p><p><strong>Both:</strong></p><p>The &#39;ideal&#39; use case would be a combination of both. A reverse proxy at the front dedicated to routing requests at the top, then a mix of blocking and non-blocking servers. Non-blocking for IO tasks like serving static content, cache content, html content. Blocking for CPU-heavy tasks like encoding images/video, streaming content, number crunching, database writes, etc.</p><p><strong>In your case:</strong></p><p>If you&#39;re just checking headers but not actually processing the requests, what you&#39;re essentially describing is a reverse proxy. In such a case I&#39;d definitely go with an async approach.</p><p>I&#39;d suggest checking out the documentation for the <a href="http://blog.peacon.co.uk/wiki/NginX_Reverse_Proxy_Configuration" rel="nofollow">nginx built-in reverse proxy</a>.</p><p><em>Aside:</em></p><p>I read the write-up from the link you provided and it makes sense that async was a poor choice for their particular implementation. The issue can be summed up in one statement.</p><blockquote><p>Found that when switching between clients, the code for saving and restoring values/state was difficult</p></blockquote><p>They were building a state-ful platform. In such a case, an async approach would mean that you&#39;d have to constantly save/load the state every time the context switches (ie when an event fires). In addition, on the SMTP side they&#39;re doing a lot of CPU-intensive work.</p><p>It sounds like they had a pretty poor grasp of async and, as a result, made a lot of bad assumptions.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../does-node-js-actually-increase-scalability/'>Does Node.js actually increase scalability</a></li><li class="list-group-item"><a href='../java-high-load-java-server-for-multiplayer/'>Java &#8211; High-Load Java Server for Multiplayer</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>