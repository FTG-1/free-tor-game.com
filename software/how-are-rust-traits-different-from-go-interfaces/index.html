<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>How are Rust Traits different from Go Interfaces &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1065598 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1065598" class="post-1065598 software type-software status-publish hentry category-software tag-go tag-rust"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">How are Rust Traits different from Go Interfaces</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">go</span><span class="mr-2 badge badge-info">rust</span></p><div class="entry-content"><p>I am relatively familiar with Go, having written a number of small programs in it. Rust, of course, I am less familiar with but keeping an eye on.</p><p>Having recently read <a href="http://yager.io/programming/go.html">http://yager.io/programming/go.html</a>, I thought I&#39;d personally examine the two ways Generics are handled because the article seemed to unfairly criticize Go when, in practice, there wasn&#39;t much that Interfaces couldn&#39;t accomplish elegantly. I kept hearing the hype about how powerful Rust&#39;s Traits were and nothing but criticism from people about Go. Having some experience in Go, I wondered how true it was and what the differences ultimately were. What I found was that Traits and Interfaces are pretty similar! Ultimately, I&#39;m not sure if I&#39;m missing something, so here is a quick educational rundown of their similarities so you can tell me what I missed!</p><p>Now, let&#39;s take a look at Go Interfaces from their <a href="http://golang.org/doc/effective_go.html#interfaces">documentation</a>:</p><blockquote><p>Interfaces in Go provide a way to specify the behavior of an object: if something can do this, then it can be used here.</p></blockquote><p>By far the most common interface is <code>Stringer</code> which returns a string representing the object.</p><pre><code>type Stringer interface {
    String() string
}
</code></pre><p>So, any object that has <code>String()</code> defined on it is a <code>Stringer</code> object. This can be used in type signatures such that <code>func (s Stringer) print()</code> takes almost all objects and prints them.</p><p>We also have <code>interface{}</code> which takes any object. We must then determine the type at runtime through reflection.</p><hr/><p>Now, let&#39;s take a look at Rust Traits from their <a href="http://doc.rust-lang.org/tutorial.html#traits">documentation</a>:</p><blockquote><p>At its simplest, a trait is a set of zero or more method signatures. For example, we could declare the trait Printable for things that can be printed to the console, with a single method signature:</p></blockquote><pre><code>trait Printable {
    fn print(&amp;self);
}
</code></pre><p>This immediately looks quite similar to our Go Interfaces. The only difference I see is that we define &#39;Implementations&#39; of Traits rather than just defining the methods. So, we do</p><pre><code>impl Printable for int {
    fn print(&amp;self) { println!(&#34;{}&#34;, *self) }
}
</code></pre><p>instead of</p><pre><code>fn print(a: int) { ... }
</code></pre><p><strong>Bonus Question:</strong> What happens in Rust if you define a function that implements a trait but you don&#39;t use <code>impl</code>? It just doesn&#39;t work?</p><p>Unlike Go&#39;s Interfaces, Rust&#39;s type system has type parameters which let you do proper generics and things like <code>interface{}</code> while the compiler and the runtime actually know the type. For example,</p><pre><code>trait Seq&lt;T&gt; {
    fn length(&amp;self) -&gt; uint;
}
</code></pre><p>works on any type and the compiler <em>knows</em> that the type of the Sequence elements at compile time rather than using reflection.</p><hr/><p>Now, the actual question: am I missing any differences here? Are they really <em>that</em> similar? Is there not some more fundamental difference that I&#39;m missing here? (In usage. Implementation details are interesting, but ultimately not important if they function the same.)</p><p>Besides syntactic differences, the actual differences I see are:</p><ol><li>Go has automatic method dispatch vs. Rust requires(?) <code>impl</code>s to implement a Trait<ul><li>Elegant vs. Explicit</li></ul></li><li>Rust has type parameters which allow for proper generics without reflection.<ul><li>Go really has no response here. This is the only thing that is significantly more powerful and it&#39;s ultimately just a replacement for copying and pasting methods with different type signatures.</li></ul></li></ol><p>Are these the only non-trivial differences? If so, it would appear Go&#39;s Interface/Type system is, in practice, not as weak as perceived.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>What happens in Rust if you define a function that implements a trait but you don&#39;t use impl? It just doesn&#39;t work?</p></blockquote><p>You need to explicitly implement the trait; happening to have a method with matching name/signature is meaningless for Rust.</p><h1>Generic call dispatching</h1><blockquote><p>Are these the only non-trivial differences? If so, it would appear Go&#39;s Interface/Type system is, in practice, not as weak as perceived.</p></blockquote><p>Not providing static dispatch can be a significant performance hit for certain cases (e.g. the <code>Iterator</code> one I mention below). I think this is what you mean by</p><blockquote><p>Go really has no response here. This is the only thing that is significantly more powerful and it&#39;s ultimately just a replacement for copying and pasting methods with different type signatures.</p></blockquote><p>but I&#39;ll cover it in more detail, because it&#39;s worth understanding the difference deeply.</p><h2>In Rust</h2><p>Rust&#39;s approach allows for the user to choose between static dispatch and <a href="http://en.wikipedia.org/wiki/Dynamic_dispatch" rel="noreferrer">dynamic dispatch</a>. As an example,  if you have</p><pre class="lang-rust prettyprint-override"><code>trait Foo { fn bar(&amp;self); }

impl Foo for int { fn bar(&amp;self) {} }
impl Foo for String { fn bar(&amp;self) {} }

fn call_bar&lt;T: Foo&gt;(value: T) { value.bar() }

fn main() {
    call_bar(1i);
    call_bar(&#34;foo&#34;.to_string());
}
</code></pre><p>then the two <code>call_bar</code> calls above will compile to calls to, respectively,</p><pre class="lang-rust prettyprint-override"><code>fn call_bar_int(value: int) { value.bar() }
fn call_bar_string(value: String) { value.bar() }
</code></pre><p>where those <code>.bar()</code> method calls are static function calls, i.e. to a fixed function address in memory. This allows for optimisations like inlining, because the compiler knows <em>exactly</em> which function is being called. (This is what C++ does too, sometimes called &#34;monomorphisation&#34;.)</p><h2>In Go</h2><p>Go only allows dynamic dispatch for &#34;generic&#34; functions, that is, the method address is loaded from the value and then called from there, so the exact function is only known at runtime. Using the example above</p><pre class="lang-golang prettyprint-override"><code>type Foo interface { bar() }

func call_bar(value Foo) { value.bar() }

type X int;
type Y string;
func (X) bar() {}
func (Y) bar() {}

func main() {
    call_bar(X(1))
    call_bar(Y(&#34;foo&#34;))
}
</code></pre><p>Now, those two <code>call_bar</code>s will always be calling the above <code>call_bar</code>, with the address of <code>bar</code> loaded from the interface&#39;s <a href="http://en.wikipedia.org/wiki/Virtual_method_table" rel="noreferrer">vtable</a>.</p><h2>Low-level</h2><p>To rephrase the above, in C notation. Rust&#39;s version creates</p><pre class="lang-rust prettyprint-override"><code>/* &#34;implementing&#34; the trait */
void bar_int(...) { ... }
void bar_string(...) { ... }

/* the monomorphised `call_bar` function */
void call_bar_int(int value) {
    bar_int(value);
}
void call_bar_string(string value) {
    bar_string(value);
}

int main() {
    call_bar_int(1);
    call_bar_string(&#34;foo&#34;);
    // pretend that is the (hypothetical) `string` type, not a `char*`
    return 1;
}
</code></pre><p>For Go, it&#39;s something more like:</p><pre class="lang-golang prettyprint-override"><code>/* implementing the interface */
void bar_int(...) { ... }
void bar_string(...) { ... }

// the Foo interface type
struct Foo {
    void* data;
    struct FooVTable* vtable;
}
struct FooVTable {
    void (*bar)(void*);
}

void call_bar(struct Foo value) {
    value.vtable.bar(value.data);
}

static struct FooVTable int_vtable = { bar_int };
static struct FooVTable string_vtable = { bar_string };

int main() {
    int* i = malloc(sizeof *i);
    *i = 1;
    struct Foo int_data = { i, &amp;int_vtable };
    call_bar(int_data);

    string* s = malloc(sizeof *s);
    *s = &#34;foo&#34;; // again, pretend the types work
    struct Foo string_data = { s, &amp;string_vtable };
    call_bar(string_data);
}
</code></pre><p>(This isn&#39;t exactly right---there has to be more information in the vtable---but the method call being a dynamic function pointer is the relevant thing here.)</p><h2>Rust offers the choice</h2><p>Going back to</p><blockquote><p>Rust&#39;s approach allows for the user to choose between static dispatch and dynamic dispatch.</p></blockquote><p>So far I&#39;ve only demonstrated Rust having statically dispatched generics, but Rust can opt-in to the dynamic ones like Go (with essentially the same implementation), via trait objects. Notated like <code>&amp;Foo</code>, which is a borrowed reference to an unknown type that implements the <code>Foo</code> trait. These values have the same/very similar vtable representation to the Go interface object. (A trait object is an example of an <a href="http://www.haskell.org/haskellwiki/Existential_type" rel="noreferrer">&#34;existential type&#34;</a>.)</p><p>There are instances where dynamic dispatch is really helpful (and sometimes more performant, by, e.g. reducing code bloat/duplication), but static dispatch allows compilers to inline the callsites and apply all their optimisations, meaning it is normally faster. This is especially important for things like <a href="http://doc.rust-lang.org/master/std/iter/trait.Iterator.html" rel="noreferrer">Rust&#39;s iteration protocol</a>, where static dispatching trait method calls allows for those iterators to be as fast as the C equivalents, while still <a href="http://huonw.github.io/blog/2014/06/error-handling-in-rust-knn-case-study/" rel="noreferrer">seeming high-level and expressive</a>.</p><p>Tl;dr: Rust&#39;s approach offers both static and dynamic dispatch in generics, at the programmers discretion; Go only allows for dynamic dispatch.</p><h1>Parametric polymorphism</h1><p>Furthermore, emphasising traits and deemphasising reflection gives Rust much stronger <a href="http://en.wikipedia.org/wiki/Parametric_polymorphism" rel="noreferrer">parametric polymorphism</a>: the programmer knows exactly what a function can do with its arguments, because it has to declare the traits the generic types implement in the function signature.</p><p>Go&#39;s approach is very flexible, but has fewer guarantees for the callers (making it somewhat harder for the programmer to reason about), because the internals of a function can (and do) query for additional type information (there was a bug in the Go standard library where, iirc, a function taking a writer would use reflection to call <code>Flush</code> on some inputs, but not others).</p><h1>Building abstractions</h1><p>This is somewhat of a sore point, so I&#39;ll only talk briefly, but having &#34;proper&#34; generics like Rust has allows for low level data types like Go&#39;s <code>map</code> and <code>[]</code> to actually be implemented directly in the standard library in a strongly typesafe way, and written in Rust (<a href="http://doc.rust-lang.org/master/std/collections/hashmap/struct.HashMap.html" rel="noreferrer"><code>HashMap</code></a> and <a href="http://doc.rust-lang.org/master/std/vec/struct.Vec.html" rel="noreferrer"><code>Vec</code></a> respectively).</p><p>And its not just those types, you can build type-safe generic structures on top of them, e.g. <a href="http://doc.rust-lang.org/master/std/collections/lru_cache/struct.LruCache.html" rel="noreferrer"><code>LruCache</code></a> is a generic caching layer on top of a hashmap. This means people can just use the data structures directly from the standard library, <em>without</em> having to store data as <code>interface{}</code> and use type assertions when inserting/extracting. That is, if you have an <code>LruCache&lt;int, String&gt;</code>, you&#39;re guaranteed that the keys are always <code>int</code>s and the values are always <code>String</code>s: there&#39;s no way to accidentally insert the wrong value (or try to extract a non-<code>String</code>).</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-how-does-go-improve-productivity-with-implicit-interfaces-and-how-does-that-compare-with-cs-notion-of-extension-methods/'>C# &#8211; How does Go improve productivity with &#8220;implicit&#8221; interfaces, and how does that compare with C#&#8217;s notion of Extension Methods</a></li><li class="list-group-item"><a href='../c-how-does-rust-diverge-from-the-concurrency-facilities-of-c/'>C++ &#8211; How does Rust diverge from the concurrency facilities of C++</a></li><li class="list-group-item"><a href='../design-golang-interface-design-for-multiple-parameter-and-return-types/'>Design &#8211; Golang Interface Design for Multiple Parameter and Return Types</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>