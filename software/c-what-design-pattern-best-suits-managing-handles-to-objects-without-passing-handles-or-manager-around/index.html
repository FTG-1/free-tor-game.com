<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C++ &#8211; What design pattern best suits managing handles to objects, without passing handles or Manager around &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1076592 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1076592" class="post-1076592 software type-software status-publish hentry category-software tag-c tag-design-patterns tag-game-development tag-opengl"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C++ &#8211; What design pattern best suits managing handles to objects, without passing handles or Manager around</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">design-patterns</span><span class="mr-2 badge badge-warning">game development</span><span class="mr-2 badge badge-primary">opengl</span></p><div class="entry-content"><p>I&#39;m writing a game in C++ using OpenGL.</p><p>For those that don&#39;t know, with the OpenGL API you make a lot of calls to things like <code>glGenBuffers</code> and <code>glCreateShader</code> etc. These return types of <code>GLuint</code> which are unique identifiers to what you just created. The thing being created lives on the GPU memory.</p><p>Considering that GPU Memory is sometimes limited, you don&#39;t want to create two things that are the same when they&#39;re to be used by multiple objects.</p><p>For example, Shaders. You link a Shader Program and then you have a <code>GLuint</code>. When you&#39;re done with the Shader, you should call <code>glDeleteShader</code> (or something to that affect).</p><p>Now, let&#39;s say I have a shallow class hierarchy like:</p><pre><code>class WorldEntity
{
public:
    /* ... */
protected:
    ShaderProgram* shader;
    /* ... */
};

class CarEntity : public WorldEntity 
{
    /* ... */
};

class PersonEntity: public WorldEntity
{
    /* ... */
};
</code></pre><p>Any code I&#39;ve ever seen would require that all the Constructors have a <code>ShaderProgram*</code> passed to it to be stored in the <code>WorldEntity</code>. <code>ShaderProgram</code> is my class that encapsulates the binding of a <code>GLuint</code> to the current shader state in the OpenGL context as well as a few other helpful things that you need to do with Shaders.</p><p>The problem I have with this is:</p><ul><li>There&#39;s a lot of parameters needed to construct a <code>WorldEntity</code> (consider that there might be a mesh, a shader, a bunch of textures etc, all of which could be shared, so they&#39;re passed as pointers)</li><li>Whatever is creating the <code>WorldEntity</code> needs to know what <code>ShaderProgram</code> it needs</li><li>This probably requires some sort of <em>gulp</em> <code>EntityManager</code> class that knows what instance of what <code>ShaderProgram</code> to pass to different entities.</li></ul><p>So now because there&#39;s a <code>Manager</code> the classes need to either register themselves with the <code>EntityManager</code> along with the <code>ShaderProgram</code> instance they need, or I need a big-ass <code>switch</code> in the manager that I need to update for every new <code>WorldEntity</code> derived type.</p><p>My first thought was to create a <code>ShaderManager</code> class (I know, Managers are bad) that I pass by reference or pointer to the <code>WorldEntity</code> classes so that they can create whatever <code>ShaderProgram</code> they want, via the <code>ShaderManager</code> and the <code>ShaderManager</code> can keep track of already existing <code>ShaderProgram</code>s, so it can return one that already exists or create a new one if needed.</p><p>(I could store the <code>ShaderProgram</code>s via the hash of the filenames of the <code>ShaderProgram</code>s actual source code)</p><p>So now:</p><ul><li>I&#39;m now passing pointers to <code>ShaderManager</code> instead of <code>ShaderProgram</code>, so there&#39;s still a lot of parameters</li><li>I don&#39;t need an <code>EntityManager</code>, the entities themselves will know what instance of <code>ShaderProgram</code> to create, and <code>ShaderManager</code> will handle the actual <code>ShaderProgram</code>s.</li><li>But now I don&#39;t know when <code>ShaderManager</code> can safely delete a <code>ShaderProgram</code> that it holds.</li></ul><p>SO now I&#39;ve added reference counting to my <code>ShaderProgram</code> class that deletes its internal <code>GLuint</code> via <code>glDeleteProgram</code> and I do away with <code>ShaderManager</code>.</p><p>So now:</p><ul><li>An object can create whatever <code>ShaderProgram</code> it needs</li><li>But now there&#39;s duplicate <code>ShaderProgram</code>s because there&#39;s no external Manager keeping track</li></ul><p>Finally I come to make one of two decisions:</p><h2>1. Static Class</h2><p>A <code>static class</code> that&#39;s invoked to create <code>ShaderProgram</code>s. It keeps an internal track of <code>ShaderProgram</code>s based on a hash of the filenames<br /> &#8211; this means I no longer need to pass pointers or references to <code>ShaderProgram</code>s or <code>ShaderManager</code>s around, so less parameters<br /> &#8211; The <code>WorldEntities</code> have all knowledge about the instance of <code>ShaderProgram</code> they want to create</p><p>This new <code>static ShaderManager</code> needs to:</p><ul><li>keep a count of the number of times a <code>ShaderProgram</code> is used and I make <code>ShaderProgram</code> no copyable OR</li><li><code>ShaderProgram</code>s count their references and only call <code>glDeleteProgram</code> in their destructor when the count is <code>0</code> AND <code>ShaderManager</code> periodically checks for <code>ShaderProgram</code>&#39;s with a count of 1 and discards them.</li></ul><p>The downsides to this approach I see are:</p><ol><li><p>I have global static class which might be a problem. The OpenGL Context needs to be created prior to the invoking any <code>glX</code> functions. So potentially, a <code>WorldEntity</code> might be created and try to create a <code>ShaderProgram</code> prior to OpenGL Context creation, which will result in a crash.</p><p>The only way around this is back to passing everything around as pointers/references, or having a global GLContext class that can be queried, or holding everything in a class that creates the Context on construction. Or maybe just a global boolean <code>IsContextCreated</code> that can be checked. But I worry that this gives me ugly code everywhere.</p><p>What I can see the devolving to is:</p><ul><li>The big <code>Engine</code> class that has every other class hidden inside of it so that it can control the construction/deconstruction order appropriately. This seems like a big mess of interface code between the user of the engine and the engine, like a wrapper over a wrapper</li><li>A whole slew of &#34;Manager&#34; classes that keep track of instances and delete things when neccessary. This might be a necessary evil?</li></ul></li></ol><p>AND</p><ol start="2"><li>When to actually clear <code>ShaderProgram</code>s out of the <code>static ShaderManager</code>? Every few minutes? Every Game Loop? I&#39;m gracefully handling the re-compiling of a shader in the case when a <code>ShaderProgram</code> was deleted but then a new <code>WorldEntity</code> requests it; but I&#39;m sure there&#39;s a better way.</li></ol><h2>2. A better method</h2><p>That&#39;s what I&#39;m asking for here</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><blockquote><ol start="2"><li>A better method
 That&#39;s what I&#39;m asking for here</li></ol></blockquote></blockquote><p>Apologies for necromancy but I&#39;ve seen so many stumbling over similar issues with managing OpenGL resources, including me in the past. And so much of the difficulties I struggled with which I recognize in others came from the temptation to wrap and sometimes abstract and even encapsulate the OGL resources needed for some analogical game entity to be rendered.</p><p>And the &#34;better way&#34; I found (at least one which ended my particular struggles there) was do things sort of the other way around. That is to say, don&#39;t concern yourself with the low-level aspects of OGL in designing your game entities and components and move away from ideas like that your <code>Model</code> has to store like a triangle and vertex primitives in the form of objects wrapping or even abstracting VBOs.</p><p><strong>Rendering Concerns vs. Game Design Concerns</strong></p><p>There are slightly higher-level concepts than GPU textures, for examples, with simpler management requirements like CPU images (and you need those anyway, at least temporarily, before you can even create and bind a GPU texture). Absent rendering concerns a model might suffice just storing a property indicating the filename to use for the file containing the data for the model. You can have a &#34;material&#34; component which is higher-level and more abstract and describes the properties of that material than a GLSL shader.</p><p>And then there is only one place in the codebase concerned with things like shaders and GPU textures and VAOs/VBOs and OpenGL contexts, and that&#39;s the implementation of the <em>rendering system</em>. The rendering system might loop through the entities in the game scene (in my case it goes through a spatial index, but you can understand more easily and start off with a simple loop before implementing optimizations like frustum culling with a spatial index), and it discovers your high-level components like &#34;materials&#34; and &#34;images&#34; and model filenames.</p><p>And its job is to take that higher-level data which isn&#39;t directly concerned with GPU and load/create/associate/bind/use/deassociate/destroy the necessary OpenGL resources based on what it discovers in the scene and what&#39;s happening to the scene. And that eliminates the temptation to use things like singletons and static versions of &#34;managers&#34; and what not, because now all your OGL resource management is centralized to one system/object in your codebase (though of course you might decompose it into further objects encapsulated by the renderer to make the code more manageable). It also naturally avoids some tripping points with things like trying to destroy resources outside of a valid OGL context, since all this stuff is now (including the destruction of resources) occurring inside the rendering system which is always in a valid GL context when invoked in the pipeline.</p><p><strong>Avoiding Design Changes</strong></p><p>Further that offers a lot of breathing room to avoid costly central design changes, because say you discover in hindsight that some materials require multiple rendering passes (and multiple shaders) to render, like a subsurface scattering pass and shader for skin materials, whereas previously you wanted to sort of conflate a material with a single GPU shader. In that case there&#39;s no costly design change to central interfaces used by many things. All you do is update the local implementation of the rendering system to handle this formerly unanticipated case when it encounters skin properties in your higher-level material component.</p><p><strong>The Overall Strategy</strong></p><p>And that&#39;s the overall strategy I use now, and it especially becomes increasingly helpful the more complex your rendering concerns are. As a downside it does require a bit more upfront work than like injecting your game entities with shaders and VBOs and things like that, and it also couples your renderer more to your particular game engine (or its abstractions, though in exchange the higher-level game entities and concepts become completely decoupled from low-level rendering concerns). And your renderer might need things like callbacks to notify it when entities are destroyed so that it can deassociate and destroy any data it associates to it (you might use ref-counting here or <code>shared_ptr</code> for shared resources, but just locally inside the renderer). And you might want some efficient way to associate and deassociate all kinds of rendering data to whatever entities in constant-time (an ECS tends to provide this off the bat to every system with how you can associate new component types on the fly if you have an ECS -- if not it shouldn&#39;t be too difficult either way)... but on the upside all these kinds of things will likely be useful to systems other than the renderer anyway.</p><p>Admittedly the real implementation gets a lot more nuanced than this and might blur these things a bit more, like your engine might want to deal with things like triangles and vertices in areas other than rendering (ex: physics might want such data to do collision detection). But where life started to get a lot easier (at least for me) was to embrace this kind of reversal in mindset and strategy as the starting point.</p><p>And designing a real-time renderer is very hard in my experience -- the hardest thing I&#39;ve ever designed (and keep re-designing) with the rapid changes to hardware, shading capabilities, discovered techniques. But this approach does eliminate the immediate concern of when GPU resources can be created/destroyed by centralizing all that to the rendering implementation, and even more beneficial for me is that it shifted what would otherwise be costly and cascading design changes (which could spill into code not immediately concerned with rendering) to just the implementation of the renderer itself. And that reduction in cost of change can add up to enormous savings with something that shifts in requirements every year or two as rapidly as real-time rendering.</p><p><strong>Your Shading Example</strong></p><p>The way I tackle your shading example is that I don&#39;t concern myself with things like GLSL shaders in things like car and person entities. I concern myself with &#34;materials&#34; which are very lightweight CPU objects which just contain properties describing what sort of material it is (skin, car paint, etc). In my actual case it is a bit sophisticated as I have a DSEL similar to Unreal Blueprints for programming shaders using a visual sort of language, but materials don&#39;t store GLSL shader handles.</p><blockquote><blockquote><p>ShaderPrograms count their references and only call glDeleteProgram in their destructor when the count is 0 AND ShaderManager periodically checks for ShaderProgram&#39;s with a count of 1 and discards them.</p></blockquote></blockquote><p>I used to do similar things when I was storing and managing these resources kind of &#34;out there in space&#34; outside the renderer because my earliest naive attempts which just tried to directly destroy those resources in a destructor often tried to destroy those resources outside of a valid GL context (and sometimes I&#39;d even accidentally try to create them in script or something when I wasn&#39;t in a valid context), so I needed to defer creation and destruction to cases where I could guarantee I was in a valid context which lead to similar &#34;manager&#34; designs you describe.</p><p>All of these issues go away if you&#39;re storing a CPU resource in its place and have the renderer deal with the concerns of the GPU resource management. I can&#39;t destroy an OGL shader anywhere but I can destroy a CPU material anywhere and easily use <code>shared_ptr</code> and so forth without getting myself into trouble.</p><blockquote><blockquote><p>When to actually clear ShaderPrograms out of the static ShaderManager? Every few minutes? Every Game Loop? I&#39;m gracefully handling the re-compiling of a shader in the case when a ShaderProgram was deleted but then a new WorldEntity requests it; but I&#39;m sure there&#39;s a better way.</p></blockquote></blockquote><p>Now that concern is actually tricky even in my case if you want to efficiently manage the GPU resources and offload them when no longer needed. In my case I can be dealing with massive scenes and I work in VFX rather than games where artists might have particularly intense content not optimized for realtime rendering (epic textures, models spanning millions of polygons, etc).</p><p>It&#39;s very useful for performance not to merely avoid rendering them when they&#39;re offscreen (out of the viewing frustum) but also offload the GPU resources when no longer needed for a while (say the user doesn&#39;t look at something way out in distant space for a while).</p><p>So the solution I tend to use most often is the sort of &#34;timestamped&#34; solution, though I&#39;m not sure how applicable it is with games. When I start using/binding resources for rendering (ex: they pass the frustum culling test), I store the current time with them. Then periodically there&#39;s a check to see if those resources have not been used for a while, and if so, they get unloaded/destroyed (though the original CPU data used to generate the GPU resource is kept until the actual entity storing those components are destroyed or until those components are removed from the entity). As the number of resources increases and more memory is used, the system becomes more aggressive about unloading/destroying those resources (the amount of idle time allowed for an old, unused resource before it is destroyed reduces as the system becomes more taxed).</p><p>I imagine it depends a whole lot on your game design. Since if you have a game with a more segmented approach with like smaller levels/zones, then you might be able to (and find the easiest time keeping frame rates stable) load all those resources necessary for that level in advance and unload them when the user goes to the next level. Whereas if you have some massive open world game that&#39;s seamless that way, you might need a much more sophisticated strategy to control when to create and destroy these resources, and there might be a greater challenge there to do this all without stuttering. In my VFX domain a little hiccup to frame rates isn&#39;t as big of a big deal (I do try to eliminate them within reason) since the user isn&#39;t going to game over as a result of it.</p><p>All of this complexity in my case is still isolated to the rendering system, and while I have generalized classes and code to help implement it, there are no concerns about valid GL contexts and temptations to use globals or anything like that.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../java-how-to-better-isolate-jogl-or-lwjgl3-dependency-from-game-clients/'>Java &#8211; How to better isolate JOGL or LWJGL3 dependency from game clients</a></li><li class="list-group-item"><a href='../c-opengl-multithreading-and-throwing-destructors/'>C++ &#8211; OpenGL, multithreading, and throwing destructors</a></li><li class="list-group-item"><a href='../design-pattern-getting-a-collection-of-objects-from-different-sources/'>Design Pattern: getting a collection of objects from different sources</a></li><li class="list-group-item"><a href='../c-implementing-reference-counting-from-scratch-or-using-shared_ptr-for-resource/'>C++ &#8211; Implementing reference counting from scratch or using shared_ptr for resource</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>