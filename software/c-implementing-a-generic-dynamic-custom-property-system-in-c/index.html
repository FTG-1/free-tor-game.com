<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>C# &#8211; Implementing a generic/dynamic custom property system in C# &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1064771 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1064771" class="post-1064771 software type-software status-publish hentry category-software tag-c tag-dynamic tag-generics tag-net"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">C# &#8211; Implementing a generic/dynamic custom property system in C#</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">c</span><span class="mr-2 badge badge-info">dynamic</span><span class="mr-2 badge badge-warning">generics</span><span class="mr-2 badge badge-primary">net</span></p><div class="entry-content"><p>I have an architecture design problem which I think is appropriate for this site.</p><p><em>Note that I have made an</em> <strong>EDIT</strong> <em>to this post below, reflecting my latest potential solution to this problem.</em></p><p><strong>General problem description:</strong></p><p>My primary goal is to design a software library/program (C#) to automate a very particular type of microscopy experiments. Our experimental setups consists of many distinct hardware devices that generally fall into a limited number of categories:</p><ul><li>Point detector</li><li>XY sample stage</li><li>Autofocus device</li><li>&#8230;</li></ul><p>The natural choice is to design an interface <code>IDevice</code> with some basic properties shared by all devices such as e.g. <code>IDevice.Initialize()</code>, <code>IDevice.Name</code>, &#8230;</p><p>We can even design an abstract class, inheriting <code>IDevice</code>, e.g. <code>DeviceBase</code> implementing some functionalty common to all devices.</p><p>Likewise, we can also design interfaces for specific devices, each time implementing the common stuff (<code>IXYSampleStage</code> might hold e.g. <code>IXYSampleStage.Move(posX, posY)</code> or <code>IXYSampleStage.AxisXStepSize</code>).</p><p>Ultimately, I can implement all these interfaces in the final classes representing specific devices. I think I know what to do there.</p><p>However, not all devices of a class are exactly the same. Some manufacturers offer rich functionality on top of the standard stuff. An XY Stage might have e.g. any number of optional/non-standard parameters to set such as e.g. channel delays, PID control values or whatever.</p><p>To tackle this,</p><blockquote><p>I need a mechanism to add additional properties (not methods,<br /> properties will suffice) to specific device classes. Higher level<br /> code, interacting with the devices should understand these added<br /> properties, be able to get/set them, however many there might be.</p></blockquote><p>So much for the basic design problem.</p><p><strong>What exists already</strong></p><p>There is an OS software program, <a href="https://www.micro-manager.org/" rel="nofollow noreferrer">Micro Manager</a>, which has such a system implemented, be it in C++ (full source <a href="https://github.com/mdcurtis/micromanager-upstream/tree/master/MMDevice" rel="nofollow noreferrer">here</a> and no, I cannot use this SW directly for my purposes):</p><pre><code>class PropertyBase
{
public:
   virtual ~PropertyBase() {}

   // property type
   virtual PropertyType GetType() = 0;

   // setting and getting values
   virtual bool Set(double dVal) = 0;
   virtual bool Set(long lVal) = 0;
   virtual bool Set(const char* Val) = 0;

   virtual bool Get(double&amp; dVal) const = 0;
   virtual bool Get(long&amp; lVal) const = 0;
   virtual bool Get(std::string&amp; strVal) const = 0;

   // Limits
   virtual bool HasLimits() const = 0;
   virtual double GetLowerLimit() const = 0;
   virtual double GetUpperLimit() const = 0;
   virtual bool SetLimits(double lowerLimit, double upperLimit) = 0;

   // Some more stuff left out for brevity
   ...
};
</code></pre><p>Subsequently, the <code>Property</code> class implements some of the pure virtual functions related to the limits.</p><p>Next, <code>StringProperty</code>, <code>IntegerProperty</code> and <code>FloatProperty</code> implement the Get()/Set() methods. These kinds of properties are defined in an enum which allows only these three kinds of property.</p><p>Properties can next be added to a <code>PropertyCollection</code> which is basically a kind of dictionary that is part of a device class.</p><p>This all works nicely. We use MM a lot in the lab for other types of experiments but when trying to do similar things in my C# solution I stumbled about a few more fundamental questions. Most of these have to do with not being quite sure how to leverage specific features offered by C#/.NET (generic but definitely also dynamics, &#8230;) to perhaps improve the existing C++ implementation.</p><p><strong>The questions:</strong></p><p><em>First question</em>:</p><p>To limit the types of properties allowed, MM defines an enum:</p><pre><code>    enum PropertyType {
      Undef,
      String,
      Float,
      Integer
    };
</code></pre><p>Whereas C# has reflection and a lot of built-in support for types/generics. I therefore considered this:</p><pre><code>public interface IProperty&lt;T&gt;
{
   public T value { get; set; }

   ...
}
</code></pre><p>I could next do an abstract <code>PropertyBase&lt;T&gt;</code> and ultimately</p><pre><code>IntegerProperty : PropertyBase&lt;int&gt;
StringProperty : PropertyBase&lt;string&gt;
FloatProperty : PropertyBase&lt;double&gt;
</code></pre><p>But this gets me in trouble when trying to put them into a collection because in .NET following is <a href="https://stackoverflow.com/questions/654752/can-i-create-a-dictionary-of-generic-types">not possible</a>:</p><pre><code>PropertyCollection : Dictionary&lt;string, IProperty&lt;T&gt;&gt;
</code></pre><p>Unless, perhaps, I adopt <a href="https://stackoverflow.com/questions/3215402/collection-of-generic-types">this strategy</a>, i.e. have a non generic base class that only returns a type and then yet more base classes to actually implement my property system. However, this seems convoluted to me. <strong>Is there a better way</strong>?</p><p>I think that utilising the generic language features might allow me to do away with needing all these Get()/Set() methods in the MM example above, as I would be able to know the backing type of my property value.</p><p>I realise this is a very broad question but, there is a big gap between understanding the basics of some language features and being able to fully make the correct design decisions from the outset.</p><p><em>Second question</em></p><p>I am contemplating making my final device classes all inherit from a kind of <code>DynamicDictionary</code> (e.g. similar to the one from <a href="https://github.com/umbraco/Umbraco-CMS/" rel="nofollow noreferrer">here</a>):</p><pre><code>    public class DynamicDictionary : DynamicObject
    {
        internal readonly Dictionary&lt;string, object&gt; SourceItems;

        public DynamicDictionary(Dictionary&lt;string, object&gt; sourceItems)
        {
            SourceItems = sourceItems;
        }
        public override bool TrySetMember(SetMemberBinder binder, object value)
        {
            if (SourceItems.ContainsKey(binder.Name))
            {
                SourceItems[binder.Name.ToLower()] = value;
            }
            else
            {
                SourceItems.Add(binder.Name.ToLower(), value);
            }
            return true;
        }
        public override bool TryGetMember(GetMemberBinder binder, out object result)
        {
            if (SourceItems != null)
            {
                if (SourceItems.TryGetValue(binder.Name.ToLower(), out result))
                {
                    return true;
                }
            }
            result = null;
            return true;
        }
    }
}
</code></pre><p>but instead of <code>&lt;string, object&gt;</code> I would then like to use <code>&lt;string, MyPropertyBase&gt;</code> where the string would be the alias for my property (which would correspond to the design choice from Q1).</p><p>Would doing such a thing make sense from a design standpoint?</p><p>I would actually only need to add custom properties to devices at design time (i.e. when writing a custom device driver). At runtime, I would only need to inspect my custom properties or get/set their values.</p><p>the C++ MM solves this by using a bunch of <code>CreateProperty(&#34;alias&#34;, Property)</code> methods in the device constructor, which again, works so maybe using dynamics here is overkill. But again, I am wondering if somebody could provide insight in possible advantages but certainly also disadvantages of going down the dynamic route.</p><p><strong>To summarize</strong></p><p>Are there .NET features (4.5) which I could leverage to implement some of the MM concepts in a more elegant way with a focus on the above mentioned specific matters?</p><p>Again, I do realise this is a very broad question and perhaps some of the possible answers are more a matter of taste/style than anything els but if so (this making the question unsuited for this platform), please provide feedback/comments such that I can adjust accordingly.</p><p><strong>EDIT</strong></p><p>I have spent some more thinking about this and tried to solve it in the following way:</p><p>First, an enum specifying the allowed propertytypes:</p><pre><code>public enum PropertyType
{
    Undefined,
    String,
    Float,
    Integer
}
</code></pre><p>Second, an interface <code>IPropertyType</code> that is responsible for checking values fed to a property of a specific type:</p><pre><code>public interface IPropertyType
{   
    Type BackingType { get; }

    PropertyType TypeAlias { get; }

    bool IsValueTypeValid(object value);
}
</code></pre><p>Then, a base class implementing <code>IPropertyType</code>:</p><pre><code>public bool IsValueTypeValid(object value)
    {
        if (value == null)
        {
            return true;
        }

        Type type = value.GetType();

        if (type == this.BackingType)
        {
            return true;
        }

        return false;
    }

...

public Type BackingType
    {
        get
        {
            switch (this.TypeAlias)
            {
                case PropertyType.Integer:
                    return typeof(long);
                case PropertyType.Float:
                    return typeof(double);
                case PropertyType.String:
                    return typeof(string);
                default:
                    return null;
            }
        }
    }
</code></pre><p>I then have three <code>IPropertyType</code>: <code>StringPropertyType</code>, <code>IntegerPropertyType</code> and <code>FloatPropertyType</code> where each time, the property <code>PropertyTypeAlias is set to one of the enum values.</code></p><p>I can now add my IPropertyType to <code>IProperty</code> types:</p><pre><code>public interface IProperty
{
    string Alias { get; }

    /// If we want to limit the property to discrete values.
    Dictionary&lt;string, object&gt; AllowedValues { get; }

    bool HasLimits { get; }

    bool HasValue { get; }

    bool IsReadOnly { get; }

    /// Callback for HW operations using the property value.
    Func&lt;PropertyFuncType, bool&gt; PropertyFunction { set; }

    PropertyType TypeAlias { get; }

    object Value { get; set; }

    void AddAllowedValue(string alias, object value);

    void ClearAllowedValues();

    // On numeric properties, it might be usefull to limit the range of values.
    void SetLimits(object lowerLimit, object upperLimit);

    // These will do stuff on the HW...
    bool TryApply();

    bool TryUpdate();
}
</code></pre><p>Here, the Value setter will run the validation on input value as defined by the <code>IPropertyType</code>.</p><p><code>IProperty</code> is almost fully implemented in <code>PropertyBase</code> which also has a field of <code>IPropertyType</code> which gets set upon instance creation (and cannot be changed thereafter; a property cannot change type.</p><p>From the base class e.g.:</p><pre><code>    public object Value
    {
        get
        {
            return this.storedvalue;
        }

        set
        {
            if (this.propertyType.IsValueTypeValid(value) &amp;&amp; this.IsValueAllowed(value))
            {
                this.storedvalue = value;
            }
        }
    }
</code></pre><p>That only leaves specific <code>IProperty</code> classes: <code>StringProperty</code>, <code>IntegerProperty</code> and <code>FloatProperty</code> where there is only one override, <code>SetLimits()</code> because it relies on comparison of values. Everything else can be in the base class:</p><pre><code>public override void SetLimits(object lowerlimit, object upperlimit)
    {
        // Is false by default
        this.HasLimits = false;

        // Makes no sense to impose limits on a property with discrete values.
        if (this.AllowedValues.Count != 0)
        {
            // If the passed objects are in fact doubles, we can proceed to check them.
            if (this.IsValueTypeValid(lowerlimit) &amp;&amp; this.IsValueTypeValid(upperlimit))
            {
                // In order to allow comparison we need to cast objects to double.
                double lowerdouble = (double)lowerlimit;
                double upperdouble = (double)upperlimit;

                // Lower limit cannot be bigger than upper limit.
                if (lowerdouble &lt; upperdouble)
                {
                    // Passed values are OK, so set them.
                    this.LowerLimit = lowerdouble;
                    this.UpperLimit = upperdouble;

                    this.HasLimits = true;
                }
            }
        }
    }
</code></pre><p>This way, I think I have a system that allows me to have a collection of <code>IProperty</code> that can actually hold data of different types (int, float or string) where for each type of <code>IProperty</code> I have the ability to implement value limits etc (i.e. stuff that is different, depending on the data type)&#8230;</p><p>However, I still have the impression that there are either better ways to do this sort of thing or that I am over engineering things.</p><p>Therefore, any feedback on this is still welcome.</p><p><strong>EDIT 2</strong></p><p>After more searching online I believe the last bits of code posted here in the previous edit are leaning towards the <a href="http://joeyoder.com/Research/metadata/WICSA3/ArchitectureOfAOMsWICSA3.pdf" rel="nofollow noreferrer">Adaptive Object Model</a> &#34;pattern&#34; (if it really is that).</p><p>However, most resources on this topic seem to be quite old and I&#39;m wondering if there are now better ways to achieve these types of things.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>You&#39;re making a type system on top of the existing type system. There is very little benefit to strongly-typed properties that cannot be referenced in compiled code. I have seen this approach used before and it ends up being a mess.</p><p>Just use a key-value store in a single property called <code>ExtendedProperties</code> or some such.</p><p>In other words, you are trying to avoid <code>Dictionary&lt;string, object&gt;</code>, but in that effort you are re-inventing the .Net type system.</p><p>Attach a property called <code>ExtendedProperties</code> of type <code>Dictionary&lt;string, object&gt;</code> and be done with it. The limitations of loosely-typed data are less costly than the road you&#39;re going down.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../c-should-i-expose-a-computed-value-as-a-property-or-a-method/'>C# &#8211; Should I expose a &#8220;computed&#8221; value as a property or a method</a></li><li class="list-group-item"><a href='../c-force-derived-class-to-implement-static-method-c/'>C# &#8211; Force Derived Class to Implement Static Method C#</a></li><li class="list-group-item"><a href='../c-how-to-add-properties-to-subclasses-and-access-them-without-casting-from-a-superclass/'>C# &#8211; How to add properties to subclasses and access them without casting from a superclass</a></li><li class="list-group-item"><a href='../c-whats-the-best-way-to-handle-updates-only-when-a-value-has-changed/'>C# &#8211; What&#8217;s the best way to handle updates only when a value has changed</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>