<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="https://free-tor-game.com/wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Is Liskov Substitution Principle incompatible with Introspection or Duck Typing &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js?ver=11.2.0' id='highlight-js'></script>     <script>( function( w, d, s, l, i ) {
				w[l] = w[l] || [];
				w[l].push( {'gtm.start': new Date().getTime(), event: 'gtm.js'} );
				var f = d.getElementsByTagName( s )[0],
					j = d.createElement( s ), dl = l != 'dataLayer' ? '&l=' + l : '';
				j.async = true;
				j.src = 'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
				f.parentNode.insertBefore( j, f );
			} )( window, document, 'script', 'dataLayer', ' ' );</script>      <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1071758 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="https://free-tor-game.com/3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="https://free-tor-game.com/contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1071758" class="post-1071758 software type-software status-publish hentry category-software tag-dynamic-languages tag-liskov-substitution tag-object-oriented"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Is Liskov Substitution Principle incompatible with Introspection or Duck Typing</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">dynamic-languages</span><span class="mr-2 badge badge-info">liskov-substitution</span><span class="mr-2 badge badge-warning">object-oriented</span></p><div class="entry-content"><p>Do I understand correctly that <a href="http://en.wikipedia.org/wiki/Liskov_Substitution_Principle" rel="nofollow">Liskov Substitution Principle</a> cannot be observed in languages where objects can inspect themselves, like what is usual in duck typed languages?</p><p>For example, in Ruby, if a class <code>B</code> inherits from a class <code>A</code>, then for every object <code>x</code> of <code>A</code>, <code>x.class</code> is going to return <code>A</code>, but if <code>x</code> is an object of <code>B</code>, <code>x.class</code> is not going to return <code>A</code>.</p><p>Here is a statement of LSP:</p><blockquote><p>Let <em>q(x)</em> be a property provable about objects <em>x</em> of type <em>T</em>. Then <em>q(y)</em> should be provable for objects <em>y</em> of type <em>S</em> where <em>S</em> is a subtype of <em>T</em>.</p></blockquote><p>So in Ruby, for example,</p><pre class="lang-rb prettyprint-override"><code>class T; end
class S &lt; T; end
</code></pre><p>violate LSP in this form, as witnessed by the property <em>q(x)</em> = <code>x.class.name == &#39;T&#39;</code></p><hr/><p><em>Addition.</em> If the answer is &#34;yes&#34; (LSP incompatible with introspection), then my other question would be: is there some modified &#34;weak&#34; form of LSP which can possibly hold for a dynamic language, possibly under some additional conditions and with only special types of <em>properties</em>.</p><hr/><p><em>Update.</em> For reference, here is another formulation of LSP that I&#39;ve found on the web:</p><blockquote><p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p></blockquote><p>And another:</p><blockquote><p>If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T.</p></blockquote><p>The last one is annotated with:</p><blockquote><p>Note that the LSP is all about expected behaviour of objects. One can only follow the LSP if one is clear about what the expected behaviour of objects is.</p></blockquote><p>This seems to be weaker than the original one, and might be possible to observe, but I would like to see it formalized, in particular explained who decides what the expected behavior is.</p><p>Is then LSP not a property of a pair of classes in a programming language, but of a pair of classes together with a given set of properties, satisfied by the ancestor class?  Practically, would this mean that to construct a subclass (descendant class) respecting LSP, all possible uses of the ancestor class have to be known?  According to LSP, the ancestor class is supposed to be replaceable with any descendant class, right?</p><hr/><p><em>Update.</em> I have already accepted the answer, but i would like to add one more concrete example from Ruby to illustrate the question.  In Ruby, each class is a module in the sense that <code>Class</code> class is a descendant of <code>Module</code> class. However:</p><pre class="lang-rb prettyprint-override"><code>class C; end
C.is_a?(Module) # =&gt; true
C.class # =&gt; Class
Class.superclass # =&gt; Module

module M; end
M.class # =&gt; Module

o = Object.new

o.extend(M) # ok
o.extend(C) # =&gt; TypeError: wrong argument type Class (expected Module)
</code></pre></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Here&#39;s the <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.1223" rel="noreferrer">actual principle</a>:</p><blockquote><p>Let <code>q(x)</code> be a property provable about objects <code>x</code> of type <code>T</code>. Then <code>q(y)</code> should be provable for objects <code>y</code> of type <code>S</code> where <code>S</code> is a subtype of <code>T</code>.</p></blockquote><p>And the excellent <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="noreferrer">wikipedia</a> summary:</p><blockquote><p>It states that, in a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may be substituted for objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).</p></blockquote><p>And some relevant quotes from the paper:</p><blockquote><p>What is needed is a stronger requirement that constrains the behavior of sub-types: properties that can be proved using the specification of an object’s <strong>presumed</strong> type should hold even though the object is actually a member of a subtype of that type...</p><p>A type specification includes the following information: <br/> - The type’s name; <br/> - A description of the type&#39;s value space; <br/> - For each of the type&#39;s methods: <br/> --- Its name; <br/> --- Its signature (including signaled exceptions); <br/> --- Its behavior in terms of pre-conditions and post-conditions.</p></blockquote><p>So on to the question:</p><blockquote><p>Do I understand correctly that Liskov Substitution Principle cannot be observed in languages where objects can inspect themselves, like what is usual in duck typed languages?</p></blockquote><p>No.</p><p><code>A.class</code> returns a class. <br/><code>B.class</code> returns a class.</p><p>Since you can make the same call on the more specific type and get a compatible result, LSP holds. The issue is that with dynamic languages, you can still call things on the result expecting them to be there.</p><p>But let&#39;s consider a statically, structural (duck) typed language. In this case, <code>A.class</code> would return a type with a constraint that it must be <code>A</code> or a subtype of <code>A</code>. This provides the static guarantee that any subtype of <code>A</code> must provide a method <code>T.class</code> whose result is a type that satisfies that constraint.</p><p>This provides a stronger assertion that LSP holds in languages that support duck typing, and that any violation of LSP in something like Ruby occurs more due to normal dynamic misuse than a language design incompatibility.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='https://free-tor-game.com/software/object-oriented-liskov-substitution-principle-strengthening-preconditions/'>Object-oriented &#8211; Liskov Substitution principle &#8211; strengthening preconditions</a></li><li class="list-group-item"><a href='https://free-tor-game.com/software/liskovs-substitution-principle-if-subtype-has-some-extra-behaviour-implemented-which-is-not-present-in-type-then-is-this-violation-of-lsp/'>Liskov&#8217;s substitution principle : If subtype has some extra behaviour implemented, which is not present in type, then is this violation of LSP</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='http://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="https://free-tor-game.com/wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>