<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>The relationship between OpenGL, GLX, DRI, and Mesa3D &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1066396 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1066396" class="post-1066396 software type-software status-publish hentry category-software tag-game-development tag-linux tag-opengl"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">The relationship between OpenGL, GLX, DRI, and Mesa3D</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">game development</span><span class="mr-2 badge badge-info">linux</span><span class="mr-2 badge badge-warning">opengl</span></p><div class="entry-content"><p>I am starting out doing some low-level 3D programming in Linux. I have a lot of experience using the higher level graphics API OpenInventor.</p><p>I know it is not strictly necessary to be aware of how all these things fit together but I&#39;m just curious. I know OpenGL is just a standard for graphics applications. Mesa3D seems to be an open source implementation of this standard.</p><p>So where do GLX and DRI fit? Digging around on Wikipedia and all these websites, I&#39;ve yet to find an explanation of exactly how it all goes together. Where does hardware acceleration happen? What do proprietary drivers have to do with this?</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>Except OpenGL, I never used those libraries, but I&#39;m going to try to guess, by reading wikipedia pages, like you did.</p><p>You seem right about Mesa. Here is the additional info we have :</p><p><a href="http://en.wikipedia.org/wiki/X_Window_System">&#34;The X window system is a computer software system and network protocol that provides a basis GUIs for networked computers. It creates a hardware abstraction layer.&#34;</a></p><p><a href="http://en.wikipedia.org/wiki/GLX">&#34;GLX enables programs wishing to use OpenGL to do so within a window provided by the X Window System.<br/> GLX consists of three parts:<br/> - An API that provides OpenGL functions.<br/> - An extension of the X protocol, which allows the client to send 3D rendering commands
- An extension of the X server that receives the rendering commands from the client and passes them on to the installed OpenGL library<br/> If client and server are running on the same computer and an accelerated 3D graphics card is available, the former two components can be bypassed by DRI. The client program is then allowed to directly access the graphics hardware.&#34;</a></p><p><a href="http://en.wikipedia.org/wiki/Direct_Rendering_Infrastructure">&#34;Direct Rendering Infrastructure (DRI) is an interface used in the X Window System to allow user applications to access the video hardware without requiring data to be passed through the X server.&#34;</a></p><p><a href="http://en.wikipedia.org/wiki/Open_Inventor">&#34;Open Inventor is a C++ 3D graphics API designed to provide a higher layer of programming for OpenGL&#34;</a></p><p>To make things simpler, let&#39;s imagine a simplified flow of data (and commands) that happens at the entries and exits of each of those APIs. At the very beginning we have your application program (compiled code), that you run from your computer. At the end we have images that are displayed on your screen.</p><p>There are several cases which I will restrain to the answers to these questions:<br/> -does your computer have a graphic card (GPU), or only a CPU, to process graphic functions ?<br/> -is your application embedded in a window of the x-window system ?<br/> -if you use the x window system, is the &#34;x server&#34; running on your computer or on an other computer on the network ?<br/> I&#39;ll assume you have the drivers for your GPU if you have one, and that you have Mesa for the software rendering).</p><p>First scenario : you run a graphic application written with OpenInventor, without using to the X Window System, and you don&#39;t have a graphic card. The program flow would be quite similar to :</p><pre><code>Your application
  ↓ (uses functions of)
OpenInventor
  ↓ (calls functions declared by)
OpenGL
  ↓ (redirects function calls to implementation defined by)
Mesa
  ↓ (implemented OpenGL functions to be run on the CPU)
[Probably] Operating System rendering API
  ↓
3D Images on your screen
</code></pre><p>What happens here is called &#34;software rendering&#34; : the graphics command are not handled by any graphic hardware, but instead by your usual CPU, the processor that generally runs software.</p><p>Second scenario : now imagine that with the same conditions as above, you have a graphic card. The flow would look more like this :</p><pre><code>Your application
  ↓ (uses functions of)
OpenInventor
  ↓ (calls functions declared by)
OpenGL
  ↓ (redirects function calls to implementation defined by)
Proprietary Drivers
  ↓ (converts OpenGL commands to GPU commands)
Graphic Card
  ↓
3D Images on your screen
</code></pre><p>What happens now is called &#34;hardware acceleration&#34;, usually faster than the first scenario.</p><p>Third scenario : now let&#39;s introduce the X Window System flow, or at least how I think it is, based on the few Wikipedia lines I read.<br/> Let&#39;s forget about the graphic hardware and API for a while. The flow should look like :</p><pre><code>Your application (X Window System sees it as an &#34;X Client&#34;)
  ↓ (sends requests defined by the X Window System Core Protocol)
X Server
  ↓ (convert your request to graphic commands)
[Probably] Operating System rendering API
  ↓
Windows or 2D images on your screen
</code></pre><p>Note that when using the X Window System, your screen and the computer from which you run your application may not be &#34;directly&#34; connected, but could be connected through a network.</p><p>Fourth scenario : suppose you want to add fancy 3D graphic renderings to your X Client application from the previous example. It seems to me that the X Window System is not originally able to do this, or at least it would necessitate much convoluted code to perform the equivalent of an OpenGL API function.<br/> Luckily you can use GLX to add support for OpenGL commands to the system. You now have :</p><pre><code>Your application
  ↓ (sends graphic requests defined by the &#34;GLX extension to the X Protocol&#34;)
X Server with the GLX extension
  ↓ (convert your request to OpenGL commands)
OpenGL
  ↓ (redirects function calls to implementation defined by)
 ...
</code></pre><p>Now you can reconnect that last arrow to the one after &#34;OpenGL&#34; in the first scenario : you can get 3D images on your screen !</p><p>Finally about what I think understand of the DRI :<br/> It seems to allow Mesa to have access to the GPU, so that would modify the flow of our first scenario into :</p><pre><code>...
  ↓
Mesa
  ↓ (forwards OpenGL commands)
DRI
  ↓ (converts OpenGL commands to GPU commands)
Graphic Card
  ↓
3D Images on your screen
</code></pre><p>And it also seems to short-circuit the flow when using GLX, given the condition that its server and client are on the same computer, and that you have a GPU. In that case the graph of our fourth scenario would simply become :</p><pre><code>Your application
  ↓ (sends graphic requests defined by the &#34;GLX extension to the X Protocol&#34;)
DRI
  ↓ (&#34;catches&#34; OpenGL commands and converts them to GPU commands)
Graphic Card
  ↓
3D Images on your screen
</code></pre><p>That&#39;s it !<br/> Now keep in mind that I&#39;m not an expert in Unix environments, so my best advice is to study the documentation of each of those APIs to know precisely what they can do.<br/> Combining the previous chart into a single one might make things easier to understand. I let this as an exercice to you!</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../android-opengl-and-extending-glsurfaceview/'>Android, OpenGL and extending GLSurfaceView</a></li><li class="list-group-item"><a href='../linux-opengl-programming-should-i-use-glx-or-any-other/'>Linux OpenGL programming, should I use GLX or any other</a></li><li class="list-group-item"><a href='../c-opengls-relationship-to-opengl-es-3-0/'>C++ &#8211; OpenGL&#8217;s relationship to OpenGL ES (3.0)</a></li><li class="list-group-item"><a href='../c-opengl-multithreading-and-throwing-destructors/'>C++ &#8211; OpenGL, multithreading, and throwing destructors</a></li><li class="list-group-item"><a href='../glfw-in-relation-to-opengl/'>GLFW in relation to OpenGL</a></li><li class="list-group-item"><a href='../design-opengl-and-global-state/'>Design &#8211; OpenGL and global state</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>