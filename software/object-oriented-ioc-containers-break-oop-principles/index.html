<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; IOC Containers break OOP Principles &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1066829 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1066829" class="post-1066829 software type-software status-publish hentry category-software tag-inversion-of-control tag-object-oriented tag-solid"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; IOC Containers break OOP Principles</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">inversion-of-control</span><span class="mr-2 badge badge-info">object-oriented</span><span class="mr-2 badge badge-warning">solid</span></p><div class="entry-content"><p>What is the purpose of IOC Containers?  The combined reasons for it can be simplified to the following:</p><p>When using OOP/SOLID Development principles, Dependency Injection gets messy.  Either you have the top-level entry points managing dependencies for multiple levels below themselves and passing dependencies recursively through construction, or you have somewhat duplicate code in factory/builder patterns and interfaces that build dependencies as you need them.</p><p>There is no OOP/SOLID way to perform this <strong><em>AND</em></strong> have super pretty code.</p><p>If that previous statement is true, then how do IOC Containers do it?  As far as I know, they aren’t employing some unknown technique that can&#39;t be done with manual D.I.  So the only explination is that IOC Containers break OOP/SOLID Principles by using static objects private accessors.</p><p>Do IOC Containers break the following principles behind the scenes?  This is the real question since I have a good understanding, but have a feeling somebody else has a better understanding:</p><ol><li><strong>Scope control</strong>.  Scope is the reason for nearly every decision I make on my code design.  Block, Local, Module, Static/Global.  Scope should be very explicit, as much at block-level and as few at Static as possible.  You should see declarations, instantiations, and lifecycle endings.  I trust the language and GC to manage scope as long as I’m explicit with it.  In my research I’ve found that IOC Containers set up most or all dependencies as Static and control them through some AOP implementation behind the scenes.  So nothing is transparent.</li><li><strong>Encapsulation</strong>.  What is the purpose of encapsulation?  Why should we keep private members so?  For practical reasons it is so implementors of our API can’t break the implementation by changing the state (which should be managed by the owner class).  But also, for security reasons, it’s so injections can’t occur that overtake our member states and bypass validation and class control.  So anything (Mocking frameworks or IOC frameworks) that somehow injects code before compile time to allow external access to private members is pretty huge.</li><li><strong>Single Responsibility Principle</strong>.  On the surface, IOC Containers seem to make things cleaner.  But imagine how you would accomplish the same thing without the helper frameworks.  You would have constructors with a dozen or so dependencies being passed in.  That doesn’t mean cover it up with IOC Containers, it is a good thing!  It’s a sign to re-factor your code and follow SRP.</li><li><p><strong>Open/Closed</strong>.   Just like SRP isn’t Class-Only (I apply SRP down to single-responsibility lines, let alone methods).  Open/Closed is not just a high level theory to not alter the code of a class.  It’s a practice of understanding the configuration of your program and having control over what gets altered and what gets extended.  IOC Containers can change the way your classes work altogether partially because:</p><ul><li><p>a.   The main code isn’t making the determination of switching out<br /> dependencies, the framework configuration is.</p></li><li><p>b.   The scope could be altered at a time that isn’t controlled by the<br /> calling members, it is instead determined externally by a static<br /> framework.</p></li></ul></li></ol><p>So the configuration of the class isn’t really closed is it, it alters itself based on the configuration of a third party tool.</p><p>The reason this is a question is because I am not necessarily a master of all IOC Containers.  And while the idea of an IOC Container is nice, they appear to just be a façade that covers up poor implementation.  But in order to accomplish external Scope control, Private member access, and Lazy loading, a lot of non-trivial questionable things have to go on.  AOP is great, but the way it is accomplished through IOC Containers is also questionable.</p><p>I can trust C# and the .NET GC to do what I expect it to.  But I can’t put that same trust in a third party tool that is altering my compiled code to perform workarounds to things I wouldn’t be able to do manually.</p><p>E.G.: Entity Framework and other ORMs create strongly Typed objects and map them to database entities, as well as provide boiler-plate basic functionality to perform CRUD.  Anybody could build their own ORM and continue to follow OOP/SOLID Principles manually.  But those frameworks help us so we don’t have to re-invent the wheel every time.  Whereas IOC Containers, it seems, help us purposely work around OOP/SOLID Principles and cover it up.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><p>I&#39;ll go through your points numerically, but first, there&#39;s something you should be very careful of: <em>don&#39;t conflate how a consumer uses a library with how the library is implemented</em>. Good examples of this are Entity Framework (which you yourself cite as a good library) and ASP.NET&#39;s MVC. Both of these do an awful lot under the hood with, for example, reflection, which would absolutely not be considered good design if you spread it through day-to-day code.</p><p>These libraries are absolutely <strong>not</strong> &#34;transparent&#34; in how they work, or what they&#39;re doing behind-the-scenes. But that&#39;s not a detriment, because they support good programming principles in their <em>consumers</em>. So whenever you talk about a library like this, remember that as a consumer of a library, it&#39;s not your job to worry about its implementation or maintenance. You should only worry about how it helps or hinders the code you write which uses the library. Don&#39;t conflate these concepts!</p><p>So, to go through by point:</p><ol><li><p>Immediately we reach what I can only assume is an example of the above. You say that IOC containers set up most dependencies as static. Well, perhaps some implementation detail of how they work includes static storage (though given that they tend to have an instance of an object like Ninject&#39;s <code>IKernel</code> as their core storage, I doubt even that). But this is not your concern!</p><p>Actually, an IoC container is just as explicit with scope as poor man&#39;s dependency injection. (I&#39;m going to keep comparing IoC containers to poor man&#39;s DI because comparing them to no DI at all would be unfair and confusing. And, to be clear, I&#39;m not using &#34;poor man&#39;s DI&#34; as a pejorative.)</p><p>In poor man&#39;s DI, you&#39;d instantiate a dependency manually, then inject it into the class that needs it. At the point where you construct the dependency, you&#39;d choose what to do with it- store it in a locally scoped variable, a class variable, a static variable, don&#39;t store it at all, whatever. You could pass the same instance into lots of classes, or you could create a new one for each class. Whatever. The point is, to see which is happening, you look to the point- probably near the application root- where the dependency is created.</p><p>Now what about an IoC container? Well, you do exactly the same! Again, going by Ninject terminology, you look at where the binding is set up, and find whether it says something like <code>InTransientScope</code>, <code>InSingletonScope</code>, or whatever. If anything this is potentially clearer, because you have code right there declaring its scope, rather than having to look through a method to track what happens to some object (an object may be scoped to a block, but is it used multiple times in that block or just once, for example). So maybe you&#39;re repelled by the idea of having to use a feature on the IoC container rather than a raw language feature to dictate scope, but as long as you trust your IoC library- which you should!- there&#39;s no real disadvantage to it.</p></li><li><p>I still don&#39;t really know what you&#39;re talking about here. Do IoC containers look at private properties as part of their internal implementation? I don&#39;t know why they would, but again, if they do, it&#39;s not your concern how a library you&#39;re using is implemented.</p><p>Or, maybe, they expose a capability like injecting into private setters? Honestly I&#39;ve never encountered this, and I&#39;m dubious about whether this really is a common feature. But even if it&#39;s there, it&#39;s a simple case of a tool that can be misused. Remember, even without an IoC container, it&#39;s but a few lines of Reflection code to access and modify a private property. It&#39;s something you should almost never do, but that doesn&#39;t mean .NET is bad for exposing the capability. If somebody so obviously and wildly misuses a tool, it&#39;s the person&#39;s fault, not the tool&#39;s.</p></li><li><p>The ultimate point here is similar to 2. The vast majority of the time, <em>IoC containers DO use the constructor!</em> Setter injection is offered for very specific circumstances where, for particular reasons, constructor injection can&#39;t be used. Anybody who uses setter injection all the time to cover up how many dependencies are being passed in is massively absuing the tool. That&#39;s NOT the tool&#39;s fault, it&#39;s theirs.</p><p>Now, if this was a really easy mistake to innocently make, and one that IoC containers encourage, then okay, maybe you&#39;d have a point. It&#39;d be like making every member of my class public then blaming other people when they modify things they shouldn&#39;t, right? But anybody who uses setter injection to cover up violations of SRP is either willfully ignoring or completely ignorant of basic design principles. It&#39;s unreasonable to lay the blame for this at the IoC container.</p><p>That&#39;s <em>especially</em> true because it&#39;s also something you can do just as easily with poor man&#39;s DI:</p><pre><code>var myObject 
   = new MyTerriblyLargeObject { DependencyA = new Thing(), DependencyB = new Widget(), Dependency C = new Repository(), ... };
</code></pre><p>So really, this worry seems completely orthogonal to whether or not an IoC container is used.</p></li><li><p>Changing how your classes work together is not a violation of OCP. If it was, then all dependency inversion would be encouraging a violation of OCP. If this was the case, they wouldn&#39;t both be in the same SOLID acronym!</p><p>Furthermore, neither points a) nor b) come close to having anything to do with OCP. I don&#39;t even know how to answer these with respect to OCP.</p><p>The only thing I can guess is that you think OCP is something to do with behaviour not being altered at runtime, or about where in the code the lifecycle of dependencies is controlled from. It&#39;s not. OCP is about not having to modify existing code when requirements are added or change. It&#39;s all about <em>writing</em> code, not about how code you&#39;ve already written is glued together (though, of course, loose coupling is an important part of achieving OCP).</p></li></ol><p>And one final thing you say:</p><blockquote><p>But I can’t put that same trust in a third party tool that is altering my compiled code to perform workarounds to things I wouldn’t be able to do manually.</p></blockquote><p><em>Yes, you can</em>. There is absolutely no reason for you to think that these tools- relied on by vast numbers of projects- are any more buggy or prone to unexpected behaviour than any other third-party library.</p><h2>Addendum</h2><p>I just noticed your intro paragraphs could use some addressing too. You sardonically say that IoC containers &#34;aren’t employing some secret technique we’ve never heard of&#34; to avoid messy, duplication-prone code to build a dependency graph. And you&#39;re quite right, what they&#39;re doing is actually addressing these things with the same basic techniques as we programmers always do.</p><p>Let me talk you through a hypothetical scenario. You, as a programmer, put together a large application, and at the entry point, where you&#39;re constructing your object graph, you notice you have quite messy code. There are quite a few classes that are used again and again, and every time you build one of those you have to build the whole chain of dependencies under them again. Plus you find you don&#39;t have any expressive way of declaring or controlling the lifecycle of dependencies, except with custom code for each one. Your code is unstructured and full of repetition. This is the messiness you talk about in your intro paragraph.</p><p>So first, you start to refactor a bit- where some repeated code is structured enough you pull it out into helper methods, and so on. But then you start to think- is this a problem that I could perhaps tackle in a <em>general</em> sense, one that isn&#39;t specific to this particular project but could help you in all your future projects?</p><p>So you sit down, and think about it, and decide that there should be a class that can resolve dependencies. And you sketch out what public methods it would need:</p><pre><code>void Bind(Type interfaceType, Type concreteType, bool singleton);
T Resolve&lt;T&gt;();
</code></pre><p><code>Bind</code> says &#34;where you see a constructor argument of type <code>interfaceType</code>, pass in an instance of <code>concreteType</code>&#34;. The additional <code>singleton</code> parameter says whether to use the same instance of <code>concreteType</code> each time, or always make a new one.</p><p><code>Resolve</code> will simply try to construct <code>T</code> with any constructor it can find whose arguments are all of types which have previously been bound. It can also call itself recursively to resolve the dependencies all the way down. If it can&#39;t resolve an instance because not everything has been bound, it throws an exception.</p><p>You can try implementing this yourself, and you&#39;ll find you need a bit of reflection, and some caching for the bindings where <code>singleton</code> is true, but certainly nothing drastic or horrifying. And once you&#39;re done- <em>voila</em>, you have the core of your very own IoC container! Is it really that scary? The only real difference between this and Ninject or StructureMap or Castle Windsor or whatever one you prefer is that those have a lot more functionality to cover the (many!) use cases where this basic version wouldn&#39;t be sufficient. But at its heart, what you have there is the essence of an IoC container.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../sell-me-on-ioc-containers-please/'>Sell me on IoC containers, please</a></li><li class="list-group-item"><a href='../object-oriented-applying-solid-principles/'>Object-oriented &#8211; Applying SOLID principles</a></li><li class="list-group-item"><a href='../solid-vs-static-methods/'>SOLID vs. static methods</a></li><li class="list-group-item"><a href='../c-single-responsibility-principle-how-to-avoid-code-fragmentation/'>C# &#8211; Single Responsibility Principle &#8211; How to Avoid Code Fragmentation</a></li><li class="list-group-item"><a href='../dependency-injection-ioc-container-practices-when-writing-frameworks/'>Dependency Injection/IoC container practices when writing frameworks</a></li><li class="list-group-item"><a href='../how-is-inversion-of-control-related-to-dependency-inversion/'>How is Inversion of Control related to Dependency Inversion</a></li><li class="list-group-item"><a href='../object-oriented-depend-on-abstractions-not-on-concretions-what-is-the-exact-meaning-of-this-term/'>Object-oriented &#8211; “Depend on abstractions, not on concretions” what is the exact meaning of this term</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>