<!doctype html><html lang="en-US"><!--  --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- / -->
<head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1">  <link media="all" href="../../wp-content/cache/autoptimize/4/css/autoptimize_dc56928889f08ceb40a4520f8ece953b.css" rel="stylesheet" /><title>Object-oriented &#8211; Did the gradual shift in methodology of writing code affect system performance? And Should I care &#8211; free-tor-game.com</title> <script>MathJax = {
  tex: {
    inlineMath: [['$','$'],['\\(','\\)']], 
    processEscapes: true
  },
  options: {
    ignoreHtmlClass: 'tex2jax_ignore|editor-rich-text'
  }
};</script> <link rel='dns-prefetch' href='http://cdn.jsdelivr.net/' /><link rel='dns-prefetch' href='http://cdnjs.cloudflare.com/' /><link rel='dns-prefetch' href='http://stackpath.bootstrapcdn.com/' /><link rel='dns-prefetch' href='http://s.w.org/' /><link rel='stylesheet' id='highlight-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/vs2015.min40df.css?ver=5.6' type='text/css' media='all' /><link rel='stylesheet' id='bootstrap-css'  href='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.mina352.css?ver=4.1.3' type='text/css' media='all' /><link rel='stylesheet' id='icons-css'  href='../../../stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min40df.css?ver=5.6' type='text/css' media='all' /> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.minb8ff.js?ver=1.12.4' id='jquery-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.minc9a3.js?ver=11.2.0' id='highlight-js'></script>            <script>hljs.highlightAll();</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1731162805004860" crossorigin="anonymous"></script></head><body class="software-template-default single single-software postid-1070765 no-sidebar"><div id="page" class="site"> <a class="skip-link screen-reader-text" href="#content">Skip to content</a><header id="topnav" class="sticky-top"><nav class="navbar navbar-expand-md navbar-light bg-light" role="navigation"> <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-primary" aria-controls="navbar-primary" aria-expanded="false" aria-label="Toggle navigation"> <span class="navbar-toggler-icon"></span> </button> <a class="navbar-brand" href="#">free-tor-game.com</a><div id="navbar-primary" class="collapse navbar-collapse"><ul id="menu-primary-top-menu" class="nav navbar-nav"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-192" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item-has-children dropdown menu-item-192 nav-item"><a title="Tools" href="#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false" class="dropdown-toggle nav-link" id="menu-item-dropdown-192">Tools</a><ul class="dropdown-menu" aria-labelledby="menu-item-dropdown-192" role="menu"><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-193" class="menu-item menu-item-type-post_type menu-item-object-post menu-item-193 nav-item"><a title="ARFCN-Frequency Converter" href="../../3gpp-arfcn-frequency-converter/" class="dropdown-item">ARFCN-Frequency Converter</a></li></ul></li><li itemscope="itemscope" itemtype="https://www.schema.org/SiteNavigationElement" id="menu-item-2301" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-2301 nav-item"><a title="Contact Us" href="../../contact/" class="nav-link">Contact Us</a></li></ul></div></nav></header><div id="content" class="site-content"><div id="primary" class="content-area"><main id="main" class="site-main"><div id="main-container" class="container"><div id="main-row" class="row"><div id="main-col" class="col-12"><article id="post-1070765" class="post-1070765 software type-software status-publish hentry category-software tag-dependency-injection tag-object-oriented tag-performance tag-refactoring"><div class="row"><div class="col-12 col-md-8"><header class="entry-header"><h1 class="entry-title text-danger">Object-oriented &#8211; Did the gradual shift in methodology of writing code affect system performance? And Should I care</h1></header><p style='font-size:1.2em'><span class="mr-2 badge badge-success">dependency-injection</span><span class="mr-2 badge badge-info">object-oriented</span><span class="mr-2 badge badge-warning">performance</span><span class="mr-2 badge badge-primary">refactoring</span></p><div class="entry-content"><p><strong>TD;DR:</strong></p><p>There was some confusion as to what I was asking, so here is the driving idea behind the question:</p><blockquote><p>I always intended the question to be what it is. I may not have articulated it well originally. But intent have always been &#34;<em>is modular, separated, loose coupled, decoupled, refactored code</em>&#34; markedly slower by its own nature than &#34;<em>monolithic single-unit, do-everything in one place, one file, tightly coupled</em>&#34; code. The rest is just details and various manifestations of this that I came across then or now or will later. It is slower for sure on some scale. Like a non-defragged disk, you have to pick up the pieces from everywhere. It&#39;s slower. For sure. But should I care?</p></blockquote><p>And the question is not about&#8230;</p><blockquote><p>not about micro-optimization, premature optimization, etc.  It is not about &#34;optimize this or that part to death&#34;.</p></blockquote><p>What is it then?</p><blockquote><p>It is about the <em>overall</em> methodology and techniques and ways of thinking about writing code that emerged over time:</p><ul><li>&#34;inject this code into your class as a dependency&#34;</li><li>&#34;write one file per class&#34;</li><li>&#34;separate your view from your database, controller, domain&#34;.</li><li>don&#39;t write spaghetti homogenious single codeblock, but write many separate modular components that work together</li></ul><p>It is about the way and the style of code that is currently &#8211; within this decade &#8211; seen and advocated in most frameworks, advocated at conventions, passed on via the community.  It is a shift in thinking from &#39;monolithic blocks&#39; to &#39;microservices&#39;.  And with that comes the price in terms of machine-level performance and overhead, and some programmer-level overhead as well.</p></blockquote><p><strong>Original Question follows:</strong></p><p>In Computer Science field, I have noticed a notable shift in thinking when it comes to programming.  I come across the advice quite often that goes like this:</p><ul><li>write smaller function-wise code (more testable and maintainable this way)</li><li>refactor existing code into smaller and smaller chunks of code until most of your methods/functions are just a few lines long and it is clear what is their purpose (which creates more functions, compared to a larger monolithic block)</li><li>write functions that only do one thing &#8211; separation of concerns, etc (which usually creates more functions and more frames on a stack)</li><li>create more files (one class per file, more classes for decomposition purposes, for layer purposes such as MVC, domain architecture, design patterns, OO, etc, which creates more file system calls)</li></ul><p>This is a change compared to the &#34;old&#34; or &#34;outdated&#34; or &#34;spaghetti&#34; coding practices where you have methods spanning 2500 lines, and big classes and god objects doing everything.</p><p><strong>My question is this:</strong></p><p>when it call comes down to machine code, to 1s and 0s, to assembly instructions, to HDD platters, should I be at all concerned that my perfectly class-separated OO code with variety of refactored small-to-tiny functions and methods generates too much extra overhead?</p><p><strong>Details</strong></p><p>While I am not intimately familiar with how OO code and its method calls are handled in ASM in the end, and how DB calls and compiler calls translate to moving actuator arm on a HDD platter, I do have some idea.  I assume that each extra function call, object call, or &#34;#include&#34; call (in some languages), generate an extra set of instructions, thereby increasing code&#39;s volume and adding various &#34;code wiring&#34; overheads, <em>without adding actual &#34;useful&#34; code</em>.  I also imagine that good optimizations can be done to ASM before it is actually ran on the hardware, but that optimization can only do so much too.</p><p>Hence, my question &#8212; how much overhead (in space and speed) does well-separated code (code that is split up across hundreds of files, classes, and design patterns, etc) actually introduce compared to having &#34;one big method that contains everything in one monolithic file&#34;, due to this overhead?</p><p><strong>UPDATE for clarity:</strong></p><p>I am assuming that taking the same code and <em>splitting it, refactoring it out, decoupling it</em> into more and more functions and objects and methods and classes will result in more and more <em>parameter passing</em> between smaller code pieces.  Because for sure, refactoring code has to keep the thread going, and that requires parameter passing.  More methods or more classes or more Factory Methods design patterns, results in more overhead of passing various bits of information <em>more</em> than it is the case in a single monolithic class or method.</p><p>It was said somewhere (quote TBD) that up to 70% of all code is made up of ASM&#39;s MOV instruction &#8211; loading CPU registers with proper variables, not the actual computation being done.  In my case, you load up CPU&#39;s time with PUSH/POP instructions to provide linkage and parameter passing between various pieces of code.  The smaller you make your pieces of code, the more overhead &#34;linkage&#34; is required.  I am concerned that this linkage adds to software bloat and slow-down and I am wondering if I should be concerned about this, and how much, if any at all, because current and future generations of programmers who are building software for the next century, will have to live with and consume software built using these practices.</p><p><strong>UPDATE:  Multiple files</strong></p><p>I am writing new code now that is slowly replacing old code.  In particular I&#39;ve noted that one of the old classes was a ~3000 line file (as mentioned earlier).  Now it is becoming a set of 15-20 files located across various directories, including test files and not including PHP framework I am using to bind some things together. More files are coming as well. When it comes to disk I/O, loading multiple files is slower than loading one large file.  Of course not all files are loaded, they are loaded as needed, and disk caching and memory caching options exist, and yet still I believe that <code>loading multiple files</code> takes more processing than <code>loading a single file</code> into memory.  I am adding that to my concern.</p><p><strong>UPDATE: Dependency Inject everything</strong></p><p>Coming back to this after a while.. I think my question was misunderstood.  Or maybe I chose to misunderstand some answers.  I am not talking about micro-optimizing as some answers have singled out, (at least I think calling what I am talking about micro-optimization is a misnomer) but about the movement of &#34;Refactor code to loosen tight coupling&#34;, as a whole, at every level of the code.  I came from Zend Con just recently where this style of code has been one of the core points and centerpieces of the convention.  Decouple logic from view, view from model, model from database, and if you can, decouple data from the database.  Dependency-Inject everything, which sometimes means just adding wiring code (functions, classes, boilerplate) that does <em>nothing</em>, but serves as a seam/hook point, easily doubling code size in most cases.</p><p><strong>UPDATE 2:  Does &#34;separating code into more files&#34; significantly affect performance (at all levels of computing)</strong></p><p>How does philosophy of <code>compartmentalize your code into multiple files</code> impact today&#39;s computing (performance, disk utilization, memory management, CPU processing tasks)?</p><p>I am talking about</p><p><strong>Before&#8230;</strong></p><p>In a hypothetical yet quite real not so distant past, you could easily write one mono-block of a file that does has model and view and controller spaghetti or not-spaghetti-coded, but that runs <em>everything</em> once it is already loaded.  Doing some benchmarks in the past using C code I found out that it is MUCH faster to load a single 900Mb file into memory and process it in large chunks than it is to load a bunch of smaller files and process them in a smaller peace-meal chunks doing the same work in the end.</p><p><strong>.. And Now*</strong></p><p>Today I find myself looking at code that shows a ledger, that has features like .. if an item is an &#34;order&#34;, show order HTML block.  If a line item can be copied, print HTML block that displays an icon and HTML parameters behind it allowing you to make the copy.  If the item can be moved up or down, display the appropriate HTML arrows.  Etc.  I can, through Zend Framework create <code>partial()</code> calls, which essentially means &#34;call a function that takes your parameters and inserts them into a separate HTML file that it also calls&#34;.  Depending on how detailed I want to get, I can create separate HTML functions for the tiniest parts of the ledger.  One for arrow up, arrow down, one for &#34;can I copy this item&#34;, etc.  Easily creating several files just to display a small part of the webpage.  Taking my code and behind-the-scenes Zend Framework code, the system/stack probably calls close to 20-30 different files.</p><p><strong>What?</strong></p><p>I am interested in aspects, the <em>wear and tear</em> on the machine that is created by compartmentalizing code into many smaller separate files.</p><p>For example, loading more files means having them located in various places of the file system, and in various places of physical HDD, which means more HDD seek and read time.</p><p>For CPU it probably means more context switching and loading various registers.</p><p>In this sub-block (update #2) I am interested more strictly in how using multiple files to do the same tasks that could be done in a single file, affect system performance.</p><p><strong>Using Zend Form API vs simple HTML</strong></p><p>I used Zend Form API with latest and greatest modern OO practices, to build an HTML form with validation, transforming <code>POST</code> into domain objects.</p><p><em>It took me 35 files to make it.</em></p><pre><code>35 files = 
    = 10 fieldsets x {programmatic fieldset + fieldset manager + view template} 
    + a few supporting files
</code></pre><p>All of which could be replaced with a a few simple HTML + PHP + JS + CSS files, perhaps total of 4 light-weight files.</p><p>Is it better? Is it worth? &#8230; Imagine loading 35 files + numerous Zend Zramework library files that make them work, vs 4 simple files.</p></div>     <div id="comments" class="comments-area"><div class="row"><div class="col-12"><div class="mt-3 border-bottom border-success"><h4 class="text-success"><i class='fa fa-check-circle text-success mr-3'></i><span>Best Answer</span></h4></div><div class='bg-transparent mb-3'><blockquote><p>My question is this: when it call comes down to machine code, to 1s
 and 0s, to assembly instructions, should I be at all concerned that my
 class-separated code with variety of small-to-tiny functions generates
 too much extra overhead?</p></blockquote><p>MY answer is yes, you should. Not because you have lots of little functions (once upon a time the overhead of calling functions was reasonably significant and you could slow your program down by making a million little calls in loops, but today compilers will inline them for you and what&#39;s left is taken care of by the CPU fancy prediction algorithms, so don&#39;t worry about that) but because you will introduce the concept of layering too much into your programs when the functionality is too small to sensibly grok in your head. If you have larger components you can be reasonably sure they are not performing the same work over and over, but you can make your program so minutely granular that you may find yourself unable to really understand the call paths, and in that end up with something that barely works (and is barely maintainable).</p><p>For example, I worked at a place that showed me a reference project for a web service with 1 method. The project comprised 32 .cs files - for a single web service! I figured this was way too much complexity, even though each part was tiny and easily understood by itself, when it came to describing the overall system, I quickly found myself having to trace through calls just to see what the hell it was doing (there were also too many abstractions involved,as you&#39;d expect). My replacement webservice was 4 .cs files.</p><p>i didn&#39;t measure performance as I figure it would have been roughly the same all in all, but I can guarantee mine was significantly cheaper to maintain. When everyone talks of programmer time being more important than CPU time, then create complex monsters that cost lots of programmer time in both dev and maintenance you have to wonder that they are making excuses for bad behaviour.</p><blockquote><p>It was said somewhere (quote TBD) that up to 70% of all code is made
 up of ASM&#39;s MOV instruction - loading CPU registers with proper
 variables, not the actual computation being done.</p></blockquote><p>That <em>is</em> what CPUs do though, they move bits from memory to registers, add or subtract them, and then put them back into memory. All computing boils down to pretty much that. Mind you, I once had a very multi-threaded program that spent most of its time context switching (ie saving and restoring register state of threads) than it did working on the thread code. A simple lock in the wrong place truly screwed performance there, and it was such an innocuous bit of code too.</p><p>So my advice is : find a sensible middle ground between either extreme that make your code look good to other humans, and test the system to see if it performs well. Use the OS features to make sure its running as you&#39;d expect with CPU, memory, disk and network IO.</p></div></div><div class="col-4"></div></div></div></div><div class="col-12 col-md-4"> <ins class="adsbygoogle"
 style="display:block"
 data-ad-client="ca-pub-1731162805004860"
 data-ad-slot="1340983829"
 data-ad-format="auto"
 data-full-width-responsive="true"></ins>   <div class='mt-3 ml-4 border-bottom border-success'><h6><span>Related Question</span></h6></div><ul class='list-group list-group-flush'><li class="list-group-item"><a href='../when-should-i-care-about-performance/'>When should I care about performance</a></li><li class="list-group-item"><a href='../object-oriented-oop-separate-manager-class/'>Object-oriented &#8211; OOP &#8211; Separate Manager class</a></li><li class="list-group-item"><a href='../object-oriented-the-purpose-of-writing-functions-and-methods-when-should-you-make-a-snippet-of-code-into-a-function-or-method/'>Object-oriented &#8211;  the purpose of writing functions and methods? When should you make a snippet of code into a function or method</a></li><li class="list-group-item"><a href='../is-it-the-correct-practice-to-keep-more-than-10-years-old-spaghetti-legacy-code-untouched-without-refactoring-at-all-in-big-product-development/'>Is it the correct practice to keep more than 10 years old spaghetti legacy code untouched without refactoring at all in big product development</a></li></ul></div></div><footer class="entry-footer"></footer></article></div></div></div></main></div></div><footer id="colophon" class="site-footer"><div class="site-info"></div></footer></div>    <script type='text/javascript' src='../../../cdn.jsdelivr.net/npm/mathjax%403/es5/tex-chtml40df.js?ver=5.6' id='mathjax-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/esm/popper.min43d3.js?ver=1.14.7' id='popper-js'></script> <script type='text/javascript' src='../../../cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min5b31.js?ver=4.3.1' id='bootstrap4-js'></script> <script type='text/javascript' id='itectec-common-js-extra'>var globalObject = {"homeUrl":"https:\/\/free-tor-game.com\/"};</script> <script defer src="../../wp-content/cache/autoptimize/4/js/autoptimize_63b39f43631847816e6b0e70ea726624.js"></script></body></html>